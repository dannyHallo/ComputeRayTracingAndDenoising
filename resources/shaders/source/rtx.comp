#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// Include definitions for ubo, triangle, material, etc.
#include "include/definitions.glsl"

layout(binding = 0) uniform UniformBufferObject {
  vec3 camPos;
  vec3 camFront;
  vec3 camUp;
  vec3 camRight;
  float vfov;
  float time;
  uint currentSample;
  uint numTriangles;
  uint numLights;
  uint numSpheres;
}
ubo;

layout(binding = 1, rgba32f) uniform image2D posTex;
layout(binding = 2, rgba32f) uniform image2D normalTex;
layout(binding = 3, r32f) uniform image2D depthTex;
layout(binding = 4, r32ui) uniform uimage2D meshHashTex1;
layout(binding = 5, rgba32f) uniform image2D rawTex;

layout(std430, binding = 6) readonly buffer TriangleBufferObject {
  triangle[] triangles;
};

layout(std430, binding = 7) readonly buffer MaterialBufferObject {
  material[] materials;
};

layout(std430, binding = 8) readonly buffer AabbBufferObject { bvhNode[] bvh; };

layout(std430, binding = 9) readonly buffer LightsBufferObject {
  light[] lights;
};

layout(std430, binding = 10) readonly buffer SpheresBufferObject {
  sphere[] spheres;
};

#include "include/random.glsl"

struct ray {
  vec3 origin;
  vec3 dir;
};

vec3 ray_at(ray r, float t) { return r.origin + t * r.dir; }

struct hitRecord {
  vec3 p;
  vec3 normal;
  uint materialIndex;
  float t;
  uint meshHash;
  // representing whetether backface or not with an integer to decrease
  // branches.
  int backFaceInt;
};

bool triIntersect(vec3 origin, vec3 dir, triangle tri, out vec3 normal,
                  out vec2 uv, out float tNear) {
  vec3 e1 = tri.v1 - tri.v0;
  vec3 e2 = tri.v2 - tri.v0;
  vec3 s = origin - tri.v0;
  vec3 s1 = cross(dir, e2);
  vec3 s2 = cross(s, e1);

  vec3 sol = vec3(dot(s2, e2), dot(s1, s), dot(s2, dir));
  float s1e1Inv = 1 / dot(s1, e1);
  sol *= s1e1Inv;

  tNear = sol.x;
  uv.xy = sol.yz;
  normal = vec3(0.0);

  if (uv.x >= 0 && uv.y >= 0 && (1 - uv.x - uv.y) >= 0 && tNear > 0) {
    normal = normalize(cross(e1, e2)); // only calculate normal when hit
    return true;
  }
  return false;
}

// wrapper function
bool hit_triangle(int triangle_index, ray r, float tMin, float tMax,
                  inout hitRecord rec) {
  triangle tri = triangles[triangle_index];

  vec3 normal;
  vec2 uv;
  float tNear;
  if (triIntersect(r.origin, r.dir, tri, normal, uv, tNear)) {
    rec.backFaceInt = int(step(0, dot(r.dir, normal)));
    rec.normal =
        normal * (1 - 2 * rec.backFaceInt); // make normal points to cam
    rec.p = r.origin + tNear * r.dir;
    rec.t = tNear;
    rec.materialIndex = tri.materialIndex;
    rec.meshHash = tri.meshHash;

    return tNear > tMin && tNear < tMax;
  }
  return false;
}

// Hit scene without bvh.
bool hit_scene(ray r, inout hitRecord rec) {
  float t_min = 0.001;
  float t_max = 10000;

  hitRecord temp_rec;
  bool hit_anything = false;
  float closest_so_far = t_max;

  for (int i = 0; i < ubo.numTriangles; i++) {
    // for (int i = 0; i < 4; i++) {
    if (hit_triangle(i, r, t_min, closest_so_far, temp_rec)) {
      hit_anything = true;
      closest_so_far = temp_rec.t;
      rec = temp_rec;
    }
  }

  return hit_anything;
}

// no intersection means vec.x > vec.y (really tNear > tFar)
bool intersectAABB(ray r, vec3 boxMin, vec3 boxMax) {
  vec3 tMin = (boxMin - r.origin) / r.dir;
  vec3 tMax = (boxMax - r.origin) / r.dir;
  vec3 t1 = min(tMin, tMax);
  vec3 t2 = max(tMin, tMax);
  float tNear = max(max(t1.x, t1.y), t1.z);
  float tFar = min(min(t2.x, t2.y), t2.z);
  return tNear <= tFar;
}

// Works only for triangles, no spheres yet.
#define MAX_STACK_DEPTH 16
bool hit_bvh(ray r, inout hitRecord rec) {
  float t_min = 0.001;
  float t_max = 10000;

  bool hit_anything = false;
  float closest_so_far = t_max;

  // Since shader doesn't have a stack structure, implementing it with an array
  // and a counter.
  int nodeStack[MAX_STACK_DEPTH];
  int stackIndex = 0;

  // Traversing a flattened bvh using a stack.
  // nodeStack[stackIndex] contains an index of AABB in bvh[]
  // bvh[nodeStack[stackIndex]] is an index of a triangle in triangles.
  nodeStack[stackIndex] = 0;
  stackIndex++;

  while (stackIndex > 0 && stackIndex < MAX_STACK_DEPTH) {
    stackIndex--;
    int currentNode = nodeStack[stackIndex];
    if (currentNode == -1)
      continue;

    bool intersect =
        intersectAABB(r, bvh[currentNode].min, bvh[currentNode].max);
    if (!intersect) // no intersection
      continue;

    // object index will only exist if it is a leaf node, otherwise, the index
    // is -1 (invalid)
    int ti = bvh[currentNode].objectIndex;
    if (ti != -1) {
      hitRecord temp_rec;
      if (hit_triangle(ti, r, t_min, closest_so_far, temp_rec)) {
        hit_anything = true;
        closest_so_far = temp_rec.t;
        rec = temp_rec;
      }
    }

    nodeStack[stackIndex++] = bvh[currentNode].leftNodeIndex;
    nodeStack[stackIndex++] = bvh[currentNode].rightNodeIndex;
  }

  return hit_anything;
}

vec3 pathTracingRayColorIndirect(ray r) {
  hitRecord rec;
  vec3 colReturn = vec3(0.0, 0.0, 0.0);

  if (!hit_bvh(r, rec)) {
    return vec3(0);
  }

  if (materials[rec.materialIndex].materialType == LIGHT_MATERIAL) {
    return materials[rec.materialIndex].albedo;
  }

  // direct lighting
  for (int i = 0; i < ubo.numLights; i++) {
    uint lightId = lights[i].triangleIndex;
    float lightArea = lights[i].area;

    vec3 e1 = triangles[lightId].v1 - triangles[lightId].v0;
    vec3 e2 = triangles[lightId].v2 - triangles[lightId].v0;
    vec3 lightNormal = normalize(
        cross(e1, e2)); // CAUTION: direction is unfixed! lit from both sides!

    vec2 randomUV = random_uv();
    float x = randomUV.x;
    float y = randomUV.y;

    x = random();
    y = random();

    if (x + y > 1) {
      x = 1 - x;
      y = 1 - y;
    }
    vec3 randomSamplingPointOnLight = triangles[lightId].v0 + e1 * x + e2 * y;

    vec3 o2l = randomSamplingPointOnLight - rec.p;
    float distSqr = dot(o2l, o2l);
    float dist = sqrt(distSqr);

    o2l /= dist;
    hitRecord rec2;
    if (hit_bvh(ray(rec.p + rec.normal * 0.0001, o2l), rec2)) {
      if (materials[rec2.materialIndex].materialType == LIGHT_MATERIAL) {
        colReturn += materials[rec2.materialIndex].albedo *
                     dot(o2l, rec.normal) * abs(dot(o2l, lightNormal)) /
                     distSqr * lightArea;
      }
    }
  }

  return materials[rec.materialIndex].albedo * colReturn;
}

void pathTracing(ray r, out vec3 colReturn, out vec4 hitWorldPos,
                 out vec4 hitNormal, out float hitDepth, out uint meshHash) {
  hitRecord rec;

  colReturn = vec3(0, 0, 0);
  hitWorldPos = vec4(0, 0, 0, -1);
  hitNormal = vec4(0, 0, 0, -1);
  hitDepth = -1;
  meshHash = 0;

  // not hit bvh
  if (!hit_bvh(r, rec)) {
    colReturn = vec3(1, 1, 0); // background color
    return;
  }

  hitWorldPos = vec4(rec.p, 1);
  hitNormal = vec4(rec.normal, 0);
  hitDepth = rec.t;
  meshHash = rec.meshHash;

  // hit light directly
  if (materials[rec.materialIndex].materialType == LIGHT_MATERIAL) {
    colReturn = materials[rec.materialIndex].albedo;
    return;
  }

  // direct lighting
  vec2 randomUV = random_uv();
  float x = randomUV.x;
  float y = randomUV.y;

  x = random();
  y = random();

  int i = 0;
  if (x + y > 1) {
    x = 1 - x;
    y = 1 - y;
    i = 1;
  }

  uint lightId = lights[i].triangleIndex;
  float lightArea = lights[i].area;

  vec3 e1 = triangles[lightId].v1 - triangles[lightId].v0;
  vec3 e2 = triangles[lightId].v2 - triangles[lightId].v0;
  vec3 lightNormal = normalize(
      cross(e1, e2)); // CAUTION: direction is unfixed! lit from both sides!

  vec3 randomSamplingPointOnLight = triangles[lightId].v0 + e1 * x + e2 * y;

  vec3 o2l = randomSamplingPointOnLight - rec.p;
  float distSqr = dot(o2l, o2l);
  float dist = sqrt(distSqr);

  o2l /= dist;
  hitRecord rec2;
  if (hit_bvh(ray(rec.p + rec.normal * 0.0001, o2l), rec2)) {
    if (materials[rec2.materialIndex].materialType == LIGHT_MATERIAL) {
      colReturn += materials[rec2.materialIndex].albedo * dot(o2l, rec.normal) *
                   abs(dot(o2l, lightNormal)) / distSqr * lightArea;
    }
  }

  vec3 secondaryRayDir;
  // indirect lighting
  if (materials[rec.materialIndex].materialType == METAL_MATERIAL) {
    secondaryRayDir = reflect(r.dir, rec.normal);
    colReturn += pathTracingRayColorIndirect(
                     ray(rec.p + rec.normal * 0.0001, secondaryRayDir)) *
                 dot(secondaryRayDir, rec.normal);
  } else {
    secondaryRayDir = random_in_hemisphere(rec.normal);
    colReturn += pathTracingRayColorIndirect(
                     ray(rec.p + rec.normal * 0.0001, secondaryRayDir)) *
                 dot(secondaryRayDir, rec.normal) * 2 * pi;
  }

  // colReturn *= materials[rec.materialIndex].albedo;
  colReturn *= materials[rec.materialIndex].albedo;
  // colReturn =  secondaryRayDir;
}

// whitted-style ray tracing for validation @ 400fps, 2k
vec3 ray_tracing_ray_color(ray r) {
  vec3 lightPos = vec3(0, 0.48, 1.5);

  hitRecord rec;
  vec3 colReturn = vec3(0.0, 0.0, 0.0);

  if (!hit_bvh(r, rec)) {
    return vec3(0.2); // background color
  }

  hitRecord rec2;

  vec3 toLight = lightPos - rec.p;
  float len = length(toLight);
  toLight = toLight / len;

  vec3 toSight = normalize(ubo.camPos - rec.p);

  bool hit2 = hit_bvh(ray(rec.p, toLight), rec2);
  if (!hit2 || rec2.t > len - 0.001) {
    colReturn = materials[rec.materialIndex].albedo * dot(toLight, rec.normal) *
                dot(normalize(toLight + toSight), rec.normal);
  }

  return colReturn;
}

const float driftXs[4] = float[](3 / 13., 9 / 13., 4 / 13., 10 / 13.);
const float driftYs[4] = float[](3 / 13., 4 / 13., 9 / 13., 10 / 13.);

// const float driftXs[4] = float[](1 / 3., 2 / 3., 1 / 3., 2 / 3.);
// const float driftYs[4] = float[](1 / 3., 1 / 3., 2 / 3., 2 / 3.);
vec2 tinyDriftInPixelGenerator(uint seed) {
  vec2 drift = vec2(0);

  seed %= 4;
  drift.x = driftXs[seed];
  drift.y = driftYs[seed];

  return drift;
}

ray rayGen(vec3 origin, vec3 front, vec3 up, vec3 right) {
  vec2 imageSize = vec2(imageSize(rawTex));

  float theta = ubo.vfov * deg2Rad;
  float h = tan(theta / 2);
  float viewport_height = 2.0 * h;
  float viewport_width = imageSize.x / imageSize.y * viewport_height;

  vec3 rayPropDir = viewport_width * right - viewport_height * up;
  vec3 top_left_corner = front - rayPropDir / 2;

  vec2 uv = (gl_GlobalInvocationID.xy +
             tinyDriftInPixelGenerator(ubo.currentSample)) /
            imageSize.xy;

  vec3 rayDir = normalize(top_left_corner + viewport_width * right * uv.x -
                          viewport_height * up * uv.y);
  ray r = {origin, rayDir};
  return r;
}

// no clamping applied here
const vec3 maxRadiance = vec3(2);
// component vise min()
vec3 fireflyRejectionClamp(vec3 radiance) { return min(radiance, maxRadiance); }

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

  ray camRay = rayGen(ubo.camPos, ubo.camFront, ubo.camUp, ubo.camRight);

  vec3 hitColor;
  vec4 hitWorldPos;
  vec4 hitNormal;
  float hitDepth;
  uint meshHash;
  pathTracing(camRay, hitColor, hitWorldPos, hitNormal, hitDepth, meshHash);

  imageStore(rawTex, uv, vec4(fireflyRejectionClamp(hitColor), 1));
  imageStore(posTex, uv, hitWorldPos);  // w: -1 (invalid) or 1 (valid)
  imageStore(normalTex, uv, hitNormal); // w: -1 (invalid) or 0 (valid)
  imageStore(depthTex, uv, vec4(hitDepth, 0, 0, 0));      // -1 (invalid)
  imageStore(meshHashTex1, uv, ivec4(meshHash, 0, 0, 0)); // -1 (invalid)
}