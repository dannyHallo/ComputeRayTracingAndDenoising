#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// Include definitions for ubo, triangle, material, etc.
#include "include/definitions.glsl"

// the uniform buffer that contains ray trace description infos
layout(binding = 0) uniform UniformBufferObject {
  vec3 camPos;
  vec3 camFront;
  vec3 camUp;
  vec3 camRight;
  float vfov;
  float time;
  uint currentSample;
  uint numTriangles;
  uint numLights;
  bool movingLightSource;
}
ubo;

// G-Buffer: the image that stores individual position of each ray hit
layout(binding = 1, rgba32f) uniform image2D posTex;
// G-Buffer: the image that stores individual normal of each ray hit
layout(binding = 2, rgba32f) uniform image2D normalTex;
// G-Buffer: the image that stores individual depth of each ray hit
layout(binding = 3, r32f) uniform image2D depthTex;
// G-Buffer: the image that stores individual mesh hash of each ray hit, each
// triangle has a unique mesh hash
layout(binding = 4, r32ui) uniform uimage2D meshHashTex1;
// Result: the image that stores ray traced color
layout(binding = 5, rgba32f) uniform image2D rawTex;

// the buffer that contains all triangles (read only)
layout(std430, binding = 6) readonly buffer TriangleBufferObject {
  triangle[] triangles;
};

// the buffer that contains all materials (read only)
layout(std430, binding = 7) readonly buffer MaterialBufferObject {
  material[] materials;
};

// the buffer that contains all bvh nodes (read only)
layout(std430, binding = 8) readonly buffer AabbBufferObject { bvhNode[] bvh; };

// the buffer that contains all lights (read only)
layout(std430, binding = 9) readonly buffer LightsBufferObject {
  light[] lights;
};

#include "include/random.glsl"

struct ray {
  vec3 origin;
  vec3 dir;
};

vec3 ray_at(ray r, float t) { return r.origin + t * r.dir; }

struct hitRecord {
  vec3 p;
  vec3 normal;
  uint materialIndex;
  float t;
  uint meshHash;
  // representing whetether backface or not with an integer to decrease
  // branches.
  int backFaceInt;
};

triangle moveLightTri(triangle tri) {
  if (!ubo.movingLightSource) return tri;
  
  float xOffset = sin(ubo.time * 10) * 0.2;
  tri.v0.x += xOffset;
  tri.v1.x += xOffset;
  tri.v2.x += xOffset;
  return tri;
}

bool triIntersect(vec3 origin, vec3 dir, triangle tri, out vec3 normal,
                  out vec2 uv, out float tNear) {
  vec3 e1 = tri.v1 - tri.v0;
  vec3 e2 = tri.v2 - tri.v0;
  vec3 s  = origin - tri.v0;
  vec3 s1 = cross(dir, e2);
  vec3 s2 = cross(s, e1);

  vec3 sol      = vec3(dot(s2, e2), dot(s1, s), dot(s2, dir));
  float s1e1Inv = 1 / dot(s1, e1);
  sol *= s1e1Inv;

  tNear  = sol.x;
  uv.xy  = sol.yz;
  normal = vec3(0.0);

  if (uv.x >= 0 && uv.y >= 0 && (1 - uv.x - uv.y) >= 0 && tNear > 0) {
    normal = normalize(cross(e1, e2)); // only calculate normal when hit
    return true;
  }
  return false;
}

// wrapper function
bool hit_triangle(int triangle_index, ray r, float tMin, float tMax,
                  inout hitRecord rec) {
  triangle tri = triangles[triangle_index];

  vec3 normal;
  vec2 uv;
  float tNear;

  // TODO: move light here!
  if (materials[tri.materialIndex].materialType == LIGHT_MATERIAL) {
    tri = moveLightTri(tri);
  }

  if (triIntersect(r.origin, r.dir, tri, normal, uv, tNear)) {
    rec.backFaceInt = int(step(0, dot(r.dir, normal)));
    rec.normal =
        normal * (1 - 2 * rec.backFaceInt); // make normal points to cam
    rec.p             = r.origin + tNear * r.dir;
    rec.t             = tNear;
    rec.materialIndex = tri.materialIndex;
    rec.meshHash      = tri.meshHash;

    return tNear > tMin && tNear < tMax;
  }
  return false;
}

// Hit scene without bvh.
// bool hit_scene(ray r, inout hitRecord rec) {
//   float t_min = 0.001;
//   float t_max = 10000;

//   hitRecord temp_rec;
//   bool hit_anything    = false;
//   float closest_so_far = t_max;

//   for (int i = 0; i < ubo.numTriangles; i++) {
//     // for (int i = 0; i < 4; i++) {
//     if (hit_triangle(i, r, t_min, closest_so_far, temp_rec)) {
//       hit_anything   = true;
//       closest_so_far = temp_rec.t;
//       rec            = temp_rec;
//     }
//   }

//   return hit_anything;
// }

// no intersection means vec.x > vec.y (really tNear > tFar)
bool intersectAABB(ray r, vec3 boxMin, vec3 boxMax) {
  vec3 tMin   = (boxMin - r.origin) / r.dir;
  vec3 tMax   = (boxMax - r.origin) / r.dir;
  vec3 t1     = min(tMin, tMax);
  vec3 t2     = max(tMin, tMax);
  float tNear = max(max(t1.x, t1.y), t1.z);
  float tFar  = min(min(t2.x, t2.y), t2.z);
  return tNear <= tFar;
}

// works only for triangles
#define MAX_STACK_DEPTH 16
bool traceRay(ray r, inout hitRecord rec) {
  float t_min = 0.001;
  float t_max = 10000;

  bool hit_anything    = false;
  float closest_so_far = t_max;

  // Since shader doesn't have a stack structure, implementing it with an array
  // and a counter.
  int nodeStack[MAX_STACK_DEPTH];
  int stackIndex = 0;

  // Traversing a flattened bvh using a stack.
  // nodeStack[stackIndex] contains an index of AABB in bvh[]
  // bvh[nodeStack[stackIndex]] is an index of a triangle in triangles.
  nodeStack[stackIndex] = 0;
  stackIndex++;

  while (stackIndex > 0 && stackIndex < MAX_STACK_DEPTH) {
    stackIndex--;
    int currentNode = nodeStack[stackIndex];
    if (currentNode == -1) continue;

    bool intersect =
        intersectAABB(r, bvh[currentNode].min, bvh[currentNode].max);
    if (!intersect) continue;

    // object index will only exist if it is a leaf node, otherwise, the index
    // is -1 (invalid)
    int ti = bvh[currentNode].objectIndex;
    if (ti != -1) {
      hitRecord temp_rec;
      if (hit_triangle(ti, r, t_min, closest_so_far, temp_rec)) {
        hit_anything   = true;
        closest_so_far = temp_rec.t;
        rec            = temp_rec;
      }
    } else {
      nodeStack[stackIndex++] = bvh[currentNode].leftNodeIndex;
      nodeStack[stackIndex++] = bvh[currentNode].rightNodeIndex;
    }
  }

  return hit_anything;
}

vec3 pathTracingRayColorIndirect(ray r) {
  hitRecord rec;
  vec3 colReturn = vec3(0.0, 0.0, 0.0);

  if (!traceRay(r, rec)) {
    return vec3(0);
  }

  if (materials[rec.materialIndex].materialType == LIGHT_MATERIAL) {
    return materials[rec.materialIndex].albedo;
  }

  // direct lighting
  for (int i = 0; i < ubo.numLights; i++) {
    uint lightId    = lights[i].triangleIndex;
    float lightArea = lights[i].area;

    vec3 e1          = triangles[lightId].v1 - triangles[lightId].v0;
    vec3 e2          = triangles[lightId].v2 - triangles[lightId].v0;
    vec3 lightNormal = normalize(
        cross(e1, e2)); // CAUTION: direction is unfixed! lit from both sides!

    vec2 randomUV = random_uv();
    float x       = randomUV.x;
    float y       = randomUV.y;

    x = random();
    y = random();

    if (x + y > 1) {
      x = 1 - x;
      y = 1 - y;
    }
    vec3 randomSamplingPointOnLight = triangles[lightId].v0 + e1 * x + e2 * y;

    vec3 o2l      = randomSamplingPointOnLight - rec.p;
    float distSqr = dot(o2l, o2l);
    float dist    = sqrt(distSqr);

    o2l /= dist;
    hitRecord rec2;
    if (traceRay(ray(rec.p + rec.normal * 0.0001, o2l), rec2)) {
      if (materials[rec2.materialIndex].materialType == LIGHT_MATERIAL) {
        colReturn += materials[rec2.materialIndex].albedo *
                     dot(o2l, rec.normal) * abs(dot(o2l, lightNormal)) /
                     distSqr * lightArea;
      }
    }
  }

  return materials[rec.materialIndex].albedo * colReturn;
}

void pathTracing(ray r, out vec3 colReturn, out vec4 hitWorldPos,
                 out vec4 hitNormal, out float hitDepth, out uint meshHash) {
  hitRecord rec;

  colReturn   = vec3(0, 0, 0);
  hitWorldPos = vec4(0, 0, 0, -1);
  hitNormal   = vec4(0, 0, 0, -1);
  hitDepth    = -1;
  meshHash    = 0;

  // direct ray not hit bvh
  if (!traceRay(r, rec)) {
    colReturn = vec3(0, 0, 0); // background color
    return;
  }

  hitWorldPos = vec4(rec.p, 1);
  hitNormal   = vec4(rec.normal, 0);
  hitDepth    = rec.t;
  meshHash    = rec.meshHash;

  // hit light directly
  if (materials[rec.materialIndex].materialType == LIGHT_MATERIAL) {
    colReturn = materials[rec.materialIndex].albedo;
    return;
  }

  // direct lighting
  vec2 randomUV = random_uv();
  float x       = randomUV.x;
  float y       = randomUV.y;

  x = random();
  y = random();

  int i = 0;
  if (x + y > 1) {
    x = 1 - x;
    y = 1 - y;
    i = 1;
  }

  uint lightId    = lights[i].triangleIndex;
  float lightArea = lights[i].area;

  triangle samplingLightTri = moveLightTri(triangles[lightId]);

  vec3 e1          = samplingLightTri.v1 - samplingLightTri.v0;
  vec3 e2          = samplingLightTri.v2 - samplingLightTri.v0;
  vec3 lightNormal = normalize(
      cross(e1, e2)); // CAUTION: direction is unfixed! lit from both sides!

  vec3 randomSamplingPointOnLight = samplingLightTri.v0 + e1 * x + e2 * y;

  vec3 o2l      = randomSamplingPointOnLight - rec.p;
  float distSqr = dot(o2l, o2l);
  float dist    = sqrt(distSqr);

  o2l /= dist;
  hitRecord rec2;
  if (traceRay(ray(rec.p + rec.normal * 0.0001, o2l), rec2)) {
    if (materials[rec2.materialIndex].materialType == LIGHT_MATERIAL) {
      colReturn += materials[rec2.materialIndex].albedo * dot(o2l, rec.normal) *
                   abs(dot(o2l, lightNormal)) / distSqr * lightArea;
    }
  }

  vec3 secondaryRayDir;
  // indirect lighting
  if (materials[rec.materialIndex].materialType == METAL_MATERIAL) {
    secondaryRayDir = reflect(r.dir, rec.normal);
    colReturn += pathTracingRayColorIndirect(
                     ray(rec.p + rec.normal * 0.0001, secondaryRayDir)) *
                 dot(secondaryRayDir, rec.normal);
  } else {
    secondaryRayDir = random_in_hemisphere(rec.normal);
    colReturn += pathTracingRayColorIndirect(
                     ray(rec.p + rec.normal * 0.0001, secondaryRayDir)) *
                 dot(secondaryRayDir, rec.normal) * 2 * pi;
  }

  colReturn *= materials[rec.materialIndex].albedo;
}

// whitted-style ray tracing for validation @ 400fps, 2k
vec3 ray_tracing_ray_color(ray r) {
  vec3 lightPos = vec3(0, 0.48, 1.5);

  hitRecord rec;
  vec3 colReturn = vec3(0.0, 0.0, 0.0);

  if (!traceRay(r, rec)) {
    return vec3(0.2); // background color
  }

  hitRecord rec2;

  vec3 toLight = lightPos - rec.p;
  float len    = length(toLight);
  toLight      = toLight / len;

  vec3 toSight = normalize(ubo.camPos - rec.p);

  bool hit2 = traceRay(ray(rec.p, toLight), rec2);
  if (!hit2 || rec2.t > len - 0.001) {
    colReturn = materials[rec.materialIndex].albedo * dot(toLight, rec.normal) *
                dot(normalize(toLight + toSight), rec.normal);
  }

  return colReturn;
}

vec2 inPixelPosition() { return vec2(.5, .5); }

ray rayGen(vec3 origin, vec3 front, vec3 up, vec3 right) {
  vec2 imageSize = vec2(imageSize(rawTex));

  float theta           = ubo.vfov * deg2Rad;
  float h               = tan(theta / 2);
  float viewport_height = 2.0 * h;
  float viewport_width  = imageSize.x / imageSize.y * viewport_height;

  vec3 rayPropDir      = viewport_width * right - viewport_height * up;
  vec3 top_left_corner = front - rayPropDir / 2;

  vec2 uv = (gl_GlobalInvocationID.xy + inPixelPosition()) / imageSize.xy;

  vec3 rayDir = normalize(top_left_corner + viewport_width * right * uv.x -
                          viewport_height * up * uv.y);
  ray r       = {origin, rayDir};
  return r;
}

// no clamping applied here
const vec3 maxRadiance = vec3(2);
// component vise min()
vec3 fireflyRejectionClamp(vec3 radiance) { return min(radiance, maxRadiance); }

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

  ray camRay = rayGen(ubo.camPos, ubo.camFront, ubo.camUp, ubo.camRight);

  vec3 hitColor;
  vec4 hitWorldPos;
  vec4 hitNormal;
  float hitDepth;
  uint meshHash;
  pathTracing(camRay, hitColor, hitWorldPos, hitNormal, hitDepth, meshHash);

  imageStore(rawTex, uv, vec4(fireflyRejectionClamp(hitColor), 1));
  imageStore(posTex, uv, hitWorldPos);  // w: -1 (invalid) or 1 (valid)
  imageStore(normalTex, uv, hitNormal); // w: -1 (invalid) or 0 (valid)
  imageStore(depthTex, uv, vec4(hitDepth, 0, 0, 0));      // -1 (invalid)
  imageStore(meshHashTex1, uv, ivec4(meshHash, 0, 0, 0)); // -1 (invalid)
}