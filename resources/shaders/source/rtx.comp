#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

struct material {
  uint materialType;
  vec3 albedo;
};

struct Triangle {
  vec3 v0;
  vec3 v1;
  vec3 v2;
  uint materialIndex;
  uint meshHash;
};

struct Light {
  uint triangleIndex;
  float area;
};

struct BvhNode {
  vec3 min;
  vec3 max;
  int leftNodeIndex;
  int rightNodeIndex;
  int objectIndex;
};

// the uniform buffer that contains ray trace description infos
layout(binding = 1) uniform UniformBufferObject {
  uint numTriangles;
  uint numLights;
  bool movingLightSource;
  bool useLdsNoise;
  bool useWeightedCosine;
  uint outputType;
}
ubo;

layout(binding = 2, rgba8) readonly uniform image2DArray vec2BlueNoise;
layout(binding = 3,
       rgba8) readonly uniform image2DArray weightedCosineBlueNoise;

// forward projected visibility buffer (sparse, full res)
layout(binding = 4, rgba32f) uniform image2D visibilityTex;
layout(binding = 5, rgba32ui) uniform uimage2D seedVisibilityTex;

// G-Buffer: the image that stores individual position of each ray hit
layout(binding = 6, rgba32f) writeonly uniform image2D posTex;
// G-Buffer: the image that stores individual normal of each ray hit
layout(binding = 7, rgba32f) writeonly uniform image2D normalTex;
// G-Buffer: the image that stores individual depth of each ray hit
layout(binding = 8, r32f) writeonly uniform image2D depthTex;
// G-Buffer: the image that stores individual mesh hash of each ray hit, each
// triangle has a unique mesh hash
layout(binding = 9, r32ui) writeonly uniform uimage2D meshHashTex1;
// Result: the image that stores ray traced color
layout(binding = 10, rgba32f) writeonly uniform image2D rawTex;
// Seed texture
layout(binding = 11, rgba32ui) writeonly uniform uimage2D seedTex;
// Temporal gradient
layout(binding = 12, rgba32f) writeonly uniform image2D temporalGradientTex;

// the buffer that contains all triangles (read only)
layout(std430, binding = 13) readonly buffer TriangleBufferObject {
  Triangle[] triangles;
};

// the buffer that contains all materials (read only)
layout(std430, binding = 14) readonly buffer MaterialBufferObject {
  material[] materials;
};

// the buffer that contains all bvh nodes (read only)
layout(std430, binding = 15) readonly buffer AabbBufferObject {
  BvhNode[] bvh;
};

// the buffer that contains all lights (read only)
layout(std430, binding = 16) readonly buffer LightsBufferObject {
  Light[] lights;
};

#include "include/definitions.glsl"
#include "include/globalUbo.glsl"
#include "include/random.glsl"

#define LIGHT_MATERIAL 0
#define LAMBERTIAN_MATERIAL 1
#define METAL_MATERIAL 2
#define GLASS_MATERIAL 3

#define OUTPUT_TYPE_COMBINED 0
#define OUTPUT_TYPE_DIRECT_ONLY 1
#define OUTPUT_TYPE_INDIRECT_ONLY 2

struct Ray {
  vec3 origin;
  vec3 dir;
};

struct HitRecord {
  bool hit;
  vec3 p;
  vec3 normal;
  vec3 color;
  uint materialIndex;
  float t;
  uint meshHash;
  // representing whetether backface or not with an integer to decrease
  // branches.
  int backFaceInt;
};

Triangle moveLightTri(Triangle tri) {
  if (!ubo.movingLightSource) return tri;

  float xOffset = sin(globalUbo.time * 4) * 0.2;
  tri.v0.x += xOffset;
  tri.v1.x += xOffset;
  tri.v2.x += xOffset;
  return tri;
}

bool triIntersect(vec3 origin, vec3 dir, Triangle tri, out vec3 normal,
                  out vec2 uv, out float tNear) {
  vec3 e1 = tri.v1 - tri.v0;
  vec3 e2 = tri.v2 - tri.v0;
  vec3 s  = origin - tri.v0;
  vec3 s1 = cross(dir, e2);
  vec3 s2 = cross(s, e1);

  vec3 sol      = vec3(dot(s2, e2), dot(s1, s), dot(s2, dir));
  float s1e1Inv = 1 / dot(s1, e1);
  sol *= s1e1Inv;

  tNear  = sol.x;
  uv.xy  = sol.yz;
  normal = vec3(0.0);

  if (uv.x >= 0 && uv.y >= 0 && (1 - uv.x - uv.y) >= 0 && tNear > 0) {
    normal = normalize(cross(e1, e2)); // only calculate normal when hit
    return true;
  }
  return false;
}

// wrapper function
HitRecord hitTriangle(int triangleIndex, Ray r, float tMin, float tMax) {
  HitRecord rec;
  rec.hit = false;

  Triangle tri = triangles[triangleIndex];

  vec3 normal;
  vec2 uv;
  float tNear;

  // TODO: move light here!
  if (materials[tri.materialIndex].materialType == LIGHT_MATERIAL) {
    tri = moveLightTri(tri);
  }

  if (triIntersect(r.origin, r.dir, tri, normal, uv, tNear)) {
    rec.backFaceInt = int(step(0, dot(r.dir, normal)));
    rec.normal =
        normal * (1 - 2 * rec.backFaceInt); // make normal points to cam
    rec.p             = r.origin + tNear * r.dir;
    rec.t             = tNear;
    rec.materialIndex = tri.materialIndex;
    rec.meshHash      = tri.meshHash;
    rec.hit           = tNear > tMin && tNear < tMax;
  }
  return rec;
}

// no intersection means vec.x > vec.y (really tNear > tFar)
bool intersectAABB(Ray r, vec3 boxMin, vec3 boxMax) {
  vec3 tMin   = (boxMin - r.origin) / r.dir;
  vec3 tMax   = (boxMax - r.origin) / r.dir;
  vec3 t1     = min(tMin, tMax);
  vec3 t2     = max(tMin, tMax);
  float tNear = max(max(t1.x, t1.y), t1.z);
  float tFar  = min(min(t2.x, t2.y), t2.z);
  return tNear <= tFar;
}

// works only for triangles
#define MAX_STACK_DEPTH 16
HitRecord traceRayToBvh(Ray r) {
  HitRecord rec;
  rec.hit = false;

  float t_min = 0.001;
  float t_max = 10000;

  float closestSoFar = t_max;

  // Since shader doesn't have a stack structure, implementing it with an array
  // and a counter.
  int nodeStack[MAX_STACK_DEPTH];
  int stackIndex = 0;

  // Traversing a flattened bvh using a stack.
  // nodeStack[stackIndex] contains an index of AABB in bvh[]
  // bvh[nodeStack[stackIndex]] is an index of a triangle in triangles.
  nodeStack[stackIndex] = 0;
  stackIndex++;

  while (stackIndex > 0 && stackIndex < MAX_STACK_DEPTH) {
    stackIndex--;
    int currentNode = nodeStack[stackIndex];
    if (currentNode == -1) continue;

    bool intersect =
        intersectAABB(r, bvh[currentNode].min, bvh[currentNode].max);
    if (!intersect) continue;

    // object index will only exist if it is a leaf node, otherwise, the index
    // is -1 (invalid)
    int ti = bvh[currentNode].objectIndex;
    if (ti != -1) {
      HitRecord triHitRec = hitTriangle(ti, r, t_min, closestSoFar);
      if (triHitRec.hit) {
        rec          = triHitRec;
        closestSoFar = triHitRec.t;
      }
    } else {
      nodeStack[stackIndex++] = bvh[currentNode].leftNodeIndex;
      nodeStack[stackIndex++] = bvh[currentNode].rightNodeIndex;
    }
  }
  return rec;
}

void getRamdomSampleOnLight(uvec3 seed, BaseDisturbance baseDisturbance,
                            out vec3 randomSamplingPointOnLight,
                            out vec3 lightNormal, out float lightArea) {
  vec2 rand = randomUv(seed, baseDisturbance, ubo.useLdsNoise);

  float x = rand.x;
  float y = rand.y;

  int i = 0;
  if (x + y > 1) {
    x = 1 - x;
    y = 1 - y;
    i = 1;
  }

  uint lightId = lights[i].triangleIndex;
  // we have two lighting tris (identical)
  lightArea = lights[i].area * 2;

  Triangle samplingLightTri = moveLightTri(triangles[lightId]);

  vec3 e1 = samplingLightTri.v1 - samplingLightTri.v0;
  vec3 e2 = samplingLightTri.v2 - samplingLightTri.v0;
  // CAUTION: direction is unfixed! lit from both sides!
  lightNormal = normalize(cross(e1, e2));

  randomSamplingPointOnLight = samplingLightTri.v0 + e1 * x + e2 * y;
}

vec3 pathTracing2(Ray r, uvec3 seed) {
  HitRecord rec = traceRayToBvh(r);
  if (!rec.hit) return vec3(0);
  vec3 hitPos    = rec.p;
  vec3 hitNormal = rec.normal;

  if (materials[rec.materialIndex].materialType == LIGHT_MATERIAL) {
    return materials[rec.materialIndex].albedo;
  }

  // direct lighting
  float lightArea;
  vec3 randomSamplingPointOnLight, lightNormal;
  getRamdomSampleOnLight(seed, BaseDisturbance(1), randomSamplingPointOnLight,
                         lightNormal, lightArea);
  vec3 o2l      = randomSamplingPointOnLight - rec.p;
  float distSqr = dot(o2l, o2l);
  float dist    = sqrt(distSqr);
  o2l /= dist;

  Ray shadowRay       = Ray(rec.p + rec.normal * kEpsilon, o2l);
  HitRecord shadowRec = traceRayToBvh(Ray(rec.p + rec.normal * 0.0001, o2l));
  vec3 directColor    = vec3(0);

  if (shadowRec.hit &&
      materials[shadowRec.materialIndex].materialType == LIGHT_MATERIAL) {
    vec3 brdf   = kInvPi * materials[rec.materialIndex].albedo;
    float pdf   = distSqr / (lightArea * abs(dot(o2l, lightNormal)));
    directColor = materials[shadowRec.materialIndex].albedo * brdf *
                  dot(o2l, hitNormal) / pdf;
  }

  return directColor;
}

float getLambertianBrdf() {
  const float kReflectance = 1.0;
  return kReflectance * kInvPi;
}

HitRecord pathTracing(Ray r, uvec3 seed) {
  HitRecord rec = traceRayToBvh(r);
  if (!rec.hit) return rec;
  vec3 hitPos    = rec.p;
  vec3 hitNormal = rec.normal;

  // hit light directly
  uint matIdx = rec.materialIndex;
  if (materials[matIdx].materialType == LIGHT_MATERIAL) {
    rec.color = materials[matIdx].albedo;
    return rec;
  }

  // direct lighting
  float lightArea;
  vec3 randomSamplingPointOnLight, lightNormal;
  getRamdomSampleOnLight(seed, BaseDisturbance(4), randomSamplingPointOnLight,
                         lightNormal, lightArea);

  vec3 o2l      = randomSamplingPointOnLight - rec.p;
  float distSqr = dot(o2l, o2l);
  float dist    = sqrt(distSqr);
  o2l /= dist;

  Ray shadowRay       = Ray(hitPos + hitNormal * kEpsilon, o2l);
  HitRecord shadowRec = traceRayToBvh(shadowRay);
  vec3 directColor    = vec3(0);
  if (shadowRec.hit &&
      materials[shadowRec.materialIndex].materialType == LIGHT_MATERIAL) {
    if (ubo.outputType != OUTPUT_TYPE_INDIRECT_ONLY) {
      vec3 brdf   = kInvPi * materials[rec.materialIndex].albedo;
      float pdf   = distSqr / (lightArea * abs(dot(o2l, lightNormal)));
      directColor = materials[shadowRec.materialIndex].albedo * brdf *
                    dot(o2l, hitNormal) / pdf;
    }
  }

  // indirect lighting
  vec3 indirectRayDir;
  float pdf;

  // cosine weighted sampling effectively increases sampling efficiency
  if (ubo.useWeightedCosine) {
    indirectRayDir = randomCosineWeightedHemispherePoint(
        hitNormal, seed, BaseDisturbance(2), ubo.useLdsNoise);
    pdf = dot(indirectRayDir, rec.normal) / kPi;
  } else {
    indirectRayDir = randomInHemisphere(hitNormal, seed, BaseDisturbance(3),
                                        ubo.useLdsNoise);
    pdf            = 1 / (2 * kPi);
  }

  Ray indirectRay = Ray(hitPos + hitNormal * kEpsilon, indirectRayDir);

  vec3 brdf = kInvPi * materials[rec.materialIndex].albedo;

  vec3 indirectColor = vec3(0);
  if (ubo.outputType != OUTPUT_TYPE_DIRECT_ONLY) {
    indirectColor = pathTracing2(indirectRay, seed) * brdf *
                    dot(indirectRayDir, rec.normal) / pdf;
  }

  rec.color = directColor + indirectColor;
  return rec;
}

vec3 getPixelInScreenPosByDispatch(vec2 subpixOffset) {
  const vec3 origin = globalUbo.camPos;
  const vec3 front  = globalUbo.camFront;
  const vec3 up     = globalUbo.camUp;
  const vec3 right  = globalUbo.camRight;

  const float theta           = globalUbo.vfov * kDeg2Rad;
  const float h               = tan(theta / 2);
  const float viewport_height = 2.0 * h;
  const float viewport_width  = float(globalUbo.swapchainWidth) /
                               float(globalUbo.swapchainHeight) *
                               viewport_height;

  vec3 rayPropDir      = viewport_width * right - viewport_height * up;
  vec3 top_left_corner = front - rayPropDir / 2;

  vec2 uv = (gl_GlobalInvocationID.xy + subpixOffset) /
            vec2(globalUbo.swapchainWidth, globalUbo.swapchainHeight);

  return top_left_corner + viewport_width * right * uv.x -
         viewport_height * up * uv.y;
}

Ray rayGen(vec2 subpixOffset) {
  vec3 rayDir = normalize(getPixelInScreenPosByDispatch(subpixOffset));
  return Ray(globalUbo.camPos, rayDir);
}

// component vise min()
vec3 fireflyRejectionClamp(vec3 radiance) {
  const vec3 maxRadiance = vec3(2);
  return min(radiance, maxRadiance);
}

vec2 getSubsubpixOffset() {
  ivec2 uv        = ivec2(gl_GlobalInvocationID.xy);
  vec4 visibility = imageLoad(visibilityTex, uv);
  // if no forward projected visibility, return 0.5
  if (visibility.w != 1) return vec2(0.5);
  // TODO: apply depth test here
  return visibility.xy - vec2(uv);
}

uvec4 getSeed() {
  ivec2 uv   = ivec2(gl_GlobalInvocationID.xy);
  uvec4 seed = imageLoad(seedVisibilityTex, uv);
  // generate a new seed if no forward projected visibility
  if (seed.w == 0)
    return uvec4(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y,
                 globalUbo.currentSample, 0);
  // self increment of seed using count
  seed.w += 1;
  return seed;
}

void calculateTemporalGradient(float thisTimeLuminance) {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

  vec4 visibility         = imageLoad(visibilityTex, uv);
  float previousLuminance = visibility.z;
  float temporalGradient  = thisTimeLuminance - previousLuminance;

  if (visibility.w != 1) return;

  if (temporalGradient < 0) {
    imageStore(temporalGradientTex, uv, vec4(-temporalGradient, 0, 0, 0));
  } else {
    imageStore(temporalGradientTex, uv, vec4(0, temporalGradient, 0, 0));
  }
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= globalUbo.swapchainWidth || uv.y >= globalUbo.swapchainHeight)
    return;

  Ray camRay = rayGen(getSubsubpixOffset());

  uvec4 seed = getSeed();

  vec3 hitColor    = vec3(0, 0, 0);
  vec4 hitWorldPos = vec4(0, 0, 0, -1);
  vec4 hitNormal   = vec4(0, 0, 0, -1);
  float hitDepth   = -1;
  uint meshHash    = 0;
  HitRecord rec    = pathTracing(camRay, seed.xyz);
  if (rec.hit) {
    hitColor    = rec.color;
    hitWorldPos = vec4(rec.p, 1);
    hitNormal   = vec4(rec.normal, 0);
    hitDepth    = rec.t;
    meshHash    = rec.meshHash;
  }

  vec4 thisTimeRawColor   = vec4(fireflyRejectionClamp(hitColor), 1);
  float thisTimeLuminance = dot(kRgbToLuminanceMat, thisTimeRawColor.rgb);

  imageStore(rawTex, uv, vec4(hitColor, 1));
  imageStore(posTex, uv, hitWorldPos);  // w: -1 (invalid) or 1 (valid)
  imageStore(normalTex, uv, hitNormal); // w: -1 (invalid) or 0 (valid)
  imageStore(depthTex, uv, vec4(hitDepth, 0, 0, 0));      // -1 (invalid)
  imageStore(meshHashTex1, uv, ivec4(meshHash, 0, 0, 0)); // -1 (invalid)
  imageStore(seedTex, uv, seed);

  calculateTemporalGradient(thisTimeLuminance);
}