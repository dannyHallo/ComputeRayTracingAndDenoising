#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

struct material {
  uint materialType;
  vec3 albedo;
};

struct triangle {
  vec3 v0;
  vec3 v1;
  vec3 v2;
  uint materialIndex;
  uint meshHash;
};

struct light {
  uint triangleIndex;
  float area;
};

struct sphere {
  vec4 s;
  uint materialIndex;
};

struct bvhNode {
  vec3 min;
  vec3 max;
  int leftNodeIndex;
  int rightNodeIndex;
  int objectIndex;
};

struct onb {
  vec3 u;
  vec3 v;
  vec3 w;
};

// the uniform buffer that contains ray trace description infos
layout(binding = 1) uniform UniformBufferObject {
  uint numTriangles;
  uint numLights;
  bool movingLightSource;
  bool useLdsNoise;
  uint outputType;
}
ubo;

// forward projected visibility buffer (sparse, full res)
layout(binding = 2, rgba32f) uniform image2D visibilityTex;
layout(binding = 3, rgba32ui) uniform uimage2D seedVisibilityTex;

// G-Buffer: the image that stores individual position of each ray hit
layout(binding = 4, rgba32f) writeonly uniform image2D posTex;
// G-Buffer: the image that stores individual normal of each ray hit
layout(binding = 5, rgba32f) writeonly uniform image2D normalTex;
// G-Buffer: the image that stores individual depth of each ray hit
layout(binding = 6, r32f) writeonly uniform image2D depthTex;
// G-Buffer: the image that stores individual mesh hash of each ray hit, each
// triangle has a unique mesh hash
layout(binding = 7, r32ui) writeonly uniform uimage2D meshHashTex1;
// Result: the image that stores ray traced color
layout(binding = 8, rgba32f) writeonly uniform image2D rawTex;
// Seed texture
layout(binding = 9, rgba32ui) writeonly uniform uimage2D seedTex;
// Temporal gradient
layout(binding = 10, rgba32f) writeonly uniform image2D temporalGradientTex;

// the buffer that contains all triangles (read only)
layout(std430, binding = 11) readonly buffer TriangleBufferObject {
  triangle[] triangles;
};

// the buffer that contains all materials (read only)
layout(std430, binding = 12) readonly buffer MaterialBufferObject {
  material[] materials;
};

// the buffer that contains all bvh nodes (read only)
layout(std430, binding = 13) readonly buffer AabbBufferObject {
  bvhNode[] bvh;
};

// the buffer that contains all lights (read only)
layout(std430, binding = 14) readonly buffer LightsBufferObject {
  light[] lights;
};

#include "include/definitions.glsl"
#include "include/globalUbo.glsl"

#define LIGHT_MATERIAL 0
#define LAMBERTIAN_MATERIAL 1
#define METAL_MATERIAL 2
#define GLASS_MATERIAL 3

#define OUTPUT_TYPE_COMBINED 0
#define OUTPUT_TYPE_DIRECT_ONLY 1
#define OUTPUT_TYPE_INDIRECT_ONLY 2

#include "include/random.glsl"

struct ray {
  vec3 origin;
  vec3 dir;
};

vec3 ray_at(ray r, float t) { return r.origin + t * r.dir; }

struct hitRecord {
  bool hit;
  vec3 p;
  vec3 normal;
  uint materialIndex;
  float t;
  uint meshHash;
  // representing whetether backface or not with an integer to decrease
  // branches.
  int backFaceInt;
};

triangle moveLightTri(triangle tri) {
  if (!ubo.movingLightSource) return tri;

  float xOffset = sin(globalUbo.time * 10) * 0.2;
  tri.v0.x += xOffset;
  tri.v1.x += xOffset;
  tri.v2.x += xOffset;
  return tri;
}

bool triIntersect(vec3 origin, vec3 dir, triangle tri, out vec3 normal,
                  out vec2 uv, out float tNear) {
  vec3 e1 = tri.v1 - tri.v0;
  vec3 e2 = tri.v2 - tri.v0;
  vec3 s  = origin - tri.v0;
  vec3 s1 = cross(dir, e2);
  vec3 s2 = cross(s, e1);

  vec3 sol      = vec3(dot(s2, e2), dot(s1, s), dot(s2, dir));
  float s1e1Inv = 1 / dot(s1, e1);
  sol *= s1e1Inv;

  tNear  = sol.x;
  uv.xy  = sol.yz;
  normal = vec3(0.0);

  if (uv.x >= 0 && uv.y >= 0 && (1 - uv.x - uv.y) >= 0 && tNear > 0) {
    normal = normalize(cross(e1, e2)); // only calculate normal when hit
    return true;
  }
  return false;
}

// wrapper function
hitRecord hitTriangle(int triangleIndex, ray r, float tMin, float tMax) {
  hitRecord rec;
  rec.hit = false;

  triangle tri = triangles[triangleIndex];

  vec3 normal;
  vec2 uv;
  float tNear;

  // TODO: move light here!
  if (materials[tri.materialIndex].materialType == LIGHT_MATERIAL) {
    tri = moveLightTri(tri);
  }

  if (triIntersect(r.origin, r.dir, tri, normal, uv, tNear)) {
    rec.backFaceInt = int(step(0, dot(r.dir, normal)));
    rec.normal =
        normal * (1 - 2 * rec.backFaceInt); // make normal points to cam
    rec.p             = r.origin + tNear * r.dir;
    rec.t             = tNear;
    rec.materialIndex = tri.materialIndex;
    rec.meshHash      = tri.meshHash;
    rec.hit           = tNear > tMin && tNear < tMax;
  }
  return rec;
}

// no intersection means vec.x > vec.y (really tNear > tFar)
bool intersectAABB(ray r, vec3 boxMin, vec3 boxMax) {
  vec3 tMin   = (boxMin - r.origin) / r.dir;
  vec3 tMax   = (boxMax - r.origin) / r.dir;
  vec3 t1     = min(tMin, tMax);
  vec3 t2     = max(tMin, tMax);
  float tNear = max(max(t1.x, t1.y), t1.z);
  float tFar  = min(min(t2.x, t2.y), t2.z);
  return tNear <= tFar;
}

// works only for triangles
#define MAX_STACK_DEPTH 16
hitRecord traceRayToBvh(ray r) {
  hitRecord rec;
  rec.hit = false;

  float t_min = 0.001;
  float t_max = 10000;

  float closestSoFar = t_max;

  // Since shader doesn't have a stack structure, implementing it with an array
  // and a counter.
  int nodeStack[MAX_STACK_DEPTH];
  int stackIndex = 0;

  // Traversing a flattened bvh using a stack.
  // nodeStack[stackIndex] contains an index of AABB in bvh[]
  // bvh[nodeStack[stackIndex]] is an index of a triangle in triangles.
  nodeStack[stackIndex] = 0;
  stackIndex++;

  while (stackIndex > 0 && stackIndex < MAX_STACK_DEPTH) {
    stackIndex--;
    int currentNode = nodeStack[stackIndex];
    if (currentNode == -1) continue;

    bool intersect =
        intersectAABB(r, bvh[currentNode].min, bvh[currentNode].max);
    if (!intersect) continue;

    // object index will only exist if it is a leaf node, otherwise, the index
    // is -1 (invalid)
    int ti = bvh[currentNode].objectIndex;
    if (ti != -1) {
      hitRecord triHitRec = hitTriangle(ti, r, t_min, closestSoFar);
      if (triHitRec.hit) {
        rec          = triHitRec;
        closestSoFar = triHitRec.t;
      }
    } else {
      nodeStack[stackIndex++] = bvh[currentNode].leftNodeIndex;
      nodeStack[stackIndex++] = bvh[currentNode].rightNodeIndex;
    }
  }
  return rec;
}

void getRamdomSampleOnLight(uvec2 seed, out vec3 randomSamplingPointOnLight,
                            out vec3 lightNormal, out float lightArea) {

  vec2 randomUV = random_uv(seed);
  float x       = randomUV.x;
  float y       = randomUV.y;

  int i = 0;
  if (x + y > 1) {
    x = 1 - x;
    y = 1 - y;
    i = 1;
  }

  uint lightId = lights[i].triangleIndex;
  lightArea    = lights[i].area;

  triangle samplingLightTri = moveLightTri(triangles[lightId]);

  vec3 e1 = samplingLightTri.v1 - samplingLightTri.v0;
  vec3 e2 = samplingLightTri.v2 - samplingLightTri.v0;
  // CAUTION: direction is unfixed! lit from both sides!
  lightNormal = normalize(cross(e1, e2));

  randomSamplingPointOnLight = samplingLightTri.v0 + e1 * x + e2 * y;
}

vec3 pathTracingRayColorIndirect(ray r, uvec2 seed) {
  // ihRec = indirect hit record
  // ihsRec = indirect hit shadow ray record

  vec3 colReturn = vec3(0.0, 0.0, 0.0);

  hitRecord ihRec = traceRayToBvh(r);
  if (!ihRec.hit) return vec3(0);

  if (materials[ihRec.materialIndex].materialType == LIGHT_MATERIAL) {
    return materials[ihRec.materialIndex].albedo;
  }

  // direct lighting
  vec3 randomSamplingPointOnLight;
  vec3 lightNormal;
  float lightArea;
  getRamdomSampleOnLight(seed, randomSamplingPointOnLight, lightNormal,
                         lightArea);

  vec3 o2l      = randomSamplingPointOnLight - ihRec.p;
  float distSqr = dot(o2l, o2l);
  float dist    = sqrt(distSqr);

  o2l /= dist;
  hitRecord ihsRec = traceRayToBvh(ray(ihRec.p + ihRec.normal * 0.0001, o2l));
  if (ihsRec.hit) {
    if (materials[ihsRec.materialIndex].materialType == LIGHT_MATERIAL) {
      colReturn += materials[ihsRec.materialIndex].albedo *
                   dot(o2l, ihRec.normal) * abs(dot(o2l, lightNormal)) /
                   distSqr * lightArea;
    }
  }

  return materials[ihRec.materialIndex].albedo * colReturn;
}

void pathTracing(ray r, uvec2 seed, out vec3 colReturn, out vec4 hitWorldPos,
                 out vec4 hitNormal, out float hitDepth, out uint meshHash) {

  // dhRec = directhit record
  // dhsRec = directhit shadow ray record

  colReturn   = vec3(0, 0, 0);
  hitWorldPos = vec4(0, 0, 0, -1);
  hitNormal   = vec4(0, 0, 0, -1);
  hitDepth    = -1;
  meshHash    = 0;

  // direct ray not hit bvh, leave the color default
  hitRecord dhRec = traceRayToBvh(r);
  if (!dhRec.hit) return;

  hitWorldPos = vec4(dhRec.p, 1);
  hitNormal   = vec4(dhRec.normal, 0);
  hitDepth    = dhRec.t;
  meshHash    = dhRec.meshHash;

  // hit light directly
  if (materials[dhRec.materialIndex].materialType == LIGHT_MATERIAL) {
    colReturn = materials[dhRec.materialIndex].albedo;
    return;
  }

  // direct lighting
  vec3 randomSamplingPointOnLight;
  vec3 lightNormal;
  float lightArea;
  getRamdomSampleOnLight(seed, randomSamplingPointOnLight, lightNormal,
                         lightArea);

  vec3 o2l      = randomSamplingPointOnLight - dhRec.p;
  float distSqr = dot(o2l, o2l);
  float dist    = sqrt(distSqr);
  o2l /= dist;

  hitRecord dhsRec = traceRayToBvh(ray(dhRec.p + dhRec.normal * 0.0001, o2l));
  if (dhsRec.hit) {
    if (materials[dhsRec.materialIndex].materialType == LIGHT_MATERIAL) {
      if (ubo.outputType != OUTPUT_TYPE_INDIRECT_ONLY) {
        colReturn += materials[dhsRec.materialIndex].albedo *
                     dot(o2l, dhRec.normal) * abs(dot(o2l, lightNormal)) /
                     distSqr * lightArea;
      }
    }
  }

  if (ubo.outputType == OUTPUT_TYPE_DIRECT_ONLY) {
    colReturn *= materials[dhRec.materialIndex].albedo;
    return;
  }

  // indirect lighting
  vec3 secondaryRayDir;
  if (materials[dhRec.materialIndex].materialType == METAL_MATERIAL) {
    secondaryRayDir = reflect(r.dir, dhRec.normal);
    colReturn +=
        pathTracingRayColorIndirect(
            ray(dhRec.p + dhRec.normal * 0.0001, secondaryRayDir), seed) *
        dot(secondaryRayDir, dhRec.normal);
  } else {
    secondaryRayDir = random_in_hemisphere(dhRec.normal, seed);
    colReturn +=
        pathTracingRayColorIndirect(
            ray(dhRec.p + dhRec.normal * 0.0001, secondaryRayDir), seed) *
        dot(secondaryRayDir, dhRec.normal) * 2 * pi;
  }

  colReturn *= materials[dhRec.materialIndex].albedo;
}

vec3 getPixelInScreenPosByDispatch(vec2 subpixOffset) {
  const vec3 origin = globalUbo.camPos;
  const vec3 front  = globalUbo.camFront;
  const vec3 up     = globalUbo.camUp;
  const vec3 right  = globalUbo.camRight;

  const float theta           = globalUbo.vfov * deg2Rad;
  const float h               = tan(theta / 2);
  const float viewport_height = 2.0 * h;
  const float viewport_width  = float(globalUbo.swapchainWidth) /
                               float(globalUbo.swapchainHeight) *
                               viewport_height;

  vec3 rayPropDir      = viewport_width * right - viewport_height * up;
  vec3 top_left_corner = front - rayPropDir / 2;

  vec2 uv = (gl_GlobalInvocationID.xy + subpixOffset) /
            vec2(globalUbo.swapchainWidth, globalUbo.swapchainHeight);

  return top_left_corner + viewport_width * right * uv.x -
         viewport_height * up * uv.y;
}

ray rayGen(vec2 subpixOffset) {
  vec3 rayDir = normalize(getPixelInScreenPosByDispatch(subpixOffset));
  return ray(globalUbo.camPos, rayDir);
}

// component vise min()
vec3 fireflyRejectionClamp(vec3 radiance) {
  const vec3 maxRadiance = vec3(2);
  return min(radiance, maxRadiance);
}

vec2 getSubsubpixOffset() {
  ivec2 uv        = ivec2(gl_GlobalInvocationID.xy);
  vec4 visibility = imageLoad(visibilityTex, uv);
  // if no forward projected visibility, return 0.5
  if (visibility.w != 1) return vec2(0.5);
  // TODO: apply depth test here
  return visibility.xy - vec2(uv);
}

uvec4 getSeed() {
  ivec2 uv   = ivec2(gl_GlobalInvocationID.xy);
  uvec4 seed = imageLoad(seedVisibilityTex, uv);
  // generate a new seed if no forward projected visibility
  if (seed.w == 0)
    return uvec4(
        gl_GlobalInvocationID.x + uint(globalUbo.currentSample) * 19937u,
        gl_GlobalInvocationID.y + uint(globalUbo.currentSample) * 3719u, 0, 0);
  // self increment of seed using count
  seed.w += 1;
  return seed;
}

void calculateTemporalGradient(float thisTimeLuminance) {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

  vec4 visibility         = imageLoad(visibilityTex, uv);
  float previousLuminance = visibility.z;
  float temporalGradient  = abs(thisTimeLuminance - previousLuminance);

  if (visibility.w != 1) return;
  imageStore(temporalGradientTex, uv, vec4(temporalGradient, 0, 0, 0));
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= globalUbo.swapchainWidth || uv.y >= globalUbo.swapchainHeight)
    return;

  ray camRay = rayGen(getSubsubpixOffset());

  uvec4 seed = getSeed();

  vec3 hitColor;
  vec4 hitWorldPos;
  vec4 hitNormal;
  float hitDepth;
  uint meshHash;
  pathTracing(camRay, seed.xy, hitColor, hitWorldPos, hitNormal, hitDepth,
              meshHash);

  vec4 thisTimeRawColor   = vec4(fireflyRejectionClamp(hitColor), 1);
  float thisTimeLuminance = dot(rgbToLuminanceMat, thisTimeRawColor.rgb);

  imageStore(rawTex, uv, thisTimeRawColor);
  imageStore(posTex, uv, hitWorldPos);  // w: -1 (invalid) or 1 (valid)
  imageStore(normalTex, uv, hitNormal); // w: -1 (invalid) or 0 (valid)
  imageStore(depthTex, uv, vec4(hitDepth, 0, 0, 0));      // -1 (invalid)
  imageStore(meshHashTex1, uv, ivec4(meshHash, 0, 0, 0)); // -1 (invalid)
  imageStore(seedTex, uv, seed);

  calculateTemporalGradient(thisTimeLuminance);
}