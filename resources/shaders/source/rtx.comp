#version 450
#extension GL_GOOGLE_include_directive : require

#define STRATUM_SIZE 3

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

struct material {
  uint materialType;
  vec3 albedo;
};

struct Triangle {
  vec3 v0;
  vec3 v1;
  vec3 v2;
  uint materialIndex;
  uint meshHash;
};

struct Light {
  uint triangleIndex;
  float area;
};

struct BvhNode {
  vec3 min;
  vec3 max;
  int leftNodeIndex;
  int rightNodeIndex;
  int objectIndex;
};

// the uniform buffer that contains ray trace description infos
layout(binding = 1) uniform UniformBufferObject {
  uint numTriangles;
  uint numLights;
  bool movingLightSource;
  uint outputType;
  float offsetX;
  float offsetY;
}
ubo;

// custom res
layout(binding = 2, rgba8) readonly uniform image2DArray vec2BlueNoise;
layout(binding = 3, rgba8) readonly uniform image2DArray weightedCosineBlueNoise;

// stratum res
layout(binding = 4, r32ui) readonly uniform uimage2D stratumOffsetTex;
layout(binding = 5, rgba32f) readonly uniform image2D visibilityTex;
layout(binding = 6, rgba32ui) readonly uniform uimage2D seedVisibilityTex;

// full res
layout(binding = 7, rgba32f) writeonly uniform image2D posTex;
layout(binding = 8, rgba32f) writeonly uniform image2D normalTex;
layout(binding = 9, r32f) writeonly uniform image2D depthTex;
layout(binding = 10, r32ui) writeonly uniform uimage2D meshHashTex1;
layout(binding = 11, rgba32f) writeonly uniform image2D rawTex;
layout(binding = 12, rgba32ui) writeonly uniform uimage2D seedTex;

// stratum res, [float luminance, float variance, float temporal_gradient, float normalized_factor]
layout(binding = 13, rgba32f) writeonly uniform image2D temporalGradientNormalizationTex;

// the buffer that contains all triangles (read only)
layout(std430, binding = 14) readonly buffer TriangleBufferObject { Triangle[] triangles; };

// the buffer that contains all materials (read only)
layout(std430, binding = 15) readonly buffer MaterialBufferObject { material[] materials; };

// the buffer that contains all bvh nodes (read only)
layout(std430, binding = 16) readonly buffer AabbBufferObject { BvhNode[] bvh; };

// the buffer that contains all lights (read only)
layout(std430, binding = 17) readonly buffer LightsBufferObject { Light[] lights; };

#include "include/definitions.glsl"
#include "include/globalUbo.glsl"
#include "include/random.glsl"

#define LIGHT_MATERIAL 0
#define LAMBERTIAN_MATERIAL 1
#define METAL_MATERIAL 2
#define GLASS_MATERIAL 3

#define OUTPUT_TYPE_COMBINED 0
#define OUTPUT_TYPE_DIRECT_ONLY 1
#define OUTPUT_TYPE_INDIRECT_ONLY 2

struct Ray {
  vec3 origin;
  vec3 dir;
};

struct HitRecord {
  bool hit;
  vec3 p;
  vec3 normal;
  vec3 color;
  uint materialIndex;
  float t;
  uint meshHash;
  // representing whetether backface or not with an integer to decrease
  // branches.
  int backFaceInt;
};

Triangle moveLightTri(Triangle tri) {
  if (!ubo.movingLightSource) return tri;

  float xOffset = sin(globalUbo.time * 4) * 0.2;
  tri.v0.x += xOffset;
  tri.v1.x += xOffset;
  tri.v2.x += xOffset;
  return tri;
}

float changeLightIntensity() {
  return 1.0;
  if (!ubo.movingLightSource) return 1.0;

  const float avgLum       = 0.7;
  const float maxLum       = 1;
  const float changingTime = 2;
  return sin(globalUbo.time * (1 / changingTime) * kPi) * (maxLum - avgLum) + avgLum;
}

bool triIntersect(vec3 origin, vec3 dir, Triangle tri, out vec3 normal, out vec2 uv,
                  out float tNear) {

  vec3 e1 = tri.v1 - tri.v0;
  vec3 e2 = tri.v2 - tri.v0;
  vec3 s  = origin - tri.v0;
  vec3 s1 = cross(dir, e2);
  vec3 s2 = cross(s, e1);

  vec3 sol      = vec3(dot(s2, e2), dot(s1, s), dot(s2, dir));
  float s1e1Inv = 1 / dot(s1, e1);
  sol *= s1e1Inv;

  tNear  = sol.x;
  uv.xy  = sol.yz;
  normal = vec3(0.0);

  if (uv.x >= 0 && uv.y >= 0 && (1 - uv.x - uv.y) >= 0 && tNear > 0) {
    normal = normalize(cross(e1, e2)); // only calculate normal when hit
    return true;
  }
  return false;
}

// wrapper function
HitRecord hitTriangle(int triangleIndex, Ray r, float tMin, float tMax) {
  HitRecord rec;
  rec.hit = false;

  Triangle tri = triangles[triangleIndex];

  vec3 normal;
  vec2 uv;
  float tNear;

  // TODO: move light here!
  if (materials[tri.materialIndex].materialType == LIGHT_MATERIAL) {
    tri = moveLightTri(tri);
  }

  if (triIntersect(r.origin, r.dir, tri, normal, uv, tNear)) {
    rec.backFaceInt   = int(step(0, dot(r.dir, normal)));
    rec.normal        = normal * (1 - 2 * rec.backFaceInt); // make normal points to cam
    rec.p             = r.origin + tNear * r.dir;
    rec.t             = tNear;
    rec.materialIndex = tri.materialIndex;
    rec.meshHash      = tri.meshHash;
    rec.hit           = tNear > tMin && tNear < tMax;
  }
  return rec;
}

// no intersection means vec.x > vec.y (really tNear > tFar)
bool intersectAABB(Ray r, vec3 boxMin, vec3 boxMax) {
  vec3 tMin   = (boxMin - r.origin) / r.dir;
  vec3 tMax   = (boxMax - r.origin) / r.dir;
  vec3 t1     = min(tMin, tMax);
  vec3 t2     = max(tMin, tMax);
  float tNear = max(max(t1.x, t1.y), t1.z);
  float tFar  = min(min(t2.x, t2.y), t2.z);
  return tNear <= tFar;
}

// works only for triangles
#define MAX_STACK_DEPTH 16
HitRecord traceRayToBvh(Ray r) {
  HitRecord rec;
  rec.hit = false;

  float t_min = 0.001;
  float t_max = 10000;

  float closestSoFar = t_max;

  // Since shader doesn't have a stack structure, implementing it with an array
  // and a counter.
  int nodeStack[MAX_STACK_DEPTH];
  int stackIndex = 0;

  // Traversing a flattened bvh using a stack.
  // nodeStack[stackIndex] contains an index of AABB in bvh[]
  // bvh[nodeStack[stackIndex]] is an index of a triangle in triangles.
  nodeStack[stackIndex] = 0;
  stackIndex++;

  while (stackIndex > 0 && stackIndex < MAX_STACK_DEPTH) {
    stackIndex--;
    int currentNode = nodeStack[stackIndex];
    if (currentNode == -1) continue;

    bool intersect = intersectAABB(r, bvh[currentNode].min, bvh[currentNode].max);
    if (!intersect) continue;

    // object index will only exist if it is a leaf node, otherwise, the index
    // is -1 (invalid)
    int ti = bvh[currentNode].objectIndex;
    if (ti != -1) {
      HitRecord triHitRec = hitTriangle(ti, r, t_min, closestSoFar);
      if (triHitRec.hit) {
        rec          = triHitRec;
        closestSoFar = triHitRec.t;
      }
    } else {
      nodeStack[stackIndex++] = bvh[currentNode].leftNodeIndex;
      nodeStack[stackIndex++] = bvh[currentNode].rightNodeIndex;
    }
  }
  return rec;
}

// avoid the edges of the lighting triangles
vec2 edgeAvoiding(vec2 val) {
  float eps = 1e-3;

  if (abs(val.x + val.y - 1.0) < eps) {
    val.x = fract(val.x + kPi);
  }

  vec2 epsVec = vec2(eps);
  vec2 oneVec = vec2(1.0);

  // Clamp val to [eps, 1-eps]
  val = clamp(val, epsVec, oneVec - epsVec);

  return val;
}

void getRandomSampleOnLight(uvec3 seed, BaseDisturbance baseDisturbance,
                            out vec3 randomSamplingPointOnLight, out vec3 lightNormal,
                            out float lightArea) {
  vec2 rand = randomUv(seed, baseDisturbance, true);
  rand      = edgeAvoiding(rand);

  int i = 0;
  if (rand.x + rand.y > 1) {
    rand = vec2(1) - rand;
    i    = 1;
  }

  uint lightId = lights[i].triangleIndex;
  // we have two lighting tris (identical)
  lightArea = lights[i].area * 2;

  Triangle samplingLightTri = moveLightTri(triangles[lightId]);
  vec3 e1                   = samplingLightTri.v1 - samplingLightTri.v0;
  vec3 e2                   = samplingLightTri.v2 - samplingLightTri.v0;
  // CAUTION: direction is unfixed! lit from both sides!
  lightNormal = normalize(cross(e1, e2));

  randomSamplingPointOnLight = samplingLightTri.v0 + e1 * rand.x + e2 * rand.y;
}

vec3 pathTracing2(Ray r, uvec3 seed) {
  HitRecord rec = traceRayToBvh(r);
  if (!rec.hit) return vec3(0);
  vec3 hitPos    = rec.p;
  vec3 hitNormal = rec.normal;

  if (materials[rec.materialIndex].materialType == LIGHT_MATERIAL) {
    return materials[rec.materialIndex].albedo * changeLightIntensity();
  }

  // direct lighting
  float lightArea;
  vec3 randomSamplingPointOnLight, lightNormal;
  getRandomSampleOnLight(seed, BaseDisturbance(1), randomSamplingPointOnLight, lightNormal,
                         lightArea);
  vec3 o2l      = randomSamplingPointOnLight - rec.p;
  float distSqr = dot(o2l, o2l);
  float dist    = sqrt(distSqr);
  o2l /= dist;

  Ray shadowRay           = Ray(rec.p + rec.normal * kEpsilon, o2l);
  HitRecord shadowRec     = traceRayToBvh(Ray(rec.p + rec.normal * 0.0001, o2l));
  vec3 directColor        = vec3(0);
  bool isDirectionCorrect = dot(lightNormal, o2l) < 0; // light backface culling
  bool hitLight =
      shadowRec.hit && materials[shadowRec.materialIndex].materialType == LIGHT_MATERIAL;
  if (hitLight && isDirectionCorrect) {
    vec3 brdf   = kInvPi * materials[rec.materialIndex].albedo;
    float pdf   = distSqr / (lightArea * abs(dot(o2l, lightNormal)));
    directColor = materials[shadowRec.materialIndex].albedo * changeLightIntensity() * brdf *
                  dot(o2l, hitNormal) / pdf;
  }

  return directColor;
}

HitRecord pathTracing(Ray r, uvec3 seed) {
  HitRecord rec = traceRayToBvh(r);
  if (!rec.hit) return rec;
  vec3 hitPos    = rec.p;
  vec3 hitNormal = rec.normal;

  // hit light directly
  uint matIdx = rec.materialIndex;
  if (materials[matIdx].materialType == LIGHT_MATERIAL) {
    rec.color = materials[matIdx].albedo * changeLightIntensity();
    return rec;
  }

  // direct lighting
  float lightArea;
  vec3 randomSamplingPointOnLight, lightNormal;
  getRandomSampleOnLight(seed, BaseDisturbance(4), randomSamplingPointOnLight, lightNormal,
                         lightArea);

  vec3 o2l      = randomSamplingPointOnLight - rec.p;
  float distSqr = dot(o2l, o2l);
  float dist    = sqrt(distSqr);
  o2l /= dist;

  Ray shadowRay           = Ray(hitPos + hitNormal * kEpsilon, o2l);
  HitRecord shadowRec     = traceRayToBvh(shadowRay);
  vec3 directColor        = vec3(0);
  bool isDirectionCorrect = dot(lightNormal, o2l) < 0; // light backface culling
  bool hitLight =
      shadowRec.hit && materials[shadowRec.materialIndex].materialType == LIGHT_MATERIAL;
  if (hitLight && isDirectionCorrect) {
    if (ubo.outputType != OUTPUT_TYPE_INDIRECT_ONLY) {
      vec3 brdf   = kInvPi * materials[rec.materialIndex].albedo;
      float pdf   = distSqr / (lightArea * abs(dot(o2l, lightNormal)));
      directColor = materials[shadowRec.materialIndex].albedo * changeLightIntensity() * brdf *
                    dot(o2l, hitNormal) / pdf;
    }
  }

  // indirect lighting
  vec3 indirectRayDir;
  float pdf;

  // cosine weighted sampling effectively increases sampling efficiency
  indirectRayDir = randomCosineWeightedHemispherePoint(hitNormal, seed, BaseDisturbance(2), true);
  pdf            = dot(indirectRayDir, rec.normal) / kPi;

  Ray indirectRay = Ray(hitPos + hitNormal * kEpsilon, indirectRayDir);

  vec3 brdf = kInvPi * materials[rec.materialIndex].albedo;

  vec3 indirectColor = vec3(0);
  if (ubo.outputType != OUTPUT_TYPE_DIRECT_ONLY) {
    indirectColor = pathTracing2(indirectRay, seed) * brdf * dot(indirectRayDir, rec.normal) / pdf;
  }

  rec.color = directColor + indirectColor;
  return rec;
}

vec3 getPixelInScreenPosByDispatch(vec2 subpixOffset) {
  const vec3 origin = globalUbo.camPos;
  const vec3 front  = globalUbo.camFront;
  const vec3 up     = globalUbo.camUp;
  const vec3 right  = globalUbo.camRight;

  const float theta           = globalUbo.vfov * kDeg2Rad;
  const float h               = tan(theta / 2);
  const float viewport_height = 2.0 * h;
  const float viewport_width =
      float(globalUbo.swapchainWidth) / float(globalUbo.swapchainHeight) * viewport_height;

  vec3 rayPropDir      = viewport_width * right - viewport_height * up;
  vec3 top_left_corner = front - rayPropDir / 2;

  vec2 uv = (gl_GlobalInvocationID.xy + subpixOffset) /
            vec2(globalUbo.swapchainWidth, globalUbo.swapchainHeight);

  return top_left_corner + viewport_width * right * uv.x - viewport_height * up * uv.y;
}

// component vise min()
vec3 fireflyRejectionClamp(vec3 radiance) {
  const vec3 maxRadiance = vec3(2);
  return min(radiance, maxRadiance);
}

uvec2 decodeOffsetInStratum(uint offset) {
  // offset of 0 is invalid
  offset--;
  return uvec2(offset % STRATUM_SIZE, offset / STRATUM_SIZE);
}

// returns whether this pixel has stratum rec
bool hasStratumRec = false; // this global var is initiated in main()
bool checkStratumRecord() {
  ivec2 uv              = ivec2(gl_GlobalInvocationID.xy);
  ivec2 stratumUv       = uv / STRATUM_SIZE;
  uint stratumOffsetRaw = imageLoad(stratumOffsetTex, stratumUv).x;
  if (stratumOffsetRaw == 0) return false;

  uvec2 stratumOffset = decodeOffsetInStratum(stratumOffsetRaw);
  ivec2 uvWithRec     = stratumUv * STRATUM_SIZE + ivec2(stratumOffset);

  return uv == uvWithRec;
}

Ray rayGen(vec2 subpixOffset) {
  vec3 rayDir = normalize(getPixelInScreenPosByDispatch(subpixOffset));
  return Ray(globalUbo.camPos, rayDir);
}

vec2 getSubsubpixOffset() {
  if (!hasStratumRec) return vec2(0.5);
  ivec2 stratumUv = ivec2(gl_GlobalInvocationID.xy) / STRATUM_SIZE;
  vec2 offset     = imageLoad(visibilityTex, stratumUv).xy;

  const float toleranceDist = 1e-4;
  vec2 delta                = offset - vec2(0.5);
  if (dot(delta, delta) < toleranceDist) return vec2(0.5);

  return offset;
}

uvec3 getSeed() {
  if (!hasStratumRec) {
    return uvec3(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, globalUbo.currentSample);
  }
  ivec2 stratumUv = ivec2(gl_GlobalInvocationID.xy) / STRATUM_SIZE;
  return imageLoad(seedVisibilityTex, stratumUv).xyz;
}

void calculateTemporalGradient(float thisTimeLuminance) {
  ivec2 stratumUv = ivec2(gl_GlobalInvocationID.xy) / STRATUM_SIZE;

  float previousLuminance = imageLoad(visibilityTex, stratumUv).z;
  float temporalGradient  = thisTimeLuminance - previousLuminance;
  float normalizedFactor  = max(thisTimeLuminance, previousLuminance);

  imageStore(temporalGradientNormalizationTex, stratumUv,
             vec4(0, 0, temporalGradient, normalizedFactor));
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= globalUbo.swapchainWidth || uv.y >= globalUbo.swapchainHeight) return;

  hasStratumRec = checkStratumRecord();
  // hasStratumRec = false;

  Ray camRay = rayGen(getSubsubpixOffset());

  uvec3 seed = getSeed();

  vec3 hitColor    = vec3(0, 0, 0);
  vec4 hitWorldPos = vec4(0, 0, 0, -1);
  vec4 hitNormal   = vec4(0, 0, 0, -1);
  float hitDepth   = -1;
  uint meshHash    = 0;
  HitRecord rec    = pathTracing(camRay, seed);
  if (rec.hit) {
    hitColor    = rec.color;
    hitWorldPos = vec4(rec.p, 1);
    hitNormal   = vec4(rec.normal, 0);
    hitDepth    = rec.t;
    meshHash    = rec.meshHash;
  }
  // hitColor = fireflyRejectionClamp(hitColor);

  vec4 thisTimeRawColor   = vec4(hitColor, 1);
  float thisTimeLuminance = dot(kRgbToLuminanceMat, thisTimeRawColor.rgb);

  imageStore(rawTex, uv, vec4(hitColor, 1));
  imageStore(posTex, uv, hitWorldPos);                    // w: -1 (invalid) or 1 (valid)
  imageStore(normalTex, uv, hitNormal);                   // w: -1 (invalid) or 0 (valid)
  imageStore(depthTex, uv, vec4(hitDepth, 0, 0, 0));      // -1 (invalid)
  imageStore(meshHashTex1, uv, ivec4(meshHash, 0, 0, 0)); // -1 (invalid)
  imageStore(seedTex, uv, uvec4(seed, 0));

  if (hasStratumRec) calculateTemporalGradient(thisTimeLuminance);
}