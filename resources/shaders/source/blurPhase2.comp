#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

#include "include/blurCommon.glsl"

// bigger phi indicates bigger tolerence to apply blur
layout(binding = 0) uniform UniformBufferObject {
  bool bypassBluring;
  float sigma;
  float cPhi;
  float nPhi;
  float pPhi;
  int i;
}
ubo;

layout(binding = 1, rgba8) uniform image2D aTrousTex1;
layout(binding = 2, rgba8) uniform image2D blurHTex;
layout(binding = 3, rgba8) uniform image2D normalTex;
layout(binding = 4, rgba32f) uniform image2D posTex;
layout(binding = 5, rgba8) uniform image2D aTrousTex2;

const float alpha = 0.8;

// int kernelSize = int(ceil(2 * 3 * ubo.sigma + 1));
int kernalHalfSize = (kernelSize - 1) / 2;

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  vec4 colorAtUV = imageLoad(aTrousTex1, uv);

  if (ubo.bypassBluring) {
    imageStore(aTrousTex2, uv, colorAtUV);
    return;
  }

  vec3 positionAtUV = imageLoad(posTex, uv).xyz;
  vec3 normalAtUV = imageLoad(normalTex, uv).xyz;

  float sig2Inv = 1 / (2 * ubo.sigma * ubo.sigma + epsilon);
  float c2Inv = 1 / (2 * alpha * alpha * ubo.cPhi * ubo.cPhi + epsilon);
  float n2Inv = 1 / (2 * alpha * alpha * ubo.nPhi * ubo.nPhi + epsilon);
  float p2Inv = 1 / (2 * alpha * alpha * ubo.pPhi * ubo.pPhi + epsilon);

  float sumOfWeights = 0;
  vec4 sumOfWeightedValues = vec4(0);
  vec4 weightedColor = vec4(0);

  for (int index = 0; index < kernelSize; index++) {
    int x = 0;
    int y = int((index - kernalHalfSize) * pow(2, ubo.i));

    // float weightDistFalloff = exp(-x * x * sig2Inv);
    float weightDistFalloff = weightsATrous[index];

    vec4 colorAtSample = imageLoad(aTrousTex1, ivec2(x + uv.x, y + uv.y));
    vec4 differenceInColorVec = colorAtSample - colorAtUV;
    float differenceInColorFloat2 =
        dot(differenceInColorVec, differenceInColorVec);
    float weightDIC = exp(-differenceInColorFloat2 * c2Inv);

    vec3 normalAtSample = imageLoad(normalTex, ivec2(x + uv.x, y + uv.y)).xyz;
    vec3 differenceInNormalVec = normalAtSample - normalAtUV;
    float differenceInNormalFloat2 =
        dot(differenceInNormalVec, differenceInNormalVec);
    float weightDIN = exp(-differenceInNormalFloat2 * n2Inv);

    vec3 positionAtSample = imageLoad(posTex, ivec2(x + uv.x, y + uv.y)).xyz;
    vec3 differenceInPositionVec = positionAtSample - positionAtUV;
    float differenceInPositionFloat2 =
        dot(differenceInPositionVec, differenceInPositionVec);
    float weightDIP = exp(-differenceInPositionFloat2 * p2Inv);

    float weight = weightDistFalloff * weightDIC * weightDIN * weightDIP;

    sumOfWeightedValues +=
        weight * imageLoad(blurHTex, ivec2(x + uv.x, y + uv.y));
    sumOfWeights += weight;
  }

  weightedColor = sumOfWeightedValues / sumOfWeights;
  imageStore(aTrousTex2, uv, weightedColor);
  // imageStore(aTrousTex2, uv, imageLoad(blurHTex, uv));
}