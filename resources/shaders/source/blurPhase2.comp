#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

#include "include/blurCommon.glsl"

// bigger phi indicates bigger tolerence to apply blur
layout(binding = 0) uniform UniformBufferObject {
  bool bypassBluring;
  int i;
  float phiLuminance;
  bool useThreeByThreeKernel;
  bool ignoreLuminanceAtFirstIteration;
  bool changingLuminancePhi;
  bool separateKernel;
}
ubo;

layout(binding = 1, rgba8) uniform image2D aTrousTex1;
layout(binding = 2, rgba8) uniform image2D blurHTex;
layout(binding = 3, rgba8) uniform image2D normalTex;
layout(binding = 4, rgba8) uniform image2D depthTex;
layout(binding = 5, rgba32f) uniform image2D posTex;
layout(binding = 6, rgba8) uniform image2D aTrousTex2;

ivec2 uv;
vec2 gradientAtUV;
vec3 positionAtUV, normalAtUV;
vec4 colorAtUV;
float luminanceAtUV, depthAtUV;

void blurKernel(int indexY, int kernalHalfSize, inout float sumOfWeights,
                inout vec4 sumOfWeightedValues) {
  int x = 0;
  int y = int((indexY - kernalHalfSize) * pow(2, ubo.i));

  float weightDistFalloff = 0;
  if (ubo.useThreeByThreeKernel) {
    weightDistFalloff = weightsATrous3x3[indexY];
  } else {
    weightDistFalloff = weightsATrous5x5[indexY];
  }

  float luminanceAtSample =
      rgbToLuminance(imageLoad(aTrousTex1, uv + ivec2(x, y)));
  float differenceInColorVec = abs(luminanceAtSample - luminanceAtUV);
  float phiC                 = ubo.phiLuminance;
  float weightC              = exp(-differenceInColorVec / phiC);
  if (ubo.changingLuminancePhi) {
    phiC = pow(2, -ubo.i) * ubo.phiLuminance;
  }
  if (ubo.ignoreLuminanceAtFirstIteration && ubo.i == 0) {
    weightC = 1.0;
  }

  // introduce the cosine term to describe normal edge stopping function
  vec3 normalAtSample = imageLoad(normalTex, uv + ivec2(x, y)).xyz;
  float weightN       = max(0., pow(dot(normalAtSample, normalAtUV), 128.));

  // ---- method SVGF
  float depthAtSample = imageLoad(depthTex, uv + ivec2(x, y)).x;
  float weightFac     = abs(depthAtUV - depthAtSample) /
                    (abs(dot(gradientAtUV, vec2(x, y))) + epsilon);
  weightFac     = min(weightFac, 1);
  float weightZ = exp(-weightFac);
  // ---- end of SVGF

  float weight = weightDistFalloff * weightN * weightZ * weightC;
  // float weight = weightDistFalloff;

  sumOfWeightedValues += weight * imageLoad(blurHTex, uv + ivec2(x, y));
  sumOfWeights += weight;
}

void main() {
  uv = ivec2(gl_GlobalInvocationID.xy);

  colorAtUV = imageLoad(blurHTex, uv);
  if (ubo.bypassBluring || !ubo.separateKernel) {
    imageStore(aTrousTex2, uv, colorAtUV);
    return;
  }

  luminanceAtUV = rgbToLuminance(colorAtUV);
  positionAtUV  = imageLoad(posTex, uv).xyz;
  normalAtUV    = imageLoad(normalTex, uv).xyz;
  depthAtUV     = imageLoad(depthTex, uv).x;

  float dep4     = imageLoad(depthTex, uv + ivec2(0, 0)).x;
  float dep5     = imageLoad(depthTex, uv + ivec2(1, 0)).x;
  float dep7     = imageLoad(depthTex, uv + ivec2(0, 1)).x;
  gradientAtUV.x = dep5 - dep4;
  gradientAtUV.y = dep7 - dep4;

  float sumOfWeights       = 0;
  vec4 sumOfWeightedValues = vec4(0);
  vec4 weightedColor       = vec4(0);

  int kernelSize     = ubo.useThreeByThreeKernel ? 3 : 5;
  int kernalHalfSize = (kernelSize - 1) / 2;
  for (int indexY = 0; indexY < kernelSize; indexY++) {
    blurKernel(indexY, kernalHalfSize, sumOfWeights, sumOfWeightedValues);
  }

  weightedColor = sumOfWeightedValues / sumOfWeights;
  imageStore(aTrousTex2, uv, weightedColor);
}