#version 450
#extension GL_GOOGLE_include_directive : require

// this compute shader is dispatched before this frame's path tracing
#define GROUP_SIZE_STRATUM 8
#define STRATUM_SIZE 3
#define GROUP_SIZE_STRATUM_2 (GROUP_SIZE_STRATUM * GROUP_SIZE_STRATUM)
#define DISPATCH_SIZE (GROUP_SIZE_STRATUM * STRATUM_SIZE)

layout(local_size_x = DISPATCH_SIZE, local_size_y = DISPATCH_SIZE, local_size_z = 1) in;

layout(binding = 1) uniform UniformBufferObject {
  bool bypassGradientProjection;
  // we use the last position buffer and this mvpe for forward prejection
  // this sticks to the original paper
  mat4 thisMvpe;
}
ubo;

layout(binding = 2, rgba8) readonly uniform image2DArray vec2BlueNoise;
layout(binding = 3, rgba8) readonly uniform image2DArray weightedCosineBlueNoise;

// full res
layout(binding = 4, rgba32f) readonly uniform image2D lastRawColorTex;
layout(binding = 5, rgba32f) readonly uniform image2D lastPosTex;
layout(binding = 6, rgba32ui) readonly uniform uimage2D lastSeedTex;

// stratum res
layout(binding = 7, r32ui) writeonly uniform uimage2D stratumOffsetTex;
// stratum res, atomic
layout(binding = 8, r32ui) uniform uimage2D perStratumLockingTex;
// stratum res, stored with forward-projected accurate screen space sampling position, associated
// with its luminance
layout(binding = 9, rgba32f) writeonly uniform image2D visibilityTex;
layout(binding = 10, rgba32ui) writeonly uniform uimage2D seedVisibilityTex;

#include "include/definitions.glsl"
#include "include/globalUbo.glsl"
#include "include/random.glsl"

shared float luminance[DISPATCH_SIZE][DISPATCH_SIZE];

void preload() {
  ivec2 uv            = ivec2(gl_GlobalInvocationID.xy);
  float luminanceAtUv = dot(kRgbToLuminanceMat, imageLoad(lastRawColorTex, uv).rgb);
  luminance[gl_LocalInvocationID.x][gl_LocalInvocationID.y] = luminanceAtUv;
}

void pickInStratum(ivec2 localStratumUv, ivec2 stratumUv, out ivec2 pickedGlobalPos,
                   out float pickedLum, out uvec3 pickedSeed) {
  uvec3 seed  = uvec3(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, globalUbo.currentSample);
  vec2 randUv = randomUv(seed, BaseDisturbance(0), false); // TODO: change random function here

  int i                  = int(randUv.x * STRATUM_SIZE);
  int j                  = int(randUv.y * STRATUM_SIZE);
  ivec2 localStratumBase = localStratumUv * STRATUM_SIZE;
  pickedLum              = luminance[localStratumBase.x + i][localStratumBase.y + j];
  pickedGlobalPos        = ivec2(stratumUv.x * STRATUM_SIZE + i, stratumUv.y * STRATUM_SIZE + j);

  pickedSeed = imageLoad(lastSeedTex, pickedGlobalPos).xyz;
}

uint encodeOffsetInStratum(uvec2 offsetInStratum) {
  return offsetInStratum.x + offsetInStratum.y * STRATUM_SIZE + 1;
}

void forwardProjection(ivec2 globalPosToProject, float lum, uvec3 seed) {
  vec4 worldPos = imageLoad(lastPosTex, globalPosToProject);
  // invalid position culling
  if (worldPos.w == -1) return;

  vec4 screenBoxCoord = ubo.thisMvpe * worldPos;
  // points are bounded in [-1, 1] in x, y, z after the following
  screenBoxCoord /= screenBoxCoord.w;
  // points are bounded in [0, 1] in x, y, meanwhile z, w are thrown away
  screenBoxCoord = (screenBoxCoord + vec4(1)) / 2.0;
  // to vulkan uv coord, starts from top left corner, range is [0, 1]
  vec2 uvCoord = vec2(screenBoxCoord.x, 1 - screenBoxCoord.y);
  // notice that the reprojected position is NOT integer
  vec2 pp = vec2(uvCoord.x * globalUbo.swapchainWidth, uvCoord.y * globalUbo.swapchainHeight);

  ivec2 stratumUv = ivec2(pp / float(STRATUM_SIZE));

  // look up to the corresponding stratum data, if it is already occupied,
  // then nothing will happen, otherwire, set it to occupeid state atomically
  uint hasSampleOnThisStratum = imageAtomicCompSwap(perStratumLockingTex, stratumUv, 0, 1);
  if (hasSampleOnThisStratum == 1) return;

  uvec2 stratumOffset  = uvec2(pp) - stratumUv * STRATUM_SIZE;
  uint offsetInStratum = encodeOffsetInStratum(stratumOffset);
  imageStore(stratumOffsetTex, stratumUv, uvec4(offsetInStratum, 0, 0, 0));

  // xy: uv in floating point, z: luminance w: valid sample
  imageStore(visibilityTex, stratumUv, vec4(pp, lum, 1));
  // xy: seed in uvec3, z: 0
  imageStore(seedVisibilityTex, stratumUv, uvec4(seed, 0));
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= globalUbo.swapchainWidth || uv.y >= globalUbo.swapchainHeight) return;

  if (ubo.bypassGradientProjection) return;

  preload(); // loads variance to shared memory for faster access
  barrier(); // wait for all threads to finish loading in work group

  // kick 8/9 of the threads
  if (gl_LocalInvocationIndex >= GROUP_SIZE_STRATUM_2) return;

  // the stratum id in the work group (0, 0) to (7, 7)
  ivec2 localStratumUv = ivec2(gl_LocalInvocationIndex % GROUP_SIZE_STRATUM,
                               gl_LocalInvocationIndex / GROUP_SIZE_STRATUM);

  // the current stratum id globally
  ivec2 stratumUv = ivec2(gl_WorkGroupID.xy * GROUP_SIZE_STRATUM) + localStratumUv;

  ivec2 pickedGlobalPos;
  float pickedLum;
  uvec3 pickedSeed;
  pickInStratum(localStratumUv, stratumUv, pickedGlobalPos, pickedLum, pickedSeed);

  forwardProjection(pickedGlobalPos, pickedLum, pickedSeed);
}