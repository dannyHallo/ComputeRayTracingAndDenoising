#version 450
#extension GL_GOOGLE_include_directive : require

// this compute shader is dispatched before this frame's path tracing
#define GROUP_SIZE_STRATUM 8
#define STRATUM_SIZE 3
#define GROUP_SIZE_STRATUM_2 (GROUP_SIZE_STRATUM * GROUP_SIZE_STRATUM)
#define DISPATCH_SIZE (GROUP_SIZE_STRATUM * STRATUM_SIZE)

layout(local_size_x = DISPATCH_SIZE, local_size_y = DISPATCH_SIZE,
       local_size_z = 1) in;

layout(binding = 1) uniform UniformBufferObject {
  bool bypassGradientProjection;
  // we use the last position buffer and this mvpe for forward prejection
  // this sticks to the original paper
  mat4 thisMvpe;
}
ubo;

// full res, dense, recording last time rtx result
layout(binding = 2, rgba32f) readonly uniform image2D lastRawColorTex;
layout(binding = 3, rgba32f) readonly uniform image2D lastPosTex;
layout(binding = 4, rgba32ui) readonly uniform uimage2D lastSeedTex;
// 1/3 res, recording the active position in
// the stratum, and its luminance
layout(binding = 5, rgba32f) writeonly uniform image2D perStratumTex;
// 1/3 res, it is automatically reset to all zero before
// every dispatch, it's aim is to ensure the write is atomic
layout(binding = 6, r32ui) uniform uimage2D perStratumLockingTex;
// full res, but sparse (at most 1 sample per stratum),
// stored with forward-projected accurate screen space sampling position,
// associated with its luminance
layout(binding = 7, rgba32f) writeonly uniform image2D visibilityTex;
layout(binding = 8, rgba32ui) writeonly uniform uimage2D seedVisibilityTex;

#include "include/definitions.glsl"
#include "include/globalUbo.glsl"
#include "include/random.glsl"

shared float luminance[DISPATCH_SIZE][DISPATCH_SIZE];

void getBrightestInStratum(ivec2 localStratumId, ivec2 stratumId,
                           out ivec2 brightestGlobalPos,
                           out float brightestLuminance,
                           out uvec2 brightestSeed) {
  brightestLuminance = 0;
  brightestGlobalPos = ivec2(0);
  // for (int i = 0; i < STRATUM_SIZE; i++) {
  //   for (int j = 0; j < STRATUM_SIZE; j++) {
  //     ivec2 localStratumBase = localStratumId * STRATUM_SIZE;
  //     float luminanceAtPixel =
  //         luminance[localStratumBase.x + i][localStratumBase.y + j];
  //     if (luminanceAtPixel > brightestLuminance) {
  //       ivec2 globalPos    = ivec2(stratumId.x * STRATUM_SIZE + i,
  //                                  stratumId.y * STRATUM_SIZE + j);
  //       brightestGlobalPos = globalPos;
  //       brightestLuminance = luminanceAtPixel;
  //     }
  //   }
  // }

  uvec3 seed  = uvec3(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y,
                      globalUbo.currentSample);
  vec2 randUv = randomUv(seed, false);

  int i                  = int(randUv.x * STRATUM_SIZE);
  int j                  = int(randUv.y * STRATUM_SIZE);
  ivec2 localStratumBase = localStratumId * STRATUM_SIZE;
  float luminanceAtPixel =
      luminance[localStratumBase.x + i][localStratumBase.y + j];
  ivec2 globalPos =
      ivec2(stratumId.x * STRATUM_SIZE + i, stratumId.y * STRATUM_SIZE + j);
  brightestGlobalPos = globalPos;
  brightestLuminance = luminanceAtPixel;

  // if the seed has been used more than x times,
  // discard this stratum
  if (imageLoad(lastSeedTex, brightestGlobalPos).w > 2) {
    brightestGlobalPos = ivec2(0);
    brightestLuminance = 0;
    brightestSeed      = uvec2(0);
    return;
  }
  brightestSeed = imageLoad(lastSeedTex, brightestGlobalPos).xy;
}

void preload() {
  ivec2 uv             = ivec2(gl_GlobalInvocationID.xy);
  const vec3 colorAtUv = imageLoad(lastRawColorTex, uv).rgb;
  float luminanceAtUv  = dot(kRgbToLuminanceMat, colorAtUv);
  luminance[gl_LocalInvocationID.x][gl_LocalInvocationID.y] = luminanceAtUv;
}

void forwardProjection(ivec2 globalPosToProject, float lum, uvec2 seed) {
  vec4 worldPos = imageLoad(lastPosTex, globalPosToProject);
  // invalid position culling
  if (worldPos.w == -1) return;

  vec4 screenBoxCoord = ubo.thisMvpe * worldPos;
  // points are bounded in [-1, 1] in x, y, z after the following
  screenBoxCoord /= screenBoxCoord.w;
  // points are bounded in [0, 1] in x, y, meanwhile z, w are thrown away
  screenBoxCoord = (screenBoxCoord + vec4(1)) / 2.0;
  // to vulkan uv coord, starts from top left corner, range is [0, 1]
  vec2 uvCoord = vec2(screenBoxCoord.x, 1 - screenBoxCoord.y);
  // notice that the reprojected position is NOT integer
  vec2 pp = vec2(uvCoord.x * globalUbo.swapchainWidth,
                 uvCoord.y * globalUbo.swapchainHeight);

  ivec2 stratumId = ivec2(pp / float(STRATUM_SIZE));

  // look up to the corresponding stratum data, if it is already occupied,
  // then nothing will happen, otherwire, set it to occupeid state atomically
  uint hasSampleOnThisStratum =
      imageAtomicCompSwap(perStratumLockingTex, stratumId, 0, 1);
  if (hasSampleOnThisStratum == 1) return;

  imageStore(perStratumTex, stratumId, vec4(pp, lum, 0));
  // xy: uv in floating point, z: luminance w: valid sample
  imageStore(visibilityTex, ivec2(pp), vec4(pp, lum, 1));
  // xy: seed in uvec2, z: 0, w: valid sample
  imageStore(seedVisibilityTex, ivec2(pp), uvec4(seed, 0, 1));
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= globalUbo.swapchainWidth || uv.y >= globalUbo.swapchainHeight)
    return;

  if (ubo.bypassGradientProjection) return;

  // loads color and calculates luminance from last frame, a single thread
  // loads one pixel, after writing to shared memory, it's faster for stratum
  // threads to use
  preload();
  // wait for all threads to finish loading in work group
  barrier();

  // kick most of the threads
  if (gl_LocalInvocationIndex >= GROUP_SIZE_STRATUM_2) return;

  ivec2 localStratumId = ivec2(gl_LocalInvocationIndex % GROUP_SIZE_STRATUM,
                               gl_LocalInvocationIndex / GROUP_SIZE_STRATUM);
  ivec2 stratumId =
      ivec2(gl_WorkGroupID.xy * GROUP_SIZE_STRATUM) + localStratumId;

  ivec2 brightestGlobalPos;
  float brightestLuminance;
  uvec2 brightestSeed;
  getBrightestInStratum(localStratumId, stratumId, brightestGlobalPos,
                        brightestLuminance, brightestSeed);

  if (brightestLuminance > 0) {
    forwardProjection(brightestGlobalPos, brightestLuminance, brightestSeed);
  }
}