#version 450

// this compute shader is dispatched before this frame's path tracing
#define GROUP_SIZE_STRATUM 8
#define STRATUM_SIZE 3
#define GROUP_SIZE_STRATUM_2 (GROUP_SIZE_STRATUM * GROUP_SIZE_STRATUM)
#define DISPATCH_SIZE (GROUP_SIZE_STRATUM * STRATUM_SIZE)

layout(local_size_x = DISPATCH_SIZE, local_size_y = DISPATCH_SIZE,
       local_size_z = 1) in;

#include "include/definitions.glsl"
#include "include/globalUbo.glsl"

layout(binding = 1) uniform UniformBufferObject {
  bool bypassGradientProjection;
  // we use the last position buffer and this mvpe for forward prejection
  // this sticks to the original paper
  mat4 thisMvpe;
}
ubo;

layout(binding = 2, rgba32f) readonly uniform image2D lastRawColorTex;
layout(binding = 3, rgba32f) readonly uniform image2D lastPosTex;
// the tex is in 1/3 resolution, recording the active position in
// the stratum, and its luminance
layout(binding = 4, rgba32f) writeonly uniform image2D perStratumTex;
// the tex is in 1/3 resolution, it is automatically reset to all zero before
// every dispatch, it's aim is to ensure the write is atomic
layout(binding = 5, r32ui) uniform uimage2D perStratumLockingTex;
// the tex is in full resolution, but sparse (at most 1 sample per stratum),
// stored with forward-projected accurate screen space sampling position,
// associated with its luminance
layout(binding = 6, rgba32f) writeonly uniform image2D visibilityTex;

shared float luminance[DISPATCH_SIZE][DISPATCH_SIZE];

void getBrightestInStratum(ivec2 localStratumId, ivec2 stratumId,
                           out ivec2 brightestGlobalPos,
                           out float brightestLuminance) {
  brightestLuminance = 0;
  brightestGlobalPos = ivec2(0);
  for (int i = 0; i < STRATUM_SIZE; i++) {
    for (int j = 0; j < STRATUM_SIZE; j++) {
      ivec2 localStratumBase = localStratumId * STRATUM_SIZE;
      float luminanceAtPixel =
          luminance[localStratumBase.x + i][localStratumBase.y + j];
      if (luminanceAtPixel > brightestLuminance) {
        ivec2 globalPos    = ivec2(stratumId.x * STRATUM_SIZE + i,
                                   stratumId.y * STRATUM_SIZE + j);
        brightestGlobalPos = globalPos;
        brightestLuminance = luminanceAtPixel;
      }
    }
  }
}

void getLuminance() {
  ivec2 uv             = ivec2(gl_GlobalInvocationID.xy);
  const vec3 colorAtUv = imageLoad(lastRawColorTex, uv).rgb;
  float luminanceAtUv  = dot(rgbToLuminanceMat, colorAtUv);
  luminance[gl_LocalInvocationID.x][gl_LocalInvocationID.y] = luminanceAtUv;
}

void forwardProjection(ivec2 globalPosToProject, float lum) {
  vec4 worldPos = imageLoad(lastPosTex, globalPosToProject);
  // invalid position culling
  if (worldPos.w == -1) return;

  vec4 screenBoxCoord = ubo.thisMvpe * worldPos;
  // points are bounded in [-1, 1] in x, y, z after the following
  screenBoxCoord /= screenBoxCoord.w;
  // points are bounded in [0, 1] in x, y, meanwhile z, w are thrown away
  screenBoxCoord = (screenBoxCoord + vec4(1)) / 2.0;
  // to vulkan uv coord, starts from top left corner, range is [0, 1]
  vec2 uvCoord = vec2(screenBoxCoord.x, 1 - screenBoxCoord.y);
  // notice that the reprojected position is NOT integer
  vec2 pp = vec2(uvCoord.x * globalUbo.swapchainWidth,
                 uvCoord.y * globalUbo.swapchainHeight);

  ivec2 stratumId = ivec2(pp / float(STRATUM_SIZE));

  // look up to the corresponding stratum data, if it is already occupied, then
  // nothing will happen, otherwire, set it to occupeid state atomically
  uint hasSampleOnThisStratum =
      imageAtomicCompSwap(perStratumLockingTex, stratumId, 0, 1);

  if (hasSampleOnThisStratum == 1) return;
  imageStore(perStratumTex, stratumId, vec4(pp, lum, 0));
  imageStore(visibilityTex, ivec2(pp), vec4(pp, lum, 0));
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= globalUbo.swapchainWidth || uv.y >= globalUbo.swapchainHeight)
    return;

  if (ubo.bypassGradientProjection) return;

  getLuminance();
  barrier();

  // kick most of the threads
  if (gl_LocalInvocationIndex >= GROUP_SIZE_STRATUM_2) return;

  ivec2 localStratumId = ivec2(gl_LocalInvocationIndex % GROUP_SIZE_STRATUM,
                               gl_LocalInvocationIndex / GROUP_SIZE_STRATUM);
  ivec2 stratumId =
      ivec2(gl_WorkGroupID.xy * GROUP_SIZE_STRATUM) + localStratumId;

  ivec2 brightestGlobalPos;
  float brightestLuminance;
  getBrightestInStratum(localStratumId, stratumId, brightestGlobalPos,
                        brightestLuminance);

  if (brightestLuminance > 0) {
    forwardProjection(brightestGlobalPos, brightestLuminance);
  }
}