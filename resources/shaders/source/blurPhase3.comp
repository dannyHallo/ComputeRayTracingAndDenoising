#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

#include "include/blurCommon.glsl"

layout(binding = 0, rgba8) uniform image2D aTrousTex2;
layout(binding = 1, rgba8) uniform image2D normalTex;
layout(binding = 2, rgba8) uniform image2D depthTex;
layout(binding = 3, rgba32f) uniform image2D posTex;
layout(binding = 4, rgba8) uniform image2D targetTex;

ivec2 uv;
vec3 positionAtUV, normalAtUV;
vec4 colorAtUV;
float luminanceAtUV, depthAtUV;

void blurKernel(int indexX, int indexY, inout float sumOfWeights,
                inout vec4 sumOfWeightedValues) {
  int x = indexX - kernalHalfSize;
  int y = indexY - kernalHalfSize;

  float luminanceAtSample =
      rgbToLuminance(imageLoad(aTrousTex2, uv + ivec2(x, y)));
  float differenceInColorVec = abs(luminanceAtSample - luminanceAtUV);
  float weightC = exp(-differenceInColorVec * 10);

  // introduce the cosine term to describe normal edge stopping function
  vec3 normalAtSample = imageLoad(normalTex, uv + ivec2(x, y)).xyz;
  float weightN = max(0., pow(dot(normalAtSample, normalAtUV), 128.));

  float weight = weightN * weightC;

  sumOfWeightedValues += weight * imageLoad(aTrousTex2, uv + ivec2(x, y));
  sumOfWeights += weight;
}

void main() {
  uv = ivec2(gl_GlobalInvocationID.xy);

  colorAtUV = imageLoad(aTrousTex2, uv);
  luminanceAtUV = rgbToLuminance(colorAtUV);
  positionAtUV = imageLoad(posTex, uv).xyz;
  normalAtUV = imageLoad(normalTex, uv).xyz;
  depthAtUV = imageLoad(depthTex, uv).x;

  float sumOfWeights = 0;
  vec4 sumOfWeightedValues = vec4(0);
  vec4 weightedColor = vec4(0);

  for (int indexX = 0; indexX < kernelSize; indexX++) {
    for (int indexY = 0; indexY < kernelSize; indexY++) {
      blurKernel(indexX, indexY, sumOfWeights, sumOfWeightedValues);
    }
  }
  weightedColor = sumOfWeightedValues / sumOfWeights;
  imageStore(targetTex, uv, weightedColor);
  // imageStore(targetTex, uv, colorAtUV);
}