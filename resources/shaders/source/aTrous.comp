#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// bigger phi indicates bigger tolerence to apply blur
layout(binding = 1) uniform UniformBufferObject {
  bool bypassBluring;
  int i;
  int iCap; // ranged from 0 - 5
  bool useVarianceGuidedFiltering;
  bool useGradientInDepth;
  float phiLuminance;
  float phiDepth;
  float phiNormal;
  bool ignoreLuminanceAtFirstIteration;
  bool changingLuminancePhi;
  bool useJittering;
}
ubo;

layout(binding = 2, rgba8) readonly uniform image2D aTrousInputTex;
layout(binding = 3, rgba8) readonly uniform image2D normalTex;
layout(binding = 4, r32f) readonly uniform image2D depthTex;
layout(binding = 5, rg32f) readonly uniform image2D gradientTex;
layout(binding = 6, r32f) readonly uniform image2D varianceTex;
layout(binding = 7, rgba8) writeonly uniform image2D accumTex;
layout(binding = 8, rgba8) writeonly uniform image2D aTrousOutputTex;
// the buffer that contains all triangles (read only)
layout(std430, binding = 9) readonly buffer SobolBufferObject {
  int[] sobol_256spp_256d;
};

layout(std430, binding = 10) readonly buffer ScramblingBufferObject {
  int[] scramblingTile;
};

layout(std430, binding = 11) readonly buffer RankingBufferObject {
  int[] rankingTile;
};

#include "include/definitions.glsl"
#include "include/globalUbo.glsl"
#include "include/random.glsl"

// standard 3x3 filtering kernel from q2rtx
const float waveletFac      = 0.5;
const float kernel3x3[2][2] = {{1.0, waveletFac},
                               {waveletFac, waveletFac *waveletFac}};

ivec2 uv;

vec2 gradientAtUv;
vec3 normalAtUv;
vec3 colorAtUv;
float depthAtUv;
float varianceAtUv;
float luminanceAtUv;

ivec2 jittering(int stepSize) {
  vec2 ldsNoise = ldsNoise2d(globalUbo.currentSample * 19937 + ubo.i + uv.x,
                             globalUbo.currentSample * 19937 + ubo.i + uv.y);
  ldsNoise -= 0.5;
  ldsNoise *= 0.5;
  ivec2 jitter = ivec2(ldsNoise * stepSize);
  return jitter;
}

void loadData(ivec2 offsetXY, out vec2 gradientAtUv, out vec3 normalAtUv,
              out vec3 colorAtUv, out float depthAtUv, out float varianceAtUv) {
  ivec2 ipos = uv + offsetXY;
  if (ipos.x < 0 || ipos.y < 0 || ipos.x >= globalUbo.swapchainWidth ||
      ipos.y >= globalUbo.swapchainHeight) {
    ipos = clamp(
        ipos, ivec2(0),
        ivec2(globalUbo.swapchainWidth - 1, globalUbo.swapchainHeight - 1));
  }

  gradientAtUv = imageLoad(gradientTex, ipos).xy;
  normalAtUv   = imageLoad(normalTex, ipos).xyz;
  colorAtUv    = imageLoad(aTrousInputTex, ipos).xyz;
  depthAtUv    = imageLoad(depthTex, ipos).x;
  varianceAtUv = imageLoad(varianceTex, ipos).x;
}

void blurKernel(ivec2 dispatchXY, int kernalHalfSize, inout float weightSum,
                inout vec4 sumOfWeightedValues) {
  int stepSize   = 1 << ubo.i;
  ivec2 offsetXY = dispatchXY * stepSize;
  if (ubo.useJittering && dispatchXY != ivec2(0)) {
    offsetXY += jittering(stepSize);
  }

  float weightK = kernel3x3[abs(dispatchXY.x)][abs(dispatchXY.y)];
  if (dispatchXY == ivec2(0)) {
    float weight = weightK;
    weight       = clamp(weight, 0, 1);
    weightSum += weight;
    sumOfWeightedValues += weight * vec4(colorAtUv, 1);
  } else {
    float weightC, weightN, weightZ;

    vec2 gradientAtSample;
    vec3 normalAtSample;
    vec3 colorAtSample;
    float depthAtSample;
    float varianceAtSample;
    loadData(offsetXY, gradientAtSample, normalAtSample, colorAtSample,
             depthAtSample, varianceAtSample);

    float luminanceAtSample = dot(kRgbToLuminanceMat, colorAtSample);
    float phiC              = ubo.phiLuminance;
    if (ubo.changingLuminancePhi) {
      phiC = pow(2, -ubo.i) * ubo.phiLuminance;
    }
    weightC       = 0;
    float colDiff = abs(luminanceAtSample - luminanceAtUv);
    if (ubo.useVarianceGuidedFiltering) {
      phiC *= 100.;
      weightC = exp(-colDiff / max(phiC * sqrt(varianceAtUv), kEpsilon));
    } else {
      weightC = exp(-colDiff / phiC);
    }
    if (ubo.ignoreLuminanceAtFirstIteration && ubo.i == 0) {
      weightC = 1.0;
    }

    weightN = max(0., pow(dot(normalAtUv, normalAtSample), ubo.phiNormal));

    float differenceInDepth = 0;
    // using gradient here can better blend samples within a single screen space
    // tilted mesh
    if (ubo.useGradientInDepth) {
      differenceInDepth =
          abs((depthAtUv - depthAtSample) - dot(gradientAtUv, vec2(offsetXY)));
    } else {
      differenceInDepth = abs(depthAtUv - depthAtSample);
    }
    weightZ = exp(-differenceInDepth / ubo.phiDepth);

    float weight = weightK * weightC * weightN * weightZ;
    weightSum += weight;
    sumOfWeightedValues += weight * vec4(colorAtSample, 1);
  }
}

void main() {
  uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= globalUbo.swapchainWidth || uv.y >= globalUbo.swapchainHeight)
    return;

  loadData(ivec2(0), gradientAtUv, normalAtUv, colorAtUv, depthAtUv,
           varianceAtUv);

  luminanceAtUv = dot(kRgbToLuminanceMat, colorAtUv);

  if (ubo.bypassBluring || ubo.i >= ubo.iCap) {
    if (ubo.i == 0) {
      imageStore(accumTex, uv, vec4(colorAtUv, 1));
    }
    imageStore(aTrousOutputTex, uv, vec4(colorAtUv, 1));
    return;
  }

  const int kernelSize     = 3;
  const int kernalHalfSize = 1;

  float weightSum          = 0;
  vec4 sumOfWeightedValues = vec4(0);
  for (int indexX = -kernalHalfSize; indexX <= kernalHalfSize; indexX++) {
    for (int indexY = -kernalHalfSize; indexY <= kernalHalfSize; indexY++) {
      blurKernel(ivec2(indexX, indexY), kernalHalfSize, weightSum,
                 sumOfWeightedValues);
    }
  }

  vec4 weightedColor = sumOfWeightedValues / weightSum;

  if (ubo.i == 0) {
    imageStore(accumTex, uv, weightedColor);
  }

  imageStore(aTrousOutputTex, uv, weightedColor);
}