#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

const float pi      = 3.1415926535897932385;
const float epsilon = 1e-8;

// const float weightsATrous3x3[3] = float[](.17, .66, .17);
const float weightsATrous5x5[5] = float[](.0625, .25, .375, .25, .0625);

const vec3 rgbToLuminanceMat = vec3(0.2989, 0.5870, 0.1140);

// bigger phi indicates bigger tolerence to apply blur
layout(binding = 0) uniform UniformBufferObject {
  bool bypassBluring;
  int i;
  int iCap; // ranged from 0 - 5
  float phiLuminance;
  float phiDepth;
  float phiNormal;
  float centralKernelWeight;
  bool useThreeByThreeKernel;
  bool ignoreLuminanceAtFirstIteration;
  bool changingLuminancePhi;
}
ubo;

layout(binding = 1, rgba8) readonly uniform image2D aTrousInputTex;
layout(binding = 2, rgba8) readonly uniform image2D normalTex;
layout(binding = 3, r32f) readonly uniform image2D depthTex;
layout(binding = 4, rg32f) readonly uniform image2D gradientTex;
layout(binding = 5, rg32f) readonly uniform image2D varianceTex;
layout(binding = 6, rgba8) writeonly uniform image2D aTrousOutputTex;

ivec2 uv;
vec2 gradientAtUV;
vec3 normalAtUV;
float luminanceAtUV, depthAtUV;

void blurKernel(int indexX, int indexY, int kernalHalfSize,
                inout float sumOfWeights, inout vec4 sumOfWeightedValues) {
  int x = int((indexX - kernalHalfSize) * pow(2, ubo.i));
  int y = int((indexY - kernalHalfSize) * pow(2, ubo.i));

  float customizedWeightsForATrous3x3[3] =
      float[]((1 - ubo.centralKernelWeight) * 0.5, ubo.centralKernelWeight,
              (1 - ubo.centralKernelWeight) * 0.5);

  float weightDistFalloff = 0;
  if (ubo.useThreeByThreeKernel) {
    weightDistFalloff = customizedWeightsForATrous3x3[indexX] *
                        customizedWeightsForATrous3x3[indexY];
  } else {
    weightDistFalloff = weightsATrous5x5[indexX] * weightsATrous5x5[indexY];
  }

  float luminanceAtSample =
      dot(rgbToLuminanceMat, imageLoad(aTrousInputTex, uv + ivec2(x, y)).xyz);

  float differenceInColorVec = abs(luminanceAtSample - luminanceAtUV);

  float phiC = ubo.phiLuminance;
  if (ubo.changingLuminancePhi) {
    phiC = pow(2, -ubo.i) * ubo.phiLuminance;
  }
  float weightC = exp(-differenceInColorVec / phiC);
  if (ubo.ignoreLuminanceAtFirstIteration && ubo.i == 0) {
    weightC = 1.0;
  }

  // introduce the cosine term to describe normal edge stopping function
  vec3 normalAtSample = imageLoad(normalTex, uv + ivec2(x, y)).xyz;
  float weightN = max(0., pow(dot(normalAtSample, normalAtUV), ubo.phiNormal));

  float depthAtSample = imageLoad(depthTex, uv + ivec2(x, y)).x;
  float differenceInDepth =
      abs((depthAtUV - depthAtSample) - dot(gradientAtUV, vec2(x, y)));
  float weightZ = exp(-differenceInDepth / ubo.phiDepth);

  float weight = weightDistFalloff * weightN * weightC * weightZ;

  sumOfWeightedValues += weight * imageLoad(aTrousInputTex, uv + ivec2(x, y));
  sumOfWeights += weight;
}

void main() {
  uv             = ivec2(gl_GlobalInvocationID.xy);
  vec4 colorAtUV = imageLoad(aTrousInputTex, uv);

  if (ubo.i >= ubo.iCap) {
    imageStore(aTrousOutputTex, uv, imageLoad(aTrousInputTex, uv));
    return;
  }

  luminanceAtUV = dot(rgbToLuminanceMat, colorAtUV.xyz);
  normalAtUV    = imageLoad(normalTex, uv).xyz;
  depthAtUV     = imageLoad(depthTex, uv).x;

  gradientAtUV = imageLoad(gradientTex, uv).xy;

  if (ubo.bypassBluring) {
    imageStore(aTrousOutputTex, uv, colorAtUV);
    return;
  }

  int kernelSize     = ubo.useThreeByThreeKernel ? 3 : 5;
  int kernalHalfSize = (kernelSize - 1) / 2;

  float sumOfWeights       = 0;
  vec4 sumOfWeightedValues = vec4(0);
  for (int indexX = 0; indexX < kernelSize; indexX++) {
    for (int indexY = 0; indexY < kernelSize; indexY++) {
      blurKernel(indexX, indexY, kernalHalfSize, sumOfWeights,
                 sumOfWeightedValues);
    }
  }

  vec4 weightedColor = sumOfWeightedValues / sumOfWeights;

  // imageStore(aTrousOutputTex, uv, vec4(gradientAtUV, 0, 1));
  imageStore(aTrousOutputTex, uv, weightedColor);
}