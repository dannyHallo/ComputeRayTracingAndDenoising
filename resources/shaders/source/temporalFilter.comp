#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0) uniform UniformBufferObject {
  mat4 lastMvpe;
  float swapchainWidth;
  float swapchainHeight;
}
ubo;

layout(binding = 1, rgba32f) uniform image2D posTex;
layout(binding = 2, rgba8) uniform image2D targetTex;
layout(binding = 3, rgba8) uniform image2D accumTex;
layout(binding = 4, rgba8) uniform image2D normalTex;
layout(binding = 5, r32i) uniform iimage2D triIdTex1;
layout(binding = 6, r32i) uniform iimage2D triIdTex2;
layout(binding = 7, rgba8) uniform image2D beforeBlurTex;

const bool bypassTemporalFiltering = false;

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  vec4 pixPos = imageLoad(posTex, uv);

  vec4 thisTimeTracingResult = imageLoad(targetTex, uv);

  // invalid pos culling
  if (pixPos.a == -1) {
    return;
  }

  vec4 colToWrite;

  if (bypassTemporalFiltering) {
    colToWrite = thisTimeTracingResult;
    imageStore(beforeBlurTex, uv, colToWrite);
    return;
  }

  vec4 screenBoxCoord = ubo.lastMvpe * pixPos;
  // points are bounded in [-1, 1] in x, y, z after the following
  screenBoxCoord /= screenBoxCoord.w;
  // points are bounded in [0, 1] in x, y, meanwhile z, w are thrown away
  screenBoxCoord = (screenBoxCoord + vec4(1)) / 2;
  // to vulkan uv coord, starts from top left corner, range is [0, 1]
  vec2 uvCoord = vec2(screenBoxCoord.x, 1 - screenBoxCoord.y);
  ivec2 uv2 =
      ivec2(uvCoord.x * ubo.swapchainWidth, uvCoord.y * ubo.swapchainHeight);

  float alpha = 0.1;

  vec4 accumTracingResult = imageLoad(accumTex, uv2);
  // invalid accumTex
  if (accumTracingResult.a == 0)
    alpha = 1;

  // occlution happened last frame
  if (imageLoad(triIdTex1, uv) != imageLoad(triIdTex2, uv2))
    alpha = 1;

  colToWrite =
      (alpha * thisTimeTracingResult + (1 - alpha) * accumTracingResult);

  imageStore(beforeBlurTex, uv, colToWrite);
}