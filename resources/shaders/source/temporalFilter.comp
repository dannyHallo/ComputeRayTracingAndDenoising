#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0) uniform UniformBufferObject {
  bool bypassTemporalFiltering;
  mat4 lastMvpe;
  uint swapchainWidth;
  uint swapchainHeight;
}
ubo;

layout(binding = 1, rgba32f) uniform image2D posTex;
layout(binding = 2, rgba32f) uniform image2D rawTex;
layout(binding = 3, rgba8) uniform image2D accumTex;
layout(binding = 4, rgba8) uniform image2D normalTex;
layout(binding = 5, r32f) uniform image2D depthTex;
layout(binding = 6, r32ui) uniform uimage2D meshHashTex1;
layout(binding = 7, r32ui) uniform uimage2D meshHashTex2;
layout(binding = 8, rgba8) uniform image2D aTrousTex1;

// when alpha is too low, the image is over-smoothed -> loss of detail
// when alpha is too high, the image is unstable     -> jitter of noise
float alpha = 0.15;

ivec2 uv;
vec4 pixPos;

ivec2 backwardProjection() {
  vec4 screenBoxCoord = ubo.lastMvpe * pixPos;
  // points are bounded in [-1, 1] in x, y, z after the following
  screenBoxCoord /= screenBoxCoord.w;
  // points are bounded in [0, 1] in x, y, meanwhile z, w are thrown away
  screenBoxCoord = (screenBoxCoord + vec4(1)) / 2;
  // to vulkan uv coord, starts from top left corner, range is [0, 1]
  vec2 uvCoord = vec2(screenBoxCoord.x, 1 - screenBoxCoord.y);
  return ivec2(uvCoord.x * ubo.swapchainWidth, uvCoord.y * ubo.swapchainHeight);
}

vec4 customMixing(vec4 accum, vec4 thisTime, float alpha) {
  if (alpha == 1) {
    return thisTime;
  }

  alpha = 0.05;

  vec4 result = mix(accum, thisTime, alpha);
  return result;
}

void main() {
  uv     = ivec2(gl_GlobalInvocationID.xy);
  pixPos = imageLoad(posTex, uv);

  vec4 thisTimeTracingResult = imageLoad(rawTex, uv);

  // invalid pos culling
  if (pixPos.a == -1) {
    return;
  }

  vec4 colToWrite;

  if (ubo.bypassTemporalFiltering) {
    colToWrite = thisTimeTracingResult;
    imageStore(aTrousTex1, uv, colToWrite);
    return;
  }

  ivec2 uv2 = backwardProjection();

  vec4 accumTracingResult = imageLoad(accumTex, uv2);

  // invalid prev accumTex || different prev mesh (not triangle)
  if (accumTracingResult.a == 0 || imageLoad(meshHashTex1, uv) != imageLoad(meshHashTex2, uv2)) {
    alpha = 1;
  }

  // colToWrite = mix(accumTracingResult, thisTimeTracingResult, alpha);
  colToWrite = customMixing(accumTracingResult, thisTimeTracingResult, alpha);
  imageStore(aTrousTex1, uv, colToWrite);
}