#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 1) uniform UniformBufferObject { uint displayType; }
ubo;

layout(binding = 2, rgba8) readonly uniform image2D aTrousTex2;
layout(binding = 3, r32f) readonly uniform image2D varianceTex;
layout(binding = 4, rgba32f) readonly uniform image2D stratumTex;
layout(binding = 5, rgba8) writeonly uniform image2D targetTex;

#include "include/globalUbo.glsl"

#define DISPLAY_TYPE_NORMAL 0
#define DISPLAY_TYPE_VARIANCE 1
#define DISPLAY_TYPE_STRATUM 2

// Converts a color from linear light gamma to sRGB gamma
// https://gamedev.stackexchange.com/questions/92015/optimized-linear-to-srgb-glsl
vec4 linearToSrgb(vec4 linearRGB) {
  bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));
  vec4 higher  = vec4(1.055) * pow(linearRGB, vec4(1.0 / 2.4)) - vec4(0.055);
  vec4 lower   = linearRGB * vec4(12.92);

  return mix(higher, lower, cutoff);
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= globalUbo.swapchainWidth || uv.y >= globalUbo.swapchainHeight) {
    return;
  }

  vec4 writingCol = vec4(0, 0, 0, 1);
  switch (ubo.displayType) {
  case DISPLAY_TYPE_NORMAL: {
    writingCol = linearToSrgb(imageLoad(aTrousTex2, uv));
    break;
  }
  case DISPLAY_TYPE_VARIANCE: {
    float varianceAtUv = imageLoad(varianceTex, uv).r;
    varianceAtUv       = min(varianceAtUv * 100, 1);
    writingCol         = vec4(varianceAtUv, 0, 0, 1);
    break;
  }
  case DISPLAY_TYPE_STRATUM: {
    ivec2 lookUpUpscaled = ivec2(vec2(uv) / 3.0);
    vec4 stratumAtUv     = imageLoad(stratumTex, lookUpUpscaled);
    writingCol           = vec4(stratumAtUv.xy / 3.0, stratumAtUv.z, 1);
    break;
  }
  }
  // inverting the color space (rgb to bgr)
  imageStore(targetTex, uv, vec4(writingCol.zyx, 1));
}