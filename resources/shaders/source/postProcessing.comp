#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 1) uniform UniformBufferObject { uint displayType; }
ubo;

layout(binding = 2, rgba8) readonly uniform image2D aTrousTex2;
layout(binding = 3, r32f) readonly uniform image2D varianceTex;
layout(binding = 4, rgba32f) readonly uniform image2D rawTex;
layout(binding = 5, rgba32f) readonly uniform image2D stratumTex;
layout(binding = 6, rgba32f) readonly uniform image2D visibilityTex;
layout(binding = 7, rgba32f) readonly uniform image2D temporalGradientTex;
layout(binding = 8, rgba8) writeonly uniform image2D targetTex;

#include "include/globalUbo.glsl"

#define DISPLAY_TYPE_NORMAL 0
#define DISPLAY_TYPE_VARIANCE 1
#define DISPLAY_TYPE_RAW 2
#define DISPLAY_TYPE_STRATUM 3
#define DISPLAY_TYPE_VISIBILITY 4
#define DISPLAY_TYPE_TEMPORAL_GRADIENT 5
#define DISPLAY_TYPE_CUSTOM 6

// Converts a color from linear light gamma to sRGB gamma
// https://gamedev.stackexchange.com/questions/92015/optimized-linear-to-srgb-glsl
vec4 linearToSrgb(vec4 linearRGB) {
  bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));
  vec4 higher  = vec4(1.055) * pow(linearRGB, vec4(1.0 / 2.4)) - vec4(0.055);
  vec4 lower   = linearRGB * vec4(12.92);

  return mix(higher, lower, cutoff);
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= globalUbo.swapchainWidth || uv.y >= globalUbo.swapchainHeight)
    return;

  vec3 writingCol = vec3(0);
  switch (ubo.displayType) {
  case DISPLAY_TYPE_NORMAL: {
    writingCol = linearToSrgb(imageLoad(aTrousTex2, uv)).xyz;
    break;
  }
  case DISPLAY_TYPE_VARIANCE: {
    float varianceAtUv = imageLoad(varianceTex, uv).r;
    varianceAtUv       = min(varianceAtUv * 100, 1);
    writingCol         = vec3(varianceAtUv, 0, 0);
    break;
  }
  case DISPLAY_TYPE_RAW: {
    writingCol = imageLoad(rawTex, uv).xyz;
    break;
  }
  case DISPLAY_TYPE_STRATUM: {
    ivec2 lookUpUpscaled = ivec2(vec2(uv) / 3.0);
    vec4 stratumAtUv     = imageLoad(stratumTex, lookUpUpscaled);
    writingCol           = vec3(stratumAtUv.xy / 3.0, stratumAtUv.z);
    break;
  }
  case DISPLAY_TYPE_VISIBILITY: {
    writingCol = imageLoad(visibilityTex, uv).xyz;
    break;
  }
  case DISPLAY_TYPE_TEMPORAL_GRADIENT: {
    writingCol = imageLoad(temporalGradientTex, uv).xyz;
    break;
  }
  case DISPLAY_TYPE_CUSTOM: {
    vec3 c     = imageLoad(aTrousTex2, uv).xyz;
    writingCol = c == vec3(1, 0, 1) ? vec3(1) : vec3(0);
    break;
  }
  }
  // inverting the color space (rgb to bgr)
  imageStore(targetTex, uv, vec4(writingCol.zyx, 1));
}