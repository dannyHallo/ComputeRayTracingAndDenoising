#version 450
#extension GL_GOOGLE_include_directive : require

#define STRATUM_SIZE 3

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 1) uniform UniformBufferObject { uint displayType; }
ubo;

layout(binding = 2, rgba32f) readonly uniform image2D aTrousTex2;
layout(binding = 3, r32f) readonly uniform image2D varianceTex;
layout(binding = 4, r32f) readonly uniform image2D rawTex;
layout(binding = 5, r32ui) readonly uniform uimage2D stratumTex;
layout(binding = 6, rgba32f) readonly uniform image2D visibilityTex;
layout(binding = 7, rgba32f) readonly uniform image2D temporalGradientTex;
layout(binding = 8, rgba8) readonly uniform image2DArray customTexArray;
layout(binding = 9, rgba8) writeonly uniform image2D targetTex;

#include "include/globalUbo.glsl"

#define DISPLAY_TYPE_NORMAL 0
#define DISPLAY_TYPE_VARIANCE 1
#define DISPLAY_TYPE_RAW 2
#define DISPLAY_TYPE_STRATUM 3
#define DISPLAY_TYPE_VISIBILITY 4
#define DISPLAY_TYPE_TEMPORAL_GRADIENT 5
#define DISPLAY_TYPE_CUSTOM 6

// Converts a color from linear light gamma to sRGB gamma
// https://gamedev.stackexchange.com/questions/92015/optimized-linear-to-srgb-glsl
vec4 linearToSrgb(vec4 linearRGB) {
  bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));
  vec4 higher  = vec4(1.055) * pow(linearRGB, vec4(1.0 / 2.4)) - vec4(0.055);
  vec4 lower   = linearRGB * vec4(12.92);

  return mix(higher, lower, cutoff);
}

uvec2 decodeOffsetInStratum(uint offset) {
  return uvec2(offset % STRATUM_SIZE, offset / STRATUM_SIZE);
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= globalUbo.swapchainWidth || uv.y >= globalUbo.swapchainHeight) return;

  vec3 writingCol = vec3(0);
  switch (ubo.displayType) {
  case DISPLAY_TYPE_NORMAL: {
    writingCol = linearToSrgb(imageLoad(aTrousTex2, uv)).xyz;
    break;
  }
  case DISPLAY_TYPE_VARIANCE: {
    float varianceAtUv = imageLoad(varianceTex, uv).r;
    varianceAtUv       = min(varianceAtUv * 100, 1);
    writingCol         = vec3(varianceAtUv, 0, 0);
    break;
  }
  case DISPLAY_TYPE_RAW: {
    writingCol = imageLoad(rawTex, uv).xyz;
    break;
  }
  case DISPLAY_TYPE_STRATUM: {
    ivec2 stratumUv     = uv / 3;
    uint offset         = imageLoad(stratumTex, stratumUv).x;
    uvec2 stratumOffset = decodeOffsetInStratum(offset);
    writingCol          = vec3(stratumOffset.xy / 3.0, 0);
    break;
  }
  case DISPLAY_TYPE_VISIBILITY: {
    ivec2 stratumUv = uv / 3;
    writingCol      = imageLoad(visibilityTex, stratumUv).xyz;

    break;
  }
  case DISPLAY_TYPE_TEMPORAL_GRADIENT: {
    ivec2 stratumUv = uv / 3;

    vec4 readVal           = imageLoad(temporalGradientTex, stratumUv);
    float grad             = readVal.z;
    float normalizationFac = readVal.w;

    if (normalizationFac == 0) {
      grad = 0;
    } else {
      grad = grad / normalizationFac;
    }

    if (grad < 0) {
      writingCol = vec3(-grad, 0, 0);
    } else {
      writingCol = vec3(0, grad, 0);
    }
    break;
  }
  case DISPLAY_TYPE_CUSTOM: {
    // tile the image across the screen
    ivec3 size      = imageSize(customTexArray);
    uint usingLayer = globalUbo.currentSample % size.z;

    int x        = uv.x % size.x;
    int y        = uv.y % size.y;
    ivec3 lookup = ivec3(x, y, usingLayer);
    writingCol   = vec3(imageLoad(customTexArray, lookup).xyz);
  }
  }

  // swap color channels (rgb to bgr)
  imageStore(targetTex, uv, vec4(writingCol.zyx, 1));
}