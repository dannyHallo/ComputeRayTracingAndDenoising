#version 450
#extension GL_GOOGLE_include_directive : require

#define STRATUM_SIZE 3

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 1) uniform UniformBufferObject { uint displayType; }
ubo;

layout(binding = 2, rgba32f) readonly uniform image2D aTrousTex2;
layout(binding = 3, r32f) readonly uniform image2D varianceTex;
layout(binding = 4, r32f) readonly uniform image2D rawTex;
layout(binding = 5, r32ui) readonly uniform uimage2D stratumTex;
layout(binding = 6, rgba32f) readonly uniform image2D visibilityTex;
layout(binding = 7, rgba32f) readonly uniform image2D temporalGradientTex;
layout(binding = 8, rgba32ui) readonly uniform uimage2D seedTex;
layout(binding = 9, rgba8) writeonly uniform image2D targetTex;

#include "include/globalUbo.glsl"

#define DISPLAY_TYPE_NORMAL 0
#define DISPLAY_TYPE_VARIANCE 1
#define DISPLAY_TYPE_RAW 2
#define DISPLAY_TYPE_STRATUM 3
#define DISPLAY_TYPE_VISIBILITY 4
#define DISPLAY_TYPE_TEMPORAL_GRADIENT 5
#define DISPLAY_TYPE_CUSTOM 6

// this hashing function is probably to be the best one of its kind
// https://nullprogram.com/blog/2018/07/31/
uint hash(uint x) {
  x ^= x >> 16;
  x *= 0x7feb352dU;
  x ^= x >> 15;
  x *= 0x846ca68bU;
  x ^= x >> 16;
  return x;
}

// Construct a float with half-open range [0:1] using low 23 bits.
// All zeroes yields 0.0, all ones yields the next smallest representable value
// below 1.0.
float floatConstruct(uint m) {
  const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
  const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32

  m &= ieeeMantissa; // Keep only mantissa bits (fractional part)
  m |= ieeeOne;      // Add fractional part to 1.0

  float f = uintBitsToFloat(m); // Range [1:2]
  return f - 1.0;               // Range [0:1]
}

// Converts a color from linear light gamma to sRGB gamma
// https://gamedev.stackexchange.com/questions/92015/optimized-linear-to-srgb-glsl
vec4 linearToSrgb(vec4 linearRGB) {
  bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));
  vec4 higher  = vec4(1.055) * pow(linearRGB, vec4(1.0 / 2.4)) - vec4(0.055);
  vec4 lower   = linearRGB * vec4(12.92);

  return mix(higher, lower, cutoff);
}

uvec2 decodeOffsetInStratum(uint offset) {
  return uvec2(offset % STRATUM_SIZE, offset / STRATUM_SIZE);
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= globalUbo.swapchainWidth || uv.y >= globalUbo.swapchainHeight) return;

  vec3 writingCol = vec3(0);
  switch (ubo.displayType) {
  case DISPLAY_TYPE_NORMAL: {
    writingCol = linearToSrgb(imageLoad(aTrousTex2, uv)).xyz;
    break;
  }
  case DISPLAY_TYPE_VARIANCE: {
    float varianceAtUv = imageLoad(varianceTex, uv).r;
    varianceAtUv       = min(varianceAtUv * 100, 1);
    writingCol         = vec3(varianceAtUv, 0, 0);
    break;
  }
  case DISPLAY_TYPE_RAW: {
    writingCol = imageLoad(rawTex, uv).xyz;
    break;
  }
  case DISPLAY_TYPE_STRATUM: {
    ivec2 stratumUv     = uv / 3;
    uint offset         = imageLoad(stratumTex, stratumUv).x;
    uvec2 stratumOffset = decodeOffsetInStratum(offset);
    writingCol          = vec3(stratumOffset.xy / 3.0, 0);
    break;
  }
  case DISPLAY_TYPE_VISIBILITY: {
    ivec2 stratumUv = uv / 3;
    vec3 readVal    = imageLoad(visibilityTex, stratumUv).xyz;
    float xFract    = abs(fract(readVal.x) - 0.5);
    float yFract    = abs(fract(readVal.y) - 0.5);

    writingCol = vec3(xFract, 0, yFract) * 1000;
    break;
  }
  case DISPLAY_TYPE_TEMPORAL_GRADIENT: {
    ivec2 stratumUv = uv / 3;

    vec4 readVal           = imageLoad(temporalGradientTex, stratumUv);
    float grad             = readVal.z;
    float normalizationFac = readVal.w;

    if (normalizationFac == 0) {
      grad = 0;
    } else {
      grad = grad / normalizationFac;
    }

    if (grad < 0) {
      writingCol = vec3(-grad, 0, 0);
    } else {
      writingCol = vec3(0, grad, 0);
    }

    // writingCol = vec3(0, readVal.zw);
    break;
  }
  case DISPLAY_TYPE_CUSTOM: {
    uvec3 seed = imageLoad(seedTex, uv).xyz;
    writingCol = vec3(floatConstruct(hash(seed.x)), floatConstruct(hash(seed.y)),
                      floatConstruct(hash(seed.z)));
    break;
  }
  }

  // swap color channels (rgb to bgr)
  imageStore(targetTex, uv, vec4(writingCol.zyx, 1));
}