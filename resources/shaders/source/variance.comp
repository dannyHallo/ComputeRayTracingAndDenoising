#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0) uniform UniformBufferObject {
  bool bypassVarianceEstimation;
  bool skipStoppingFunctions;
  int kernelSize; // not used
  float phiGaussian;
  float phiDepth;
}
ubo;

layout(binding = 1, rgba8) readonly uniform image2D textureForVarianceCalc;
layout(binding = 2, rgba8) readonly uniform image2D normalTex;
layout(binding = 3, r32f) readonly uniform image2D depthTex;
layout(binding = 4, rg32f) writeonly uniform image2D gradientTex;
layout(binding = 5, r32f) writeonly uniform image2D varianceTex;
// l1, l2, sample count, NA
layout(binding = 6, rgba32f) uniform image2D varianceHistTex;

ivec2 uv;
vec2 gradientAtUV;
vec3 normalAtUV;
float luminanceAtUV, depthAtUV, varianceAtUV;

const vec3 rgbToLuminanceMat = vec3(0.2989, 0.5870, 0.1140);

float readDepth(ivec2 offset) {
  ivec2 texSize = imageSize(depthTex);
  ivec2 p       = uv + offset;

  // if read pos is out of image bounds, return -1
  if (any(lessThan(p, ivec2(0))) || any(greaterThanEqual(p, texSize))) {
    return -1;
  }

  // otherwise, return the depth, if depth is -1 (nothit), return 100000
  float rawDepth = imageLoad(depthTex, p).x;
  return rawDepth == -1 ? 100000 : rawDepth;
}

vec2 calculateGradient() {
  float cDepth = readDepth(ivec2(0, 0));
  float rDepth = readDepth(ivec2(1, 0));
  float uDepth = readDepth(ivec2(0, 1));

  float gradientX = rDepth == -1 ? 0 : rDepth - cDepth;
  float gradientY = uDepth == -1 ? 0 : uDepth - cDepth;

  return vec2(gradientX, gradientY);
}

vec2 getLuminancePair(ivec2 offset) {
  ivec2 p    = uv + offset;
  vec3 color = imageLoad(textureForVarianceCalc, p).xyz;
  float l1   = dot(rgbToLuminanceMat, color);
  float l2   = l1 * l1;
  return vec2(l1, l2);
}

int varianceKernelSize     = ubo.kernelSize;
int varianceKernelHalfSize = (varianceKernelSize - 1) / 2;
float kernelSigma          = varianceKernelHalfSize / 3.;
float usingSigmaInv        = 1. / (2. * kernelSigma * kernelSigma);

// calculate variance using the variance kernel, or temporally
float calculateVariance() {
  vec2 luminancePairCalc = vec2(0);
  vec2 luminancePairAtUV = getLuminancePair(ivec2(0, 0));
  float weightSumCalc    = 0;

  vec3 varianceHist             = imageLoad(varianceHistTex, uv).xyz;
  vec2 luminancePairHist        = varianceHist.xy;
  float varianceHistSampleCount = varianceHist.z;
  if (false) {
    weightSumCalc     = varianceHistSampleCount + 1;
    luminancePairCalc = luminancePairHist + luminancePairAtUV;
  } else {
    for (int indexY = 0; indexY < varianceKernelSize; indexY++) {
      for (int indexX = 0; indexX < varianceKernelSize; indexX++) {
        int x = indexX - varianceKernelHalfSize;
        int y = indexY - varianceKernelHalfSize;

        float weight = 1.;
        // these stopping functions reduce performances greatly, and don't seem
        // to be useful
        if (ubo.skipStoppingFunctions) {
          weight = 1.;
        } else {
          // float weightK = 1;
          float weightK = exp(-(x * x + y * y) * ubo.phiGaussian);

          vec3 normalAtSample = imageLoad(normalTex, uv + ivec2(x, y)).xyz;
          float weightN = max(0., pow(dot(normalAtSample, normalAtUV), 128.));

          float depthAtSample = readDepth(ivec2(x, y));
          float differenceInDepth =
              abs((depthAtUV - depthAtSample) - dot(gradientAtUV, vec2(x, y)));
          float weightZ = exp(-differenceInDepth / ubo.phiDepth);

          weight = weightK * weightN * weightZ;
        }

        weightSumCalc += weight;
        luminancePairCalc += weight * getLuminancePair(ivec2(x, y));
      }
    }
  }

  imageStore(varianceHistTex, uv,
             vec4(luminancePairHist + luminancePairAtUV,
                  varianceHistSampleCount + 1, 0));

  weightSumCalc  = max(weightSumCalc, 1e-8); // TODO: this might need a workaround
  float mean     = luminancePairCalc.x / weightSumCalc;
  float variance = luminancePairCalc.y / weightSumCalc - mean * mean;

  return variance;
}

void main() {
  uv = ivec2(gl_GlobalInvocationID.xy);

  if (ubo.bypassVarianceEstimation) {
    imageStore(gradientTex, uv, vec4(calculateGradient(), 0, 0));
    return;
  }

  normalAtUV   = imageLoad(normalTex, uv).xyz;
  depthAtUV    = imageLoad(depthTex, uv).x;
  gradientAtUV = calculateGradient();
  varianceAtUV = calculateVariance();

  imageStore(gradientTex, uv, vec4(gradientAtUV, 0, 0));
  imageStore(varianceTex, uv, vec4(varianceAtUV, 0, 0, 0));
}