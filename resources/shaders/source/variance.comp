#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0) uniform GlobalUniformBufferObject {
  uint swapchainWidth;
  uint swapchainHeight;
  uint currentSample;
  float time;
}
globalUbo;

layout(binding = 1) uniform UniformBufferObject {
  bool bypassVarianceEstimation;
  bool skipStoppingFunctions;
  bool useTemporalVariance;
  int kernelSize; // not used
  float phiGaussian;
  float phiDepth;
}
ubo;

layout(binding = 2, rgba8) readonly uniform image2D textureForVarianceCalc;
layout(binding = 3, rgba8) readonly uniform image2D normalTex;
layout(binding = 4, r32f) readonly uniform image2D depthTex;
layout(binding = 5, rg32f) readonly uniform image2D gradientTex;
layout(binding = 6, r32f) writeonly uniform image2D varianceTex;
// l1, l2, sample count, NA
layout(binding = 7, rgba32f) uniform image2D varianceHistTex;

ivec2 uv;
vec2 gradientAtUV;
vec3 normalAtUV;
float luminanceAtUV, depthAtUV, varianceAtUV;

const vec3 rgbToLuminanceMat = vec3(0.2989, 0.5870, 0.1140);
ivec2 texSize                = imageSize(depthTex);

bool outofBounds(ivec2 p) {
  return any(lessThan(p, ivec2(0))) || any(greaterThanEqual(p, texSize));
}

float readDepth(ivec2 offset) {
  ivec2 p = uv + offset;

  // if read pos is out of image bounds, return -1
  if (outofBounds(p)) {
    return -1;
  }

  // otherwise, return the depth, if depth is -1 (nothit), return 100000
  float rawDepth = imageLoad(depthTex, p).x;
  return rawDepth == -1 ? 100000 : rawDepth;
}

vec2 getLuminancePair(ivec2 offset) {
  ivec2 p = uv + offset;

  if (outofBounds(p)) {
    return vec2(-1, -1);
  }

  vec3 color = imageLoad(textureForVarianceCalc, p).xyz;
  float l1   = dot(rgbToLuminanceMat, color);
  float l2   = l1 * l1;
  return vec2(l1, l2);
}

int varianceKernelSize     = ubo.kernelSize;
int varianceKernelHalfSize = (varianceKernelSize - 1) / 2;

// calculate variance using the variance kernel, or temporally
float calculateVariance() {
  vec2 luminancePairCalc = vec2(0);
  vec2 luminancePairAtUV = getLuminancePair(ivec2(0, 0));
  if (luminancePairAtUV.x < 0) {
    return 0;
  }
  float weightSumCalc = 0;

  vec3 varianceHist             = imageLoad(varianceHistTex, uv).xyz;
  vec2 luminancePairHist        = varianceHist.xy;
  float varianceHistSampleCount = varianceHist.z;
  if (ubo.useTemporalVariance && varianceHistSampleCount > 4) {
    weightSumCalc     = varianceHistSampleCount + 1;
    luminancePairCalc = luminancePairHist + luminancePairAtUV;
  } else {
    for (int indexY = 0; indexY < varianceKernelSize; indexY++) {
      for (int indexX = 0; indexX < varianceKernelSize; indexX++) {
        int x = indexX - varianceKernelHalfSize;
        int y = indexY - varianceKernelHalfSize;

        float weight = 1.;
        // these stopping functions reduce performances and don't seem
        // to be useful to the visual effect
        if (!ubo.skipStoppingFunctions) {
          float weightK = exp(-(x * x + y * y) * ubo.phiGaussian);

          vec3 normalAtSample = imageLoad(normalTex, uv + ivec2(x, y)).xyz;
          float weightN = max(0., pow(dot(normalAtSample, normalAtUV), 128.));

          float depthAtSample = readDepth(ivec2(x, y));
          float differenceInDepth =
              abs((depthAtUV - depthAtSample) - dot(gradientAtUV, vec2(x, y)));
          float weightZ = exp(-differenceInDepth / ubo.phiDepth);

          weight = weightK * weightN * weightZ;
        }

        vec2 luminancePair = getLuminancePair(ivec2(x, y));
        if (luminancePair.x < 0) {
          continue;
        }

        weightSumCalc += weight;
        luminancePairCalc += weight * luminancePair;
      }
    }
  }

  imageStore(varianceHistTex, uv,
             vec4(luminancePairHist + luminancePairAtUV,
                  varianceHistSampleCount + 1, 0));

  weightSumCalc  = max(weightSumCalc, 1e-8);
  float mean     = luminancePairCalc.x / weightSumCalc;
  float variance = luminancePairCalc.y / weightSumCalc - mean * mean;

  return variance;
}

void main() {
  uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= globalUbo.swapchainWidth || uv.y >= globalUbo.swapchainHeight) {
    return;
  }

  if (ubo.bypassVarianceEstimation) { // TODO: remove this
    return;
  }

  normalAtUV   = imageLoad(normalTex, uv).xyz;
  depthAtUV    = readDepth(ivec2(0, 0));
  gradientAtUV = imageLoad(gradientTex, uv).xy;
  varianceAtUV = calculateVariance();

  imageStore(varianceTex, uv, vec4(varianceAtUV, 0, 0, 0));
}