#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0, rgba8) readonly uniform image2D textureForVarianceCalc;
layout(binding = 1, rgba8) readonly uniform image2D normalTex;
layout(binding = 2, r32f) readonly uniform image2D depthTex;
layout(binding = 3, rg32f) writeonly uniform image2D gradientTex;
layout(binding = 4, rg32f) writeonly uniform image2D varianceTex;

ivec2 uv;
vec2 gradientAtUV;
vec3 normalAtUV;
float luminanceAtUV, depthAtUV;

const int varianceKernelSize = 7; // 7x7 kernel
int varianceKernelHalfSize =
    (varianceKernelSize - 1) / 2; // 3 <- if using 7x7 kernel

const vec3 rgbToLuminanceMat = vec3(0.2989, 0.5870, 0.1140);

vec2 getVariancePairAtPoint(ivec2 offset) {
  ivec2 p    = uv + offset;
  vec4 pxCol = imageLoad(textureForVarianceCalc, p);

  float samp  = dot(rgbToLuminanceMat, pxCol.rgb);
  float samp2 = samp * samp;
  return vec2(samp, samp2);
}

float readDepth(ivec2 offset) {
  ivec2 texSize = imageSize(depthTex);
  ivec2 p       = uv + offset;

  // if read pos is out of image bounds, return -1
  if (any(lessThan(p, ivec2(0))) || any(greaterThanEqual(p, texSize))) {
    return -1;
  }

  // otherwise, return the depth, if depth is -1 (nothit), return 100000
  float rawDepth = imageLoad(depthTex, p).x;
  return rawDepth == -1 ? 100000 : rawDepth;
}

vec2 calculateGradient() {
  float cDepth = readDepth(ivec2(0, 0));
  float rDepth = readDepth(ivec2(1, 0));
  float uDepth = readDepth(ivec2(0, 1));

  float gradientX = rDepth == -1 ? 0 : rDepth - cDepth;
  float gradientY = uDepth == -1 ? 0 : uDepth - cDepth;

  return vec2(gradientX, gradientY);
}

void main() {
  uv             = ivec2(gl_GlobalInvocationID.xy);
  vec4 colorAtUV = imageLoad(textureForVarianceCalc, uv);

  luminanceAtUV = dot(rgbToLuminanceMat, colorAtUV.xyz);
  // normalAtUV    = imageLoad(normalTex, uv).xyz;
  // depthAtUV     = imageLoad(depthTex, uv).x;

  imageStore(gradientTex, uv, vec4(calculateGradient(), 0, 0));

  // uint samplesThisTime           = 0;
  // vec2 sigmaVariancePairThisTime = vec2(0);
  // for (int indexY = 0; indexY < varianceKernelSize; indexY++) {
  //   for (int indexX = 0; indexX < varianceKernelSize; indexX++) {
  //     int x = indexX - varianceKernelHalfSize;
  //     int y = indexY - varianceKernelHalfSize;
  //     sigmaVariancePairThisTime += getVariancePairAtPoint(ivec2(x, y));
  //     samplesThisTime++;
  //   }
  // }
  // sigmaVariancePairThisTime /= float(samplesThisTime);
  // imageStore(varianceTex, uv, vec4(sigmaVariancePairThisTime, 0, 0));
}