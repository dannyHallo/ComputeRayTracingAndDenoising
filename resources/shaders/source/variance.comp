#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0) uniform UniformBufferObject {
  bool bypassVarianceEstimation;
  bool skipStoppingFunctions;
  int kernelSize; // not used
  float phiGaussian;
  float phiDepth;
}
ubo;

layout(binding = 1, rgba8) readonly uniform image2D textureForVarianceCalc;
layout(binding = 2, rgba8) readonly uniform image2D normalTex;
layout(binding = 3, r32f) readonly uniform image2D depthTex;
layout(binding = 4, rg32f) writeonly uniform image2D gradientTex;
layout(binding = 5, rg32f) writeonly uniform image2D varianceTex;

ivec2 uv;
vec2 gradientAtUV;
vec3 normalAtUV;
float luminanceAtUV, depthAtUV;

const vec3 rgbToLuminanceMat = vec3(0.2989, 0.5870, 0.1140);

float readDepth(ivec2 offset) {
  ivec2 texSize = imageSize(depthTex);
  ivec2 p       = uv + offset;

  // if read pos is out of image bounds, return -1
  if (any(lessThan(p, ivec2(0))) || any(greaterThanEqual(p, texSize))) {
    return -1;
  }

  // otherwise, return the depth, if depth is -1 (nothit), return 100000
  float rawDepth = imageLoad(depthTex, p).x;
  return rawDepth == -1 ? 100000 : rawDepth;
}

vec2 calculateGradient() {
  float cDepth = readDepth(ivec2(0, 0));
  float rDepth = readDepth(ivec2(1, 0));
  float uDepth = readDepth(ivec2(0, 1));

  float gradientX = rDepth == -1 ? 0 : rDepth - cDepth;
  float gradientY = uDepth == -1 ? 0 : uDepth - cDepth;

  return vec2(gradientX, gradientY);
}

vec2 getLuminancePair(ivec2 offset) {
  ivec2 p    = uv + offset;
  vec3 color = imageLoad(textureForVarianceCalc, p).xyz;
  float l1   = dot(rgbToLuminanceMat, color);
  float l2   = l1 * l1;
  return vec2(l1, l2);
}

int varianceKernelSize     = ubo.kernelSize;
int varianceKernelHalfSize = (varianceKernelSize - 1) / 2;
float kernelSigma          = varianceKernelHalfSize / 3.;
float usingSigmaInv        = 1. / (2. * kernelSigma * kernelSigma);

vec2 calculateVariance() {
  vec2 luminancePair = vec2(0);
  float weightSum    = 0;
  for (int indexY = 0; indexY < varianceKernelSize; indexY++) {
    for (int indexX = 0; indexX < varianceKernelSize; indexX++) {
      int x = indexX - varianceKernelHalfSize;
      int y = indexY - varianceKernelHalfSize;

      float weight = 1.;
      // these stopping functions reduce performances greatly, and don't seem to
      // be useful
      if (ubo.skipStoppingFunctions) {
        weight = 1.;
      } else {
        // float weightK = 1;
        float weightK = exp(-(x * x + y * y) * ubo.phiGaussian);

        vec3 normalAtSample = imageLoad(normalTex, uv + ivec2(x, y)).xyz;
        float weightN = max(0., pow(dot(normalAtSample, normalAtUV), 128.));

        float depthAtSample = readDepth(ivec2(x, y));
        float differenceInDepth =
            abs((depthAtUV - depthAtSample) - dot(gradientAtUV, vec2(x, y)));
        float weightZ = exp(-differenceInDepth / ubo.phiDepth);

        weight = weightK * weightN * weightZ;
      }

      weightSum += weight;
      luminancePair += weight * getLuminancePair(ivec2(x, y));
    }
  }
  weightSum      = max(weightSum, 1e-8); // TODO: this needs a workaround
  float mean     = luminancePair.x / weightSum;
  float variance = luminancePair.y / weightSum - mean * mean;
  return vec2(mean, variance); // mean is not used
}

void main() {
  uv = ivec2(gl_GlobalInvocationID.xy);

  if (ubo.bypassVarianceEstimation) {
    imageStore(gradientTex, uv, vec4(calculateGradient(), 0, 0));
    return;
  }

  normalAtUV   = imageLoad(normalTex, uv).xyz;
  depthAtUV    = imageLoad(depthTex, uv).x;
  gradientAtUV = calculateGradient();

  imageStore(gradientTex, uv, vec4(gradientAtUV, 0, 0));
  imageStore(varianceTex, uv, vec4(calculateVariance(), 0, 0));
}