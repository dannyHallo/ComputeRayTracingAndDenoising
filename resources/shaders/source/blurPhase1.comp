#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// bigger phi indicates bigger tolerence to apply blur
layout(binding = 0) uniform UniformBufferObject {
  bool bypassBluring;
  float sigma;
  float cPhi;
  float nPhi;
  float pPhi;
  int i; // phase 1-5
}
ubo;

layout(binding = 1, rgba8) uniform image2D aTrousTex1;
layout(binding = 2, rgba8) uniform image2D normalTex;
layout(binding = 3, r32f) uniform image2D depthTex;
layout(binding = 4, rgba32f) uniform image2D posTex;
layout(binding = 5, r32f) uniform image2D varTex;
layout(binding = 6, rgba8) uniform image2D blurHTex;

// 56, 180 fps
// 44, 100 fps without separation

#include "include/blurCommon.glsl"

ivec2 uv;
vec2 gradientAtUV;
vec3 positionAtUV, normalAtUV;
vec4 colorAtUV;
float luminanceAtUV, varianceAtUV, depthAtUV, c2Inv;

void blurKernel(int indexX, int indexY, inout float sumOfWeights,
                inout vec4 sumOfWeightedValues) {
  int x = int((indexX - kernalHalfSize) * pow(2, ubo.i));
  int y = int((indexY - kernalHalfSize) * pow(2, ubo.i));

  float weightDistFalloff = weightsATrous[indexX] * weightsATrous[indexY];

  float luminanceAtSample =
      rgbToLuminance(imageLoad(aTrousTex1, uv + ivec2(x, y)));
  float differenceInColorVec = abs(luminanceAtSample - luminanceAtUV);
  float weightC = exp(-differenceInColorVec / (0.8 * sqrt(varianceAtUV) + epsilon));
  // float weightC = exp(-differenceInColorVec / (0.2 * 1 + epsilon));

  // introduce the cosine term to describe normal edge stopping function
  vec3 normalAtSample = imageLoad(normalTex, uv + ivec2(x, y)).xyz;
  float weightN = max(0., pow(dot(normalAtSample, normalAtUV), ubo.nPhi));

  // ---- method SVGF
  float depthAtSample = imageLoad(depthTex, uv + ivec2(x, y)).x;
  float weightZ = exp(-(abs(depthAtUV - depthAtSample) /
                        (1 * abs(dot(gradientAtUV, vec2(x, y))) + epsilon)));
  // ---- end of method SVGF

  // ---- method A-Trous
  //   vec3 positionAtSample = imageLoad(posTex, uv + ivec2(x, y)).xyz;
  //   vec3 differenceInPositionVec = positionAtUV - positionAtSample;
  //   float differenceInPositionFloat2 =
  //       dot(differenceInPositionVec, differenceInPositionVec);
  //   float weightZ = exp(-differenceInPositionFloat2 * p2Inv);
  // ---- end of method A-Trous

  float weight = weightDistFalloff * weightZ * weightN * weightC;

  sumOfWeightedValues +=
      weight * imageLoad(aTrousTex1, uv + ivec2(x, y));
  sumOfWeights += weight;
}

void main() {
  uv = ivec2(gl_GlobalInvocationID.xy);

  colorAtUV = imageLoad(aTrousTex1, uv);
  luminanceAtUV = rgbToLuminance(colorAtUV);
  positionAtUV = imageLoad(posTex, uv).xyz;
  normalAtUV = imageLoad(normalTex, uv).xyz;
  depthAtUV = imageLoad(depthTex, uv).x;
  varianceAtUV = imageLoad(varTex, uv).x;

  float dep4 = imageLoad(depthTex, uv + ivec2(0, 0)).x;
  float dep5 = imageLoad(depthTex, uv + ivec2(1, 0)).x;
  float dep7 = imageLoad(depthTex, uv + ivec2(0, 1)).x;
  gradientAtUV.x = dep5 - dep4;
  gradientAtUV.y = dep7 - dep4;

  if (ubo.bypassBluring) {
    imageStore(blurHTex, uv, colorAtUV);
    // imageStore(blurHTex, uv, vec4(varianceAtUV, varianceAtUV, varianceAtUV, 1));
    return;
  }

  // float sig2Inv = 1 / (2 * ubo.sigma * ubo.sigma + epsilon);
  c2Inv = 1 / (2 * ubo.cPhi * ubo.cPhi + epsilon);
  // float p2Inv = 1 / (2 * ubo.pPhi * ubo.pPhi + epsilon);

  float sumOfWeights = 0;
  vec4 sumOfWeightedValues = vec4(0);
  vec4 weightedColor = vec4(0);

  for (int indexY = 0; indexY < kernelSize; indexY++) {
    for (int indexX = 0; indexX < kernelSize; indexX++) {
      blurKernel(indexX, indexY, sumOfWeights, sumOfWeightedValues);
    }
  }

  weightedColor = sumOfWeightedValues / sumOfWeights;
  imageStore(blurHTex, uv, weightedColor);
}