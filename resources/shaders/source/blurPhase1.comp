#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

#include "include/blurCommon.glsl"

// bigger phi indicates bigger tolerence to apply blur
layout(binding = 0) uniform UniformBufferObject {
  bool bypassBluring;
  float sigma;
  float cPhi;
  float nPhi;
  float pPhi;
  int i; // phase 1-5
}
ubo;

layout(binding = 1, rgba8) uniform image2D aTrousTex1;
layout(binding = 2, rgba8) uniform image2D normalTex;
layout(binding = 3, r32f) uniform image2D depthTex;
layout(binding = 4, rgba32f) uniform image2D posTex;
layout(binding = 5, rgba32f) uniform image2D rayDirTex;
layout(binding = 6, rgba8) uniform image2D blurHTex;

// int kernelSize = int(ceil(2 * 3 * ubo.sigma + 1));
int kernalHalfSize = (kernelSize - 1) / 2;
// 56, 180 fps
// 44, 100 fps without separation

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

  vec4 colorAtUV = imageLoad(aTrousTex1, uv);
  vec3 positionAtUV = imageLoad(posTex, uv).xyz;
  vec3 rayDirAtUV = imageLoad(rayDirTex, uv).xyz;
  vec3 normalAtUV = imageLoad(normalTex, uv).xyz;
  float depthAtUV = imageLoad(depthTex, uv).x;

  vec3 gradientAtUV = cross(cross(normalAtUV, rayDirAtUV), normalAtUV);

  if (ubo.bypassBluring) {
    imageStore(blurHTex, uv, colorAtUV);
    return;
  }

  float sig2Inv = 1 / (2 * ubo.sigma * ubo.sigma + epsilon);
  float c2Inv = 1 / (2 * ubo.cPhi * ubo.cPhi + epsilon);
  float p2Inv = 1 / (2 * ubo.pPhi * ubo.pPhi + epsilon);

  float sumOfWeights = 0;
  vec4 sumOfWeightedValues = vec4(0);
  vec4 weightedColor = vec4(0);

  // for (int index = 0; index < kernelSize; index++) {
  //   int x = int((index - kernalHalfSize) * pow(2, ubo.i));
  //   int y = 0;

  //   // float weightDistFalloff = exp(-x * x * sig2Inv);
  //   float weightDistFalloff = weightsATrous[index];

  //   vec4 colorAtSample = imageLoad(aTrousTex1, ivec2(x + uv.x, y + uv.y));
  //   vec4 differenceInColorVec = colorAtSample - colorAtUV;
  //   float differenceInColorFloat2 =
  //       dot(differenceInColorVec, differenceInColorVec);
  //   float weightDIC = exp(-differenceInColorFloat2 * c2Inv);

  //   vec3 normalAtSample = imageLoad(normalTex, ivec2(x + uv.x, y +
  //   uv.y)).xyz; float weightDIN = max(0., pow(dot(normalAtSample,
  //   normalAtUV), ubo.nPhi));

  //   vec3 positionAtSample = imageLoad(posTex, ivec2(x + uv.x, y + uv.y)).xyz;
  //   vec3 differenceInPositionVec = positionAtSample - positionAtUV;
  //   float differenceInPositionFloat2 =
  //       dot(differenceInPositionVec, differenceInPositionVec);
  //   float weightDIP = exp(-differenceInPositionFloat2 * p2Inv);

  //   float weight = weightDistFalloff * weightDIC * weightDIN * weightDIP;

  //   sumOfWeightedValues +=
  //       weight * imageLoad(aTrousTex1, ivec2(x + uv.x, y + uv.y));
  //   sumOfWeights += weight;
  // }

  for (int indexY = 0; indexY < kernelSize; indexY++) {
    for (int indexX = 0; indexX < kernelSize; indexX++) {
      int x = int((indexX - kernalHalfSize) * pow(2, ubo.i));
      int y = int((indexY - kernalHalfSize) * pow(2, ubo.i));

      // float weightDistFalloff = exp(-x * x * sig2Inv);
      float weightDistFalloff = weightsATrous[indexX] * weightsATrous[indexY];

      vec4 colorAtSample = imageLoad(aTrousTex1, ivec2(x + uv.x, y + uv.y));
      vec4 differenceInColorVec = colorAtSample - colorAtUV;
      float differenceInColorFloat2 =
          dot(differenceInColorVec, differenceInColorVec);
      float weightC = exp(-differenceInColorFloat2 * c2Inv);

      vec3 normalAtSample = imageLoad(normalTex, ivec2(x + uv.x, y + uv.y)).xyz;
      float weightN = max(0., pow(dot(normalAtSample, normalAtUV), ubo.nPhi));

      vec3 positionAtSample = imageLoad(posTex, ivec2(x + uv.x, y + uv.y)).xyz;
      float depthAtSample = imageLoad(depthTex, ivec2(x + uv.x, y + uv.y)).x;
      float weightZ =
          exp(-abs(depthAtUV - depthAtSample) /
              (1 * abs(dot(gradientAtUV, positionAtUV - positionAtSample)) +
               epsilon));

      float weight = weightDistFalloff * weightZ * weightN * weightC;

      sumOfWeightedValues +=
          weight * imageLoad(aTrousTex1, ivec2(x + uv.x, y + uv.y));
      sumOfWeights += weight;
    }
  }

  weightedColor = sumOfWeightedValues / sumOfWeights;
  imageStore(blurHTex, uv, weightedColor);
}