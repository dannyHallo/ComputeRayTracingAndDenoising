#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

#include "../include/svoBuilderDescriptorSetLayouts.glsl"

#include "../include/core/inoise.glsl"
#include "../include/core/packer.glsl"

#include "../include/blockType.glsl"

vec4 computeNoise(vec3 p) {
  float total       = 0.0;
  float amplitude   = 0.6;
  float frequency   = 2.0;
  float persistence = 0.3;
  float lacunarity  = 2.0;
  int octaves       = 4;

  vec3 gradient = vec3(0.0);
  for (int i = 0; i < octaves; i++) {
    vec4 noise = noised(p * frequency);
    total += amplitude * noise.x;
    gradient += amplitude * frequency * noise.yzw;
    amplitude *= persistence;
    frequency *= lacunarity;
  }

  return vec4(total, gradient);
}

// takes 21 bits
uint compressNormal(vec3 normal) {
  // scale and bias from [-1, 1] to [0, 127]
  uvec3 quantized = uvec3(((normal + 1.0) * 0.5) * 127.0);

  // pack the 7-bit components into a single uint
  uint packed = (quantized.r) | (quantized.g << 7) | (quantized.b << 14);

  return packed;
}

void main() {
  ivec3 uvi = ivec3(gl_GlobalInvocationID);
  if (any(greaterThanEqual(uvi, ivec3(fragmentListInfoBuffer.data.voxelResolution + 2)))) {
    return;
  }
  vec3 localVoxelPos  = (vec3(uvi) - 0.5) / float(fragmentListInfoBuffer.data.voxelResolution);
  vec3 chunkPos       = vec3(chunksInfoBuffer.data.currentlyWritingChunk);
  vec3 globalVoxelPos = chunkPos + localVoxelPos;

  // x: noise val, yzw: gradient
  // this step takes ~80% of the time for the entire chunk generation
  vec4 noise = computeNoise(globalVoxelPos);

  float weight = noise.x - (globalVoxelPos.y - 0.5);

  // noise gradient + heightDropoff gradient
  vec3 gradient         = noise.yzw - vec3(0, 1, 0);
  uint compressedNormal = compressNormal(normalize(-gradient));

  uint blockType = getBlockTypeFromWeight(weight);
  // imageStore(chunkFieldImage, uvi, uvec4(blockType, compressedNormal, 0, 0));
  if (blockType == kBlockTypeEmpty) {
    return;
  }

  ivec3 p = ivec3(gl_GlobalInvocationID) - ivec3(1);
  if (any(lessThan(p, ivec3(0))) ||
      any(greaterThanEqual(p, ivec3(fragmentListInfoBuffer.data.voxelResolution)))) {
    return;
  }
  uvec3 boundedCoord = uvec3(p);

  ///

  uint fragmentListCur = atomicAdd(fragmentListInfoBuffer.data.voxelFragmentCount, 1);

  // position
  G_FragmentListEntry ufragment;
  uint coordinatesData = 0;
  coordinatesData |= boundedCoord.x;
  coordinatesData |= boundedCoord.y << 10;
  coordinatesData |= boundedCoord.z << 20;
  ufragment.coordinates = coordinatesData;

  // color and normal
  uint propertiesData = 0;
  propertiesData |= 0;
  propertiesData |= compressedNormal << 8;
  ufragment.properties = propertiesData;

  fragmentListBuffer.datas[fragmentListCur] = ufragment;
}
