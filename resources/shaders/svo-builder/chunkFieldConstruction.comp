#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

#include "../include/svoBuilderDescriptorSetLayouts.glsl"

#include "../include/core/cnoise.glsl"
#include "../include/core/inoise.glsl"

#include "../include/blockTypes.glsl"

vec4 computeNoise(vec3 p) {
  float total       = 0.0;
  float amplitude   = 0.6;
  float frequency   = 2.0;
  float persistence = 0.3;
  float lacunarity  = 2.0;
  int octaves       = 4;

  vec3 gradient = vec3(0.0);
  for (int i = 0; i < octaves; i++) {
    vec4 noise = noised(p * frequency);
    total += amplitude * noise.x;
    gradient += amplitude * frequency * noise.yzw;
    amplitude *= persistence;
    frequency *= lacunarity;
  }

  return vec4(total, gradient);
}

void main() {
  ivec3 uvi = ivec3(gl_GlobalInvocationID);
  if (any(greaterThanEqual(uvi, ivec3(fragmentListInfoBuffer.data.voxelResolution + 1)))) {
    return;
  }
  const vec3 localVoxelPos = (vec3(uvi) - 0.5) / float(fragmentListInfoBuffer.data.voxelResolution);
  const vec3 chunkPos      = vec3(chunksInfoBuffer.data.currentlyWritingChunk);
  const vec3 globalVoxelPos = chunkPos + localVoxelPos;

  // x: noise val, yzw: gradient
  // this step takes ~80% of the time for the entire chunk generation
  float noise = computeNoise(globalVoxelPos).x;

  float weight = noise.x - (globalVoxelPos.y - 0.5);

  uint blockType = getBlockTypeFromWeight(weight);
  uint packed    = packBlockTypeAndWeight(blockType, weight);

  imageStore(chunkFieldImage, uvi, uvec4(packed, 0, 0, 0));
}
