#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

#include "../include/svoBuilderDescriptorSetLayouts.glsl"

#include "../include/core/inoise.glsl"
#include "../include/core/packer.glsl"

#include "../include/blockType.glsl"

vec4 computeNoise(vec3 p) {
  float total       = 0.0;
  float amplitude   = 0.6;
  float frequency   = 2.0;
  float persistence = 0.3;
  float lacunarity  = 2.0;
  int octaves       = 4;

  vec3 gradient = vec3(0.0);
  for (int i = 0; i < octaves; i++) {
    vec4 noise = noised(p * frequency);
    total += amplitude * noise.x;
    gradient += amplitude * frequency * noise.yzw;
    amplitude *= persistence;
    frequency *= lacunarity;
  }

  return vec4(total, gradient);
}

void main() {
  ivec3 uvi = ivec3(gl_GlobalInvocationID);
  if (any(greaterThanEqual(uvi, ivec3(fragmentListInfoBuffer.data.voxelResolution + 2)))) {
    return;
  }
  vec3 localVoxelPos  = (vec3(uvi) - 0.5) / float(fragmentListInfoBuffer.data.voxelResolution);
  vec3 chunkPos       = vec3(chunksInfoBuffer.data.currentlyWritingChunk);
  vec3 globalVoxelPos = chunkPos + localVoxelPos;

  // x: noise val, yzw: gradient
  // this step takes ~80% of the time for the entire chunk generation
  vec4 noise = computeNoise(globalVoxelPos);

  float weight = noise.x - (globalVoxelPos.y - 0.5);

  // noise gradient + heightDropoff gradient
  vec3 gradient     = noise.yzw - vec3(0, 1, 0);
  uint packedNormal = packNormal21Bits(normalize(-gradient));

  uint blockType = getBlockTypeFromWeight(weight);
  imageStore(chunkFieldImage, uvi, uvec4(blockType << 21 | packedNormal, 0, 0, 0));
}
