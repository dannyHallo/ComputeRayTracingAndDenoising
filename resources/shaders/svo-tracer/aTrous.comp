#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "../include/svoTracerDescriptorSetLayouts.glsl"

#include "../include/definitions.glsl"
#include "../include/packer.glsl"
#include "../include/random.glsl"

// standard 3x3 filtering kernel from q2rtx
const float waveletFac      = 0.5;
const float kernel3x3[2][2] = {{1.0, waveletFac}, {waveletFac, waveletFac *waveletFac}};

float luminanceAtUv;
float depthAtUv;

ivec2 jittering(int stepSize) {
  uvec3 seed       = uvec3(gl_GlobalInvocationID.xy, renderInfoUbo.data.currentSample);
  vec2 randomNoise = vec2(random(seed), random(seed));
  randomNoise -= 0.5;
  randomNoise *= 0.5;
  ivec2 jitter = ivec2(randomNoise * stepSize);
  return jitter;
}

void loadDataFromPing(out vec3 oNormal, out vec3 oColor, out vec3 oPosition, ivec2 uv) {
  ivec2 bound = ivec2(renderInfoUbo.data.lowResSize);
  // padding
  if (any(lessThan(uv, ivec2(0))) || any(greaterThanEqual(uv, bound))) {
    uv = clamp(uv, ivec2(0), bound - ivec2(1));
  }

  oNormal   = unpackNormal(imageLoad(normalImage, uv).x);
  oColor    = unpackRGBE(imageLoad(aTrousPingImage, uv).x);
  oPosition = imageLoad(positionImage, uv).xyz;
  // oVariance = imageLoad(varianceImage, uv).x;
}

void loadDataFromPong(out vec3 oNormal, out vec3 oColor, out vec3 oPosition, ivec2 uv) {
  ivec2 bound = ivec2(renderInfoUbo.data.lowResSize);
  if (any(lessThan(uv, ivec2(0))) || any(greaterThanEqual(uv, bound))) {
    uv = clamp(uv, ivec2(0), bound - ivec2(1));
  }

  oNormal   = unpackNormal(imageLoad(normalImage, uv).x);
  oColor    = unpackRGBE(imageLoad(aTrousPongImage, uv).x);
  oPosition = imageLoad(positionImage, uv).xyz;
  // oVariance = imageLoad(varianceImage, uv).x;
}

void blurKernel(inout float weightSum, inout vec3 sumOfWeightedColors, ivec2 uv, ivec2 dispatchXY,
                int kernalHalfSize, uint currentIteration, vec3 normalAtUv, vec3 colorAtUv,
                vec3 positionAtUv, float luminanceAtUv, float depthAtUv) {
  int stepSize   = 1 << currentIteration;
  ivec2 offsetXY = dispatchXY * stepSize;

  // jittering is heavy and no longer applied here to avoid divergence withing the same warp

  float weightK = kernel3x3[abs(dispatchXY.x)][abs(dispatchXY.y)];

  if (dispatchXY == ivec2(0)) {
    float weight = weightK;
    weight       = clamp(weight, 0, 1);
    weightSum += weight;
    sumOfWeightedColors += weight * colorAtUv;
    return;
  }

  // since we give a offset here, we need to check if the hit is valid again
  if (imageLoad(hitImage, uv + offsetXY).x == 0) {
    return;
  }

  vec3 normalAtSample;
  vec3 colorAtSample;
  vec3 positionAtSample;
  // float varianceAtSample;

  if (currentIteration % 2 == 0) {
    loadDataFromPing(normalAtSample, colorAtSample, positionAtSample, uv + offsetXY);
  } else {
    loadDataFromPong(normalAtSample, colorAtSample, positionAtSample, uv + offsetXY);
  }

  // WEIGHT_C
  float phiC = spatialFilterInfoUbo.data.phiC;
  if (spatialFilterInfoUbo.data.changingLuminancePhi) {
    phiC *= pow(2, -currentIteration);
  }

  float luminanceAtSample = dot(kRgbToLuminanceMat, colorAtSample);
  float colDiff           = abs(luminanceAtSample - luminanceAtUv);
  // if (spatialFilterInfoUbo.data.useVarianceGuidedFiltering != 0) {
  //   phiC *= 100.;
  //   weightC = exp(-colDiff / max(phiC * sqrt(varianceAtUv), kEpsilon));
  // } else {
  float weightC = exp(-colDiff / phiC);
  // }
  if (spatialFilterInfoUbo.data.ignoreLuminanceAtFirstIteration && currentIteration == 0) {
    weightC = 1.0;
  }

  // WEIGHT_N
  float weightN = max(0., pow(dot(normalAtUv, normalAtSample), spatialFilterInfoUbo.data.phiN));

  // WEIGHT_P
  float weightP = exp(-distance(positionAtSample, positionAtUv) / spatialFilterInfoUbo.data.phiP);

  // WEIGHT_Z
  float weightZ       = 1.0;
  float depthFalloff  = exp(-depthAtUv);
  float depthThrehold = spatialFilterInfoUbo.data.phiZ;
  // depth is bigger than the threshold
  if (depthFalloff < depthThrehold) {
    weightZ = 1.0;
  } else {
    bool sameVoxHash = imageLoad(voxHashImage, uv).x == imageLoad(voxHashImage, uv + offsetXY).x;
    weightZ          = sameVoxHash ? 1.0 : 0.0;
  }

  float weight = weightK * weightC * weightN * weightP * weightZ;

  weightSum += weight;
  sumOfWeightedColors += weight * colorAtSample;
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (any(greaterThanEqual(uv, ivec2(renderInfoUbo.data.lowResSize)))) {
    return;
  }

  if (imageLoad(hitImage, uv).x == 0) {
    return;
  }

  uint currentIteration = aTrousIterationBuffer.data;
  if (currentIteration >= spatialFilterInfoUbo.data.aTrousIterationCount) {
    // no A-Trous at all: just copy input to the output at the first iteration
    if (currentIteration == 0) {
      vec3 color       = unpackRGBE(imageLoad(aTrousPingImage, uv).x);
      uint packedColor = packRGBE(color);
      imageStore(aTrousFinalResultImage, uv, uvec4(packedColor, 0, 0, 0));
      imageStore(accumedImage, uv, uvec4(packedColor, 0, 0, 0));
    }
    return;
  }

  // if (spatialFilterInfoUbo.data.bypassBluring || aTrousIterationsInfo.data >=
  // aTrousIterationsInfo.dataCap) {
  //   if (aTrousIterationsInfo.data == 0) {
  //     imageStore(accumTex, uv, vec4(colorAtUv, 1));
  //   }
  //   imageStore(aTrousOutputTex, uv, vec4(colorAtUv, 1));
  //   return;
  // }

  vec3 normalAtUv, colorAtUv, positionAtUv;
  if (currentIteration % 2 == 0) {
    loadDataFromPing(normalAtUv, colorAtUv, positionAtUv, uv);
  } else {
    loadDataFromPong(normalAtUv, colorAtUv, positionAtUv, uv);
  }

  luminanceAtUv = dot(kRgbToLuminanceMat, colorAtUv);
  depthAtUv     = imageLoad(depthImage, uv).x;

  const int kernalHalfSize = 1;
  float weightSum          = 0;
  vec3 sumOfWeightedColors = vec3(0);
  for (int indexX = -kernalHalfSize; indexX <= kernalHalfSize; indexX++) {
    for (int indexY = -kernalHalfSize; indexY <= kernalHalfSize; indexY++) {
      blurKernel(weightSum, sumOfWeightedColors, uv, ivec2(indexX, indexY), kernalHalfSize,
                 currentIteration, normalAtUv, colorAtUv, positionAtUv, luminanceAtUv, depthAtUv);
    }
  }
  vec3 weightedColor = sumOfWeightedColors / weightSum;

  uint packedWeightedColor = packRGBE(weightedColor);
  // send to accum buffer for the first iteration
  if (currentIteration == 0) {
    imageStore(accumedImage, uv, uvec4(packedWeightedColor, 0, 0, 0));
  }

  // dump image if in the last iteration
  if (currentIteration == spatialFilterInfoUbo.data.aTrousIterationCount - 1) {
    imageStore(aTrousFinalResultImage, uv, uvec4(packedWeightedColor, 0, 0, 0));
    return;
  }

  // send to pingpong buffer
  if (currentIteration % 2 == 0) {
    imageStore(aTrousPongImage, uv, uvec4(packedWeightedColor, 0, 0, 0));
  } else {
    imageStore(aTrousPingImage, uv, uvec4(packedWeightedColor, 0, 0, 0));
  }
}