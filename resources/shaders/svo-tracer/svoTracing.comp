#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "../include/svoTracerDescriptorSetLayouts.glsl"

#include "../include/cascadedMarching.glsl"
#include "../include/core/definitions.glsl"
#include "../include/core/packer.glsl"
#include "../include/projection.glsl"
#include "../include/random.glsl"
// #include "../include/seascape.glsl"
#include "../include/skyColor.glsl"

///

#ifndef SEASCAPE_GLSL
#define SEASCAPE_GLSL

/*
 * taken from: https://www.shadertoy.com/view/Ms2SD1 for the _noise functions
 * taken from: https://www.shadertoy.com/view/MdXyzX for the marching functions
 * "Seascape" by Alexander Alekseev aka TDM - 2014
 * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
 * Contact: tdmaav@gmail.com
 */

#include "../include/svoTracerDescriptorSetLayouts.glsl"

// #include "../include/core/cnoise.glsl"
#include "../include/core/definitions.glsl"
#include "../include/core/hash.glsl"
#include "../include/skyColor.glsl"

const int NUM_STEPS = 8;
const float EPSILON = 1e-3;

const float kWaterTopHeight    = 0.22;
const float kWaterBottomHeight = -0.0;

const int ITER_RAYMARCH    = 3;
const int ITER_NORMAL      = 5;
const float SEA_CHOPPY     = 4.0;
const float SEA_SPEED      = 1.0;
const float SEA_FREQ       = 0.16;
const vec3 SEA_BASE        = vec3(0.0, 0.09, 0.18);
const vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6) * 0.6;
#define SEA_TIME (1.0 + renderInfoUbo.data.time * SEA_SPEED)
const mat2 octave_m = mat2(1.6, 1.2, -1.2, 1.6);

// -1.0 - 1.0
float _noise(in vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  vec2 u = f * f * (3.0 - 2.0 * f);
  return 2.0 * mix(mix(hash12(i + vec2(0.0, 0.0)), hash12(i + vec2(1.0, 0.0)), u.x),
                   mix(hash12(i + vec2(0.0, 1.0)), hash12(i + vec2(1.0, 1.0)), u.x), u.y) -
         1.0;
}

float _seaOctave(vec2 uv, float choppy) {
  uv += _noise(uv);
  vec2 wv  = 1.0 - abs(sin(uv));
  vec2 swv = abs(cos(uv));
  wv       = mix(wv, swv, wv);
  return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);
}

// 0.0 - 1.0
float _getWaveHeight01(vec2 p, uint iterationCount) {
  float freq   = SEA_FREQ;
  float amp    = 1.0;
  float choppy = SEA_CHOPPY;
  vec2 uv      = p;
  uv.x *= 0.75;

  float d, h = 0.0;
  float sumOfAmp = 0.0;
  for (uint i = 0; i < iterationCount; i++) {
    // 0.0 - 1.0
    d = _seaOctave((uv + SEA_TIME) * freq, choppy);
    d += _seaOctave((uv - SEA_TIME) * freq, choppy);
    d /= 2.0;
    sumOfAmp += amp;
    h += d * amp;
    uv *= octave_m;
    freq *= 1.9;
    amp *= 0.22;
    choppy = mix(choppy, 1.0, 0.2);
  }
  h /= sumOfAmp;
  return h;
}

// ray-plane intersection checker
float _intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal) {
  return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0);
}

// assertion: water must be hit before calling this function
// raymarches the ray from top water layer boundary to low water layer boundary
float _raymarchWater(vec3 o, vec3 d) {
  // calculate intersections and reconstruct positions
  float tHighPlane = _intersectPlane(o, d, vec3(0.0, kWaterTopHeight, 0.0), vec3(0.0, 1.0, 0.0));
  float tLowPlane  = _intersectPlane(o, d, vec3(0.0, kWaterBottomHeight, 0.0), vec3(0.0, 1.0, 0.0));
  vec3 start       = o + tHighPlane * d; // high hit position
  vec3 end         = o + tLowPlane * d;  // low hit position

  float t  = tHighPlane;
  vec3 pos = start;

  for (int i = 0; i < 64; i++) {
    float h = mix(kWaterBottomHeight, kWaterTopHeight, _getWaveHeight01(pos.xz, ITER_RAYMARCH));

    // proximity hit check, uncomment this for better perf?
    // if (h + 1e-2 * dist_pos > pos.y) {
    if (pos.y < h + 1e-2) {
      return t;
    }
    t += pos.y - h;
    // iterate forwards according to the height mismatch
    pos = o + t * d;
  }
  // if hit was not registered, just assume hit the top layer,
  // this makes the raymarching faster and looks better at higher distances
  return tHighPlane;
}

// calculate normal at point by calculating the height at the pos and 2 additional points very
// close to pos
vec3 normal(vec2 pos, float e) {
  vec2 ex     = vec2(e, 0);
  float depth = kWaterTopHeight - kWaterBottomHeight;
  float h     = _getWaveHeight01(pos, ITER_NORMAL) * depth;
  vec3 a      = vec3(pos.x, h, pos.y);
  return normalize(
      cross(a - vec3(pos.x - e, _getWaveHeight01(pos - ex.xy, ITER_NORMAL) * depth, pos.y),
            a - vec3(pos.x, _getWaveHeight01(pos + ex.yx, ITER_NORMAL) * depth, pos.y + e)));
}

bool traceSeascape(out vec3 oColor, out vec3 oPosition, out float oT, vec3 o, vec3 d) {
  oColor    = vec3(0.0);
  oT        = 1e10;
  oPosition = o + d * oT;

  if (d.y >= 0.0) {
    return false;
  }

  // raymatch water and reconstruct the hit pos
  float dist       = _raymarchWater(o, d);
  vec3 waterHitPos = o + d * dist;

  // calculate normal at the hit position
  vec3 N = normal(waterHitPos.xz, 0.01);

  // smooth the normal with distance to avoid disturbing high frequency _noise
  N = mix(N, vec3(0.0, 1.0, 0.0), 0.8 * min(1.0, sqrt(dist * 0.01) * 1.1));

  // calculate fresnel coefficient
  float fresnel = (0.04 + (1.0 - 0.04) * (pow(1.0 - max(0.0, dot(-N, d)), 5.0)));

  // reflect the ray and make sure it bounces up
  vec3 R = normalize(reflect(d, N));
  R.y    = abs(R.y);

  // calculate the reflection and approximate subsurface scattering
  vec3 reflection = skyColor(R, true);
  float depth     = kWaterTopHeight - kWaterBottomHeight;
  vec3 scattering = vec3(0.0293, 0.0698, 0.1717) * 0.1 * (0.2 + (waterHitPos.y + depth) / depth);

  // return the combined result
  oColor    = fresnel * reflection + scattering;
  oT        = dist;
  oPosition = waterHitPos;

  // oColor = vec3(pow(oPosition.y + 1.0, 200.0));
  return true;
}

#endif // SEASCAPE_GLSL

///

// subpixOffset ranges from -0.5 to 0.5
void rayGen(out vec3 o, out vec3 d, vec2 subpixOffset) {
  vec2 screenSpaceUv = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5) + subpixOffset) /
                       vec2(renderInfoUbo.data.lowResSize);
  o = renderInfoUbo.data.camPosition;
  d = normalize(projectScreenUvToWorldCamFarPoint(screenSpaceUv, false) -
                renderInfoUbo.data.camPosition);
}

uvec3 getSeed() {
  return uvec3(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, renderInfoUbo.data.currentSample);
}

vec3 getShadowRayColor(vec3 o, vec3 d) {
  MarchingResult shadowRayResult;
  bool shadowRayHit = cascadedMarching(shadowRayResult, o, d);
  if (shadowRayHit) {
    return vec3(0.0);
  }
  return 1000 * skyColor(d, true);
}

vec3 getIndirectRayColor(vec3 o, vec3 d, uvec3 seed, vec3 shadowRayDirReuse) {
  MarchingResult indirectRayResult;

  bool indirectRayHit = cascadedMarching(indirectRayResult, o, d);
  if (!indirectRayHit) {
    // exclude the sun light here!
    return skyColor(d, false);
  }

  // reuse the shadow ray dir for better performance
  vec3 shadowRay2Color = vec3(0.0);
  if (dot(shadowRayDirReuse, indirectRayResult.normal) >= 0.0) {
    shadowRay2Color = getShadowRayColor(indirectRayResult.nextTracingPosition, shadowRayDirReuse);
    vec3 brdf       = indirectRayResult.color * kInvPi;
    const float shadowRayPdf = 1.0 / (0.0001 * kPi);
    shadowRay2Color *= brdf * dot(shadowRayDirReuse, indirectRayResult.normal) / shadowRayPdf;
  }

  return shadowRay2Color;
}

// most of the return value is only valid if hit, except for oPrimaryRayIterUsed
bool getPrimaryRayColor(out float oT, out uint oPrimaryRayIterUsed,
                        out uint oPrimaryRayChunkTraversed, out vec3 oColor, out vec3 oPosition,
                        out vec3 oNormal, out uint oVoxHash, uvec3 seed, vec3 o, vec3 d,
                        float optimizedDistance) {
  MarchingResult primaryRayResult;
  bool primaryRayHit = cascadedMarching(primaryRayResult, o + d * optimizedDistance, d);

  oT                        = primaryRayResult.t;
  oPrimaryRayIterUsed       = primaryRayResult.iter;
  oPrimaryRayChunkTraversed = primaryRayResult.chunkTraversed;
  oColor                    = primaryRayResult.color;
  oPosition                 = primaryRayResult.position;
  oNormal                   = primaryRayResult.normal;
  oVoxHash                  = primaryRayResult.voxHash;

  oT += optimizedDistance;

  vec3 seaColor, seaHitPos;
  float seaT;
  bool hitSea = traceSeascape(seaColor, seaHitPos, seaT, o, d);
  if (hitSea && seaT < oT) {
    oColor = seaColor;
    // oPosition = pos;
    // oT        = t;
    return false;
  }

  if (!primaryRayHit) {
    oColor = skyColor(d, true);
    return false;
  }

  // uncomment to: show normal
  // return true;

  vec3 brdf = primaryRayResult.color * kInvPi;

  // direct contribution
  vec3 shadowRayDir   = getRandomShadowRay(makeDisturbedSeed(seed, 1));
  vec3 shadowRayColor = vec3(0.0);
  if (dot(shadowRayDir, primaryRayResult.normal) >= 0.0) {
    shadowRayColor = getShadowRayColor(primaryRayResult.nextTracingPosition, shadowRayDir);
    const float shadowRayPdf = 1.0 / (0.0001 * kPi);
    shadowRayColor *= brdf * dot(shadowRayDir, primaryRayResult.normal) / shadowRayPdf;
  }

  if (tweakableParametersUbo.data.traceIndirectRay == 0u) {
    oColor = shadowRayColor;
    return true;
  }

  // indirect contribution
  vec3 indirectRayDir =
      randomCosineWeightedHemispherePoint(primaryRayResult.normal, makeDisturbedSeed(seed, 2));
  vec3 indirectRayColor =
      getIndirectRayColor(primaryRayResult.nextTracingPosition, indirectRayDir, seed, shadowRayDir);

  float indirectRayPdf = dot(indirectRayDir, primaryRayResult.normal) / kPi;
  indirectRayColor *= brdf * dot(indirectRayDir, primaryRayResult.normal) / indirectRayPdf;

  oColor = shadowRayColor + indirectRayColor;
  return true;
}

void writeOutputBuffer(ivec2 uvi, bool hitVoxel, vec3 position) {
  // if uvi is not the center pixel, we don't write the output buffer
  if (uvi != ivec2(renderInfoUbo.data.lowResSize) / 2) {
    return;
  }
  outputInfoBuffer.data.midRayHit    = uint(hitVoxel);
  outputInfoBuffer.data.midRayHitPos = position;
}

void main() {
  ivec2 uvi = ivec2(gl_GlobalInvocationID.xy);
  if (any(greaterThanEqual(uvi, ivec2(renderInfoUbo.data.lowResSize)))) {
    return;
  }

  uvec3 seed = getSeed();

  vec3 o, d;
  // (-0.5, 0.5)
  vec2 subpixOffset =
      bool(tweakableParametersUbo.data.taa) ? renderInfoUbo.data.subpixOffset : vec2(0);
  rayGen(o, d, subpixOffset);

  float optimizedDistance = 0;

  // beam optimization
  if (bool(tweakableParametersUbo.data.beamOptimization)) {
    ivec2 beamUv      = ivec2(gl_GlobalInvocationID.xy / sceneInfoBuffer.data.beamResolution);
    float t1          = imageLoad(beamDepthImage, beamUv).r;
    float t2          = imageLoad(beamDepthImage, beamUv + ivec2(1, 0)).r;
    float t3          = imageLoad(beamDepthImage, beamUv + ivec2(0, 1)).r;
    float t4          = imageLoad(beamDepthImage, beamUv + ivec2(1, 1)).r;
    float t           = min(min(t1, t2), min(t3, t4));
    optimizedDistance = t;
  }

  uint voxHash;
  uint primaryRayIterUsed;
  uint primaryRayChunkTraversed;
  vec3 normal, position, color;
  float tMin;
  bool hitVoxel = getPrimaryRayColor(tMin, primaryRayIterUsed, primaryRayChunkTraversed, color,
                                     position, normal, voxHash, seed, o, d, optimizedDistance);

  if (hitVoxel) {
    imageStore(positionImage, uvi, vec4(position, 0.0));
    imageStore(normalImage, uvi, uvec4(packNormal(normal), 0, 0, 0));
    imageStore(voxHashImage, uvi, uvec4(voxHash, 0, 0, 0));
  }
  imageStore(depthImage, uvi, vec4(tMin, 0.0, 0.0, 0.0));

  // calculate the motion here avoids a store - load cycle for the position, and the motion
  // vector can be reused in temporal filter and the taa filter, also, using a motion vector is
  // easier for us to handle moving objects in the future
  vec2 pUv01 = projectWorldPosToScreenUv(position, true);
  vec2 uv01  = projectWorldPosToScreenUv(position, false);
  // the motion vector points to the previous frame, and is normalized
  vec2 motion = pUv01 - uv01;

  imageStore(hitImage, uvi, uvec4(hitVoxel ? 1 : 0, 0, 0, 0));
  imageStore(motionImage, uvi, vec4(motion, 0, 0));

  uint packedColor = packRgbe(color);
  if (hitVoxel) {
    imageStore(rawImage, uvi, uvec4(packedColor, 0, 0, 0));
  } else {
    imageStore(backgroundImage, uvi, uvec4(packedColor, 0, 0, 0));
  }

  const vec3 iterUsedColor       = vec3(1, 0.4, 0.2) * 0.02 * float(primaryRayIterUsed);
  const vec3 chunkTraversedColor = vec3(0.2, 0.4, 1) * 0.2 * float(primaryRayChunkTraversed);

  vec3 overlappingColor = vec3(0);
  if (bool(tweakableParametersUbo.data.visualizeOctree)) {
    overlappingColor += iterUsedColor;
  }
  if (bool(tweakableParametersUbo.data.visualizeChunks)) {
    overlappingColor += chunkTraversedColor;
  }

  imageStore(octreeVisualizationImage, uvi, vec4(overlappingColor, 0));

  writeOutputBuffer(uvi, hitVoxel, position);
}
