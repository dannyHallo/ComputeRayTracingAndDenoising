#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "../include/svoTracerDescriptorSetLayouts.glsl"

#include "../include/cascadedMarching.glsl"
#include "../include/core/definitions.glsl"
#include "../include/core/packer.glsl"
#include "../include/projection.glsl"
#include "../include/random.glsl"
// #include "../include/seascape.glsl"
#include "../include/skyColor.glsl"

///

#ifndef SEASCAPE_GLSL
#define SEASCAPE_GLSL

/*
 * taken from: https://www.shadertoy.com/view/Ms2SD1
 * "Seascape" by Alexander Alekseev aka TDM - 2014
 * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
 * Contact: tdmaav@gmail.com
 */

#include "../include/svoTracerDescriptorSetLayouts.glsl"

// #include "../include/core/cnoise.glsl"
#include "../include/core/definitions.glsl"
#include "../include/core/hash.glsl"
#include "../include/skyColor.glsl"

const int NUM_STEPS = 8;
const float EPSILON = 1e-3;

const int ITER_GEOMETRY    = 3;
const int ITER_FRAGMENT    = 5;
const float SEA_HEIGHT     = 0.6;
const float SEA_CHOPPY     = 4.0;
const float SEA_SPEED      = 1.0;
const float SEA_FREQ       = 0.16;
const vec3 SEA_BASE        = vec3(0.0, 0.09, 0.18);
const vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6) * 0.6;
#define SEA_TIME (1.0 + renderInfoUbo.data.time * SEA_SPEED)
const mat2 octave_m = mat2(1.6, 1.2, -1.2, 1.6);

// math
mat3 fromEuler(vec3 ang) {
  vec2 a1 = vec2(sin(ang.x), cos(ang.x));
  vec2 a2 = vec2(sin(ang.y), cos(ang.y));
  vec2 a3 = vec2(sin(ang.z), cos(ang.z));
  mat3 m;
  m[0] = vec3(a1.y * a3.y + a1.x * a2.x * a3.x, a1.y * a2.x * a3.x + a3.y * a1.x, -a2.y * a3.x);
  m[1] = vec3(-a2.y * a1.x, a1.y * a2.y, a2.x);
  m[2] = vec3(a3.y * a1.x * a2.x + a1.y * a3.x, a1.x * a3.x - a1.y * a3.y * a2.x, a2.y * a3.y);
  return m;
}

// the hash function from shadertoy has been repleaced by murmurHash

// -1.0 - 1.0
float noise(in vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  vec2 u = f * f * (3.0 - 2.0 * f);
  return 2.0 * mix(mix(hash12(i + vec2(0.0, 0.0)), hash12(i + vec2(1.0, 0.0)), u.x),
                   mix(hash12(i + vec2(0.0, 1.0)), hash12(i + vec2(1.0, 1.0)), u.x), u.y) -
         1.0;
}

// lighting
float diffuse(vec3 n, vec3 l, float p) { return pow(dot(n, l) * 0.4 + 0.6, p); }
float specular(vec3 n, vec3 l, vec3 e, float s) {
  float nrm = (s + 8.0) / (kPi * 8.0);
  return pow(max(dot(reflect(e, n), l), 0.0), s) * nrm;
}

// sea
float sea_octave(vec2 uv, float choppy) {
  uv += noise(uv);
  vec2 wv  = 1.0 - abs(sin(uv));
  vec2 swv = abs(cos(uv));
  wv       = mix(wv, swv, wv);
  return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);
}

float map(vec3 p, uint iterationCount) {
  float freq   = SEA_FREQ;
  float amp    = SEA_HEIGHT;
  float choppy = SEA_CHOPPY;
  vec2 uv      = p.xz;
  uv.x *= 0.75;

  float d, h = 0.0;
  float sumOfAmp = 0.0;
  for (uint i = 0; i < iterationCount; i++) {
    // 0.0 - 1.0
    d = sea_octave((uv + SEA_TIME) * freq, choppy);
    d += sea_octave((uv - SEA_TIME) * freq, choppy);
    sumOfAmp += amp;
    h += d * amp;
    uv *= octave_m;
    freq *= 1.9;
    amp *= 0.22;
    choppy = mix(choppy, 1.0, 0.2);
  }
  h /= sumOfAmp;
  return p.y - h;
  // return h;
}

vec3 getSeaColor(vec3 p, vec3 n, vec3 eye, float t) {
  vec3 l    = environmentUbo.data.sunDir;
  vec3 dist = p + t * eye;

  float fresnel = clamp(1.0 - dot(n, -eye), 0.0, 1.0);
  fresnel       = min(pow(fresnel, 3.0), 0.5);

  vec3 reflected = skyColor(reflect(eye, n), true);
  vec3 refracted = SEA_BASE + diffuse(n, l, 80.0) * SEA_WATER_COLOR * 0.12;

  vec3 color = mix(refracted, reflected, fresnel);

  float atten = max(1.0 - dot(dist, dist) * 0.001, 0.0);
  color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;

  color += vec3(specular(n, l, eye, 60.0));

  return color;
}

vec3 _getNormal(vec3 p, float eps) {
  vec3 n;
  n.y = map(p, ITER_FRAGMENT);
  n.x = map(vec3(p.x + eps, p.y, p.z), ITER_FRAGMENT) - n.y;
  n.z = map(vec3(p.x, p.y, p.z + eps), ITER_FRAGMENT) - n.y;
  n.y = eps;
  return normalize(n);
}

bool _heightMapTracing(out float oT, vec3 o, vec3 d) {
  float tm = 0.0;
  float tx = 1000.0;
  float hx = map(o + d * tx, ITER_GEOMETRY);
  if (hx > 0.0) {
    oT = tx;
    return false;
  }
  float hm   = map(o + d * tm, ITER_GEOMETRY);
  float tmid = 0.0;
  for (int i = 0; i < NUM_STEPS; i++) {
    tmid       = mix(tm, tx, hm / (hm - hx));
    float hmid = map(o + d * tmid, ITER_GEOMETRY);
    if (hmid < 0.0) {
      tx = tmid;
      hx = hmid;
    } else {
      tm = tmid;
      hm = hmid;
    }
  }
  oT = tmid;
  return true;
}

// #define EPSILON_NRM (0.1 / iResolution.x)
#define EPSILON_NRM 1e-4

bool traceSeascape(out vec3 oColor, out vec3 oPosition, out float oT, vec3 o, vec3 d) {
  oColor = vec3(0.0);

  bool hitSea = _heightMapTracing(oT, o, d);
  if (!hitSea) {
    return false;
  }

  oPosition = o + oT * d;
  vec3 n    = _getNormal(oPosition, dot(oT, oT) * EPSILON_NRM);

  oColor = getSeaColor(oPosition, n, d, oT);
  return true;
}

#endif // SEASCAPE_GLSL

///

// subpixOffset ranges from -0.5 to 0.5
void rayGen(out vec3 o, out vec3 d, vec2 subpixOffset) {
  vec2 screenSpaceUv = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5) + subpixOffset) /
                       vec2(renderInfoUbo.data.lowResSize);
  o = renderInfoUbo.data.camPosition;
  d = normalize(projectScreenUvToWorldCamFarPoint(screenSpaceUv, false) -
                renderInfoUbo.data.camPosition);
}

uvec3 getSeed() {
  return uvec3(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, renderInfoUbo.data.currentSample);
}

vec3 getShadowRayColor(vec3 o, vec3 d) {
  MarchingResult shadowRayResult;
  bool shadowRayHit = cascadedMarching(shadowRayResult, o, d);
  if (shadowRayHit) {
    return vec3(0.0);
  }
  return 1000 * skyColor(d, true);
}

vec3 getIndirectRayColor(vec3 o, vec3 d, uvec3 seed, vec3 shadowRayDirReuse) {
  MarchingResult indirectRayResult;

  bool indirectRayHit = cascadedMarching(indirectRayResult, o, d);
  if (!indirectRayHit) {
    // exclude the sun light here!
    return skyColor(d, false);
  }

  // reuse the shadow ray dir for better performance
  vec3 shadowRay2Color = vec3(0.0);
  if (dot(shadowRayDirReuse, indirectRayResult.normal) >= 0.0) {
    shadowRay2Color = getShadowRayColor(indirectRayResult.nextTracingPosition, shadowRayDirReuse);
    vec3 brdf       = indirectRayResult.color * kInvPi;
    const float shadowRayPdf = 1.0 / (0.0001 * kPi);
    shadowRay2Color *= brdf * dot(shadowRayDirReuse, indirectRayResult.normal) / shadowRayPdf;
  }

  return shadowRay2Color;
}

// most of the return value is only valid if hit, except for oPrimaryRayIterUsed
bool getPrimaryRayColor(out float oT, out uint oPrimaryRayIterUsed,
                        out uint oPrimaryRayChunkTraversed, out vec3 oColor, out vec3 oPosition,
                        out vec3 oNormal, out uint oVoxHash, uvec3 seed, vec3 o, vec3 d,
                        float optimizedDistance) {
  MarchingResult primaryRayResult;
  bool primaryRayHit = cascadedMarching(primaryRayResult, o + d * optimizedDistance, d);

  oT                        = primaryRayResult.t;
  oPrimaryRayIterUsed       = primaryRayResult.iter;
  oPrimaryRayChunkTraversed = primaryRayResult.chunkTraversed;
  oColor                    = primaryRayResult.color;
  oPosition                 = primaryRayResult.position;
  oNormal                   = primaryRayResult.normal;
  oVoxHash                  = primaryRayResult.voxHash;

  oT += optimizedDistance;

  if (!primaryRayHit) {
    oT        = 1e10;
    oPosition = o + d * oT;

    vec3 color, pos;
    float t;
    bool hitSea = traceSeascape(color, pos, t, o, d);
    if (hitSea) {
      oColor = color;
      // oPosition = pos;
      // oT        = t;
    } else {
      oColor = skyColor(d, true);
    }

    return false;
  }

  // uncomment to: show normal
  // return true;

  vec3 brdf = primaryRayResult.color * kInvPi;

  // direct contribution
  vec3 shadowRayDir   = getRandomShadowRay(makeDisturbedSeed(seed, 1));
  vec3 shadowRayColor = vec3(0.0);
  if (dot(shadowRayDir, primaryRayResult.normal) >= 0.0) {
    shadowRayColor = getShadowRayColor(primaryRayResult.nextTracingPosition, shadowRayDir);
    const float shadowRayPdf = 1.0 / (0.0001 * kPi);
    shadowRayColor *= brdf * dot(shadowRayDir, primaryRayResult.normal) / shadowRayPdf;
  }

  if (tweakableParametersUbo.data.traceIndirectRay == 0u) {
    oColor = shadowRayColor;
    return true;
  }

  // indirect contribution
  vec3 indirectRayDir =
      randomCosineWeightedHemispherePoint(primaryRayResult.normal, makeDisturbedSeed(seed, 2));
  vec3 indirectRayColor =
      getIndirectRayColor(primaryRayResult.nextTracingPosition, indirectRayDir, seed, shadowRayDir);

  float indirectRayPdf = dot(indirectRayDir, primaryRayResult.normal) / kPi;
  indirectRayColor *= brdf * dot(indirectRayDir, primaryRayResult.normal) / indirectRayPdf;

  oColor = shadowRayColor + indirectRayColor;
  return true;
}

void writeOutputBuffer(ivec2 uvi, bool hitVoxel, vec3 position) {
  // if uvi is not the center pixel, we don't write the output buffer
  if (uvi != ivec2(renderInfoUbo.data.lowResSize) / 2) {
    return;
  }
  outputInfoBuffer.data.midRayHit    = uint(hitVoxel);
  outputInfoBuffer.data.midRayHitPos = position;
}

void main() {
  ivec2 uvi = ivec2(gl_GlobalInvocationID.xy);
  if (any(greaterThanEqual(uvi, ivec2(renderInfoUbo.data.lowResSize)))) {
    return;
  }

  uvec3 seed = getSeed();

  vec3 o, d;
  // (-0.5, 0.5)
  vec2 subpixOffset =
      bool(tweakableParametersUbo.data.taa) ? renderInfoUbo.data.subpixOffset : vec2(0);
  rayGen(o, d, subpixOffset);

  float optimizedDistance = 0;

  // beam optimization
  if (bool(tweakableParametersUbo.data.beamOptimization)) {
    ivec2 beamUv      = ivec2(gl_GlobalInvocationID.xy / sceneInfoBuffer.data.beamResolution);
    float t1          = imageLoad(beamDepthImage, beamUv).r;
    float t2          = imageLoad(beamDepthImage, beamUv + ivec2(1, 0)).r;
    float t3          = imageLoad(beamDepthImage, beamUv + ivec2(0, 1)).r;
    float t4          = imageLoad(beamDepthImage, beamUv + ivec2(1, 1)).r;
    float t           = min(min(t1, t2), min(t3, t4));
    optimizedDistance = t;
  }

  uint voxHash;
  uint primaryRayIterUsed;
  uint primaryRayChunkTraversed;
  vec3 normal, position, color;
  float tMin;
  bool hitVoxel = getPrimaryRayColor(tMin, primaryRayIterUsed, primaryRayChunkTraversed, color,
                                     position, normal, voxHash, seed, o, d, optimizedDistance);

  if (hitVoxel) {
    imageStore(positionImage, uvi, vec4(position, 0.0));
    imageStore(normalImage, uvi, uvec4(packNormal(normal), 0, 0, 0));
    imageStore(voxHashImage, uvi, uvec4(voxHash, 0, 0, 0));
  }
  imageStore(depthImage, uvi, vec4(tMin, 0.0, 0.0, 0.0));

  // calculate the motion here avoids a store - load cycle for the position, and the motion
  // vector can be reused in temporal filter and the taa filter, also, using a motion vector is
  // easier for us to handle moving objects in the future
  vec2 pUv01 = projectWorldPosToScreenUv(position, true);
  vec2 uv01  = projectWorldPosToScreenUv(position, false);
  // the motion vector points to the previous frame, and is normalized
  vec2 motion = pUv01 - uv01;

  imageStore(hitImage, uvi, uvec4(hitVoxel ? 1 : 0, 0, 0, 0));
  imageStore(motionImage, uvi, vec4(motion, 0, 0));

  uint packedColor = packRgbe(color);
  if (hitVoxel) {
    imageStore(rawImage, uvi, uvec4(packedColor, 0, 0, 0));
  } else {
    imageStore(backgroundImage, uvi, uvec4(packedColor, 0, 0, 0));
  }

  const vec3 iterUsedColor       = vec3(1, 0.4, 0.2) * 0.02 * float(primaryRayIterUsed);
  const vec3 chunkTraversedColor = vec3(0.2, 0.4, 1) * 0.2 * float(primaryRayChunkTraversed);

  vec3 overlappingColor = vec3(0);
  if (bool(tweakableParametersUbo.data.visualizeOctree)) {
    overlappingColor += iterUsedColor;
  }
  if (bool(tweakableParametersUbo.data.visualizeChunks)) {
    overlappingColor += chunkTraversedColor;
  }

  imageStore(octreeVisualizationImage, uvi, vec4(overlappingColor, 0));

  writeOutputBuffer(uvi, hitVoxel, position);
}
