#version 450
#extension GL_GOOGLE_include_directive : require

#define STRATUM_SIZE 3

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "../include/svoTracerDescriptorSetLayouts.glsl"

#include "../include/interpolation.glsl"
#include "../include/packer.glsl"
#include "../include/projection.glsl"

#define DISPLAY_TYPE_RAW 0

// this hashing function is probably to be the best one of its kind
// https://nullprogram.com/blog/2018/07/31/
uint hash(uint x) {
  x ^= x >> 16;
  x *= 0x7feb352dU;
  x ^= x >> 15;
  x *= 0x846ca68bU;
  x ^= x >> 16;
  return x;
}

// Converts a color from linear light gamma to sRGB gamma
// https://gamedev.stackexchange.com/questions/92015/optimized-linear-to-srgb-glsl
vec4 linearToSrgb(vec4 linearRGB) {
  bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));
  vec4 higher  = vec4(1.055) * pow(linearRGB, vec4(1.0 / 2.4)) - vec4(0.055);
  vec4 lower   = linearRGB * vec4(12.92);
  return mix(higher, lower, cutoff);
}

// https://www.shadertoy.com/view/MslGR8
vec3 getDitherMask(ivec2 screenSpaceUv) {
  // bit-depth of display. Normally 8 but some LCD monitors are 7 or even 6-bit.
  float dither_bit = 8.0;
  // calculate grid position
  float grid_position =
      fract(dot(screenSpaceUv - vec2(0.5, 0.5), vec2(1.0 / 16.0, 10.0 / 36.0) + 0.25));

  // calculate how big the shift should be
  float dither_shift = (0.25) * (1.0 / (pow(2.0, dither_bit) - 1.0));

  // shift the individual colors differently, thus making it even harder to see the dithering
  // pattern
  vec3 dither_shift_RGB = vec3(dither_shift, -dither_shift, dither_shift); // subpixel dithering

  // modify shift acording to grid position
  dither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position);

  // shift the color by dither_shift
  return 0.5 / 255.0 + dither_shift_RGB;
}

vec2 highResToLowRes(ivec2 highResUv) {
  vec2 subpixOffset = twickableParametersUbo.data.taa ? renderInfoUbo.data.subpixOffset : vec2(0);
  return (vec2(highResUv) + vec2(0.5)) *
             (vec2(renderInfoUbo.data.lowResSize) / vec2(renderInfoUbo.data.highResSize)) -
         vec2(0.5) - subpixOffset;
}

void getMoments(out vec3 mom1, out vec3 mom2, out vec3 colorCenter, ivec2 uv) {
  mom1            = vec3(0);
  mom2            = vec3(0);
  uint numSamples = 0;

  for (int yy = -1; yy <= 1; yy++) {
    for (int xx = -1; xx <= 1; xx++) {
      ivec2 p = uv + ivec2(xx, yy);

      // out of bound
      if (any(lessThan(p, ivec2(0))) ||
          any(greaterThanEqual(p, ivec2(renderInfoUbo.data.lowResSize)))) {
        continue;
      }

      vec3 color = unpackRGBE(imageLoad(blittedImage, p).x);
      mom1 += color;
      mom2 += color * color;

      if (xx == 0 && yy == 0) {
        colorCenter = color;
      }

      numSamples++;
    }
  }

  mom1 /= float(numSamples);
  mom2 /= float(numSamples);
}

vec2 getLongestMotion(ivec2 uv) {
  float len   = -1;
  vec2 motion = vec2(0);
  return imageLoad(motionImage, uv).xy;

  for (int yy = -1; yy <= 1; yy++) {
    for (int xx = -1; xx <= 1; xx++) {
      ivec2 p = uv + ivec2(xx, yy);
      vec2 m  = imageLoad(motionImage, p).xy;
      float l = dot(m, m);
      if (l > len) {
        len    = l;
        motion = m;
      }
    }
  }

  return motion;
}

vec3 getAccumColor(ivec2 pUv) {
  ivec2 bound = ivec2(renderInfoUbo.data.highResSize);
  if (any(lessThan(pUv, ivec2(0))) || any(greaterThanEqual(pUv, bound))) {
    return vec3(0);
  }
  return imageLoad(lastTaaImage, pUv).xyz;
}

float getSampleWeight(vec2 delta, float scale) {
  return clamp(1 - scale * dot(delta, delta), 0, 1);
}

// #define RAW_DIRECT_OUTPUT

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (any(greaterThanEqual(uv, ivec2(renderInfoUbo.data.highResSize)))) {
    return;
  }

#ifdef RAW_DIRECT_OUTPUT
  if (any(greaterThanEqual(uv, ivec2(renderInfoUbo.data.lowResSize)))) {
    return;
  }
  vec3 readingCol = unpackRGBE(imageLoad(rawImage, uv).x).rgb;
  imageStore(renderTargetImage, uv, vec4(readingCol.zyx, 1));
  return;
#endif

  vec2 lowResUv     = highResToLowRes(uv);
  ivec2 intLowResUv = ivec2(lowResUv);
  vec3 writingCol   = vec3(0);
  if (twickableParametersUbo.data.taa) {
    // get moments
    vec3 mom1, mom2;
    vec3 colorCenter;
    getMoments(mom1, mom2, colorCenter, intLowResUv);

    // motion points to the last frame
    vec2 motion = getLongestMotion(intLowResUv) * vec2(renderInfoUbo.data.highResSize);
    vec2 pUv    = vec2(uv) + vec2(0.5) + motion;

    vec3 colorPrev = textureLod(lastTaaTexture, pUv * renderInfoUbo.data.highResSizeInv, 0).xyz;

    // neighborhood color clamping using variance
    float varianceScale = 3.0;
    vec3 sigma          = sqrt(max(vec3(0), mom2 - mom1 * mom1));
    vec3 mi             = mom1 - sigma * varianceScale;
    vec3 ma             = mom1 + sigma * varianceScale;
    colorPrev           = clamp(colorPrev, mi, ma);

    // mix the new color with the clamped previous color
    float motionWeight = smoothstep(0.0, 1.0, length(motion));
    float sampleWeight =
        getSampleWeight(lowResUv - intLowResUv, float(renderInfoUbo.data.highResSize.x) /
                                                    float(renderInfoUbo.data.lowResSize.x));
    float pixelWeight = max(motionWeight, sampleWeight) * 0.1;
    pixelWeight       = clamp(pixelWeight, 0, 1);

    writingCol = mix(colorPrev, colorCenter, pixelWeight);

    imageStore(taaImage, uv, vec4(writingCol, 0));
  } else {
    writingCol = unpackRGBE(imageLoad(blittedImage, intLowResUv).x).rgb;
  }

  // octree overlay
  if (twickableParametersUbo.data.visualizeOctree) {
    writingCol += unpackRGBE(imageLoad(octreeVisualizationImage, intLowResUv).x);
  }

  // dithering pattern, to reduce banding
  writingCol += getDitherMask(uv);

  // rgb to bgr
  imageStore(renderTargetImage, uv, vec4(writingCol.zyx, 1));
}