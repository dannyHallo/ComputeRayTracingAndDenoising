#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "../include/svoTracerDescriptorSetLayouts.glsl"

#include "../include/atmosCommon.glsl"
#include "../include/core/color.glsl"
#include "../include/core/packer.glsl"
#include "../include/core/postProcessing.glsl"
#include "../include/projection.glsl"

const uint kDotPixelInnerRadius = 4;
const uint kDotPixelOuterRadius = 5;
const vec4 kDotColor            = vec4(1, 1, 1, 0.4);

ivec2 highResToMidRes(ivec2 highResuvi) {
  float ratio = float(renderInfoUbo.data.midResSize.x) / float(renderInfoUbo.data.highResSize.x);
  return ivec2(vec2(highResuvi) * ratio);
}

vec2 midResToLowRes(ivec2 midResuvi) {
  vec2 subpixOffset =
      bool(twickableParametersUbo.data.taa) ? renderInfoUbo.data.subpixOffset : vec2(0);
  return (vec2(midResuvi) + vec2(0.5)) *
             (vec2(renderInfoUbo.data.lowResSize) / vec2(renderInfoUbo.data.midResSize)) -
         vec2(0.5) - subpixOffset;
}

vec3 blendWithDot(vec3 color, ivec2 uvi) {
  ivec2 center = ivec2(renderInfoUbo.data.highResSize) / 2;
  ivec2 diff   = abs(uvi - center);

  // fast bb culling
  if (diff.x > kDotPixelOuterRadius || diff.y > kDotPixelOuterRadius) {
    return color;
  }

  float diffSq = float(dot(diff, diff));

  // border dropoff
  float dist = sqrt(diffSq);
  float dotStrength =
      1 - smoothstep(float(kDotPixelInnerRadius), float(kDotPixelOuterRadius), dist);
  dotStrength *= kDotColor.a;
  return mix(color, kDotColor.rgb, dotStrength);
}

vec3 debugInfoOverwrite(ivec2 midResuvi) {
  ivec2 lowResuvi = ivec2(midResToLowRes(midResuvi));
  if (lowResuvi.x < 0 || lowResuvi.y < 0 || lowResuvi.x >= renderInfoUbo.data.lowResSize.x ||
      lowResuvi.y >= renderInfoUbo.data.lowResSize.y) {
    return vec3(0);
  }
  return unpackRGBE(imageLoad(octreeVisualizationImage, lowResuvi).x);
}

// #define RAW_DIRECT_OUTPUT

vec3 sunWithBloom(vec3 rayDir, vec3 sunDir) {
  const float sunSolidAngle  = 1e-2;
  const float minSunCosTheta = cos(sunSolidAngle);

  float cosTheta = dot(rayDir, sunDir);
  // the solid sun
  if (cosTheta >= minSunCosTheta) {
    return vec3(1.0);
  }

  float offset        = minSunCosTheta - cosTheta;
  float gaussianBloom = exp(-offset * 50000.0) * 0.5;
  float invBloom      = 1.0 / (0.02 + offset * 300.0) * 0.01;
  return vec3(gaussianBloom + invBloom);
}

// subpixOffset ranges from -0.5 to 0.5
void rayGen(out vec3 o, out vec3 d, vec2 subpixOffset) {
  vec2 screenSpaceUv = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5) + subpixOffset) /
                       vec2(renderInfoUbo.data.highResSize);
  o = renderInfoUbo.data.camPosition;
  d = normalize(projectScreenUvToWorldCamFarPoint(screenSpaceUv, false) -
                renderInfoUbo.data.camPosition);
}

void main() {
  ivec2 uvi        = ivec2(gl_GlobalInvocationID.xy);
  ivec2 targetSize = imageSize(renderTargetImage);
  if (any(greaterThanEqual(uvi, targetSize))) {
    return;
  }

  vec2 uv = vec2(uvi) / vec2(targetSize);

  vec3 sunDir = getSunDir(environmentUbo.data.sunAngleA / 180.0 * kPi);

  vec3 o, rayDir;
  rayGen(o, rayDir, vec2(0));

  vec2 skyLutUv = getLookupUv2(rayDir, sunDir);
  vec3 lum      = textureLod(skyViewLutTexture, skyLutUv, 0).rgb;

  // bloom should be added at the end, but this is subtle and works well.
  vec3 sunLum = sunWithBloom(rayDir, sunDir);
  // use smoothstep to limit the effect, so it drops off to actual zero.
  sunLum = smoothstep(0.002, 1.0, sunLum);

  if (length(sunLum) > 0.0) {
    if (rayIntersectSphere(kCamPos, rayDir, kGroundRadiusMm) >= 0.0) {
      sunLum *= 0.0;
    } else {
      // if the sun value is applied to this pixel, we need to calculate the
      // transmittance to obscure it
      vec2 tLutUv = getLookupUv1(kCamPos, sunDir);
      sunLum *= textureLod(transmittanceLutTexture, tLutUv, 0).rgb;
    }
  }
  lum += sunLum;

  // tonemapping and gamma. ScamUper ad-hoc, probably a better way to do this.
  lum *= 20.0;
  lum = pow(lum, vec3(1.3));
  // lum /= (smoothstep(0.0, 0.2, clamp(sunDir.y, 0.0, 1.0)) * 2.0 + 0.15);

  lum = jodieReinhardTonemap(lum);

  // eliminate the color-banding effect
  lum += getDitherMask(uvi);

  imageStore(renderTargetImage, uvi, vec4(lum.bgr, 1));
}
