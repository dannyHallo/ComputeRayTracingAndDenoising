#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "include/svoTracerDescriptorSetLayouts.glsl"

#include "include/colorPacker.glsl"
#include "include/definitions.glsl"

vec2 backwardProjection(ivec2 uv) {
  vec4 worldPos = imageLoad(positionImage, uv);

  mat4 mvpe;
  mvpe = renderInfoUbo.data.lastMvpe;

  vec4 screenBoxCoord = mvpe * worldPos;

  // points are bounded in [-1, 1] in x, y, z after the following
  screenBoxCoord /= screenBoxCoord.w;
  // points are bounded in [0, 1] in x, y, meanwhile z, w are thrown away
  screenBoxCoord = (screenBoxCoord + vec4(1)) / 2;
  // to vulkan uv coord, starts from top left corner, range is [0, 1]
  vec2 uvCoord = vec2(screenBoxCoord.x, 1 - screenBoxCoord.y);
  return vec2(uvCoord.x * renderInfoUbo.data.swapchainWidth,
              uvCoord.y * renderInfoUbo.data.swapchainHeight);
}

vec3 getAccumColor(ivec2 pUv) {
  ivec2 bound = ivec2(renderInfoUbo.data.swapchainWidth, renderInfoUbo.data.swapchainHeight);
  if (any(lessThan(pUv, ivec2(0))) || any(greaterThanEqual(pUv, bound))) {
    return vec3(0);
  }
  return unpackRGBE(imageLoad(lastAccumedImage, pUv).x);
}

bool isConsistent(vec3 normal, vec3 lastNormal, vec3 position, vec3 lastPosition) {
  // normal test is useful for edges (nearby disocclusions)
  float normalFac       = dot(normal, lastNormal);
  bool normalConsistent = normalFac > 0.9;
  // normalConsistent      = true;

  // position test is useful for disocclusions happened in some distance
  float positionFac       = exp(-distance(position, lastPosition));
  bool positionConsistent = positionFac > temporalFilterInfoUbo.data.temporalPositionPhi;

  return normalConsistent && positionConsistent;
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= renderInfoUbo.data.swapchainWidth || uv.y >= renderInfoUbo.data.swapchainHeight)
    return;

  bool hit = imageLoad(hitImage, uv).x != 0;
  if (!hit) {
    return;
  }

  vec2 pUv     = backwardProjection(uv);
  vec2 pBaseUv = floor(pUv - vec2(0.5));
  vec2 subpix  = fract(pUv - vec2(0.5) - pBaseUv);

  const ivec2 off[4] = {{0, 0}, {1, 0}, {0, 1}, {1, 1}};
  float w[4]         = {(1.0 - subpix.x) * (1.0 - subpix.y), (subpix.x) * (1.0 - subpix.y),
                        (1.0 - subpix.x) * (subpix.y), (subpix.x) * (subpix.y)};

  // sum of weights of bilinear interpolation is 1
  float sumOfWeights       = 0;
  float sumOfHistLengths   = 0;
  vec3 sumOfWeightedColors = vec3(0);
  // float varianceBlending = 0;

  // normal test is useful for edges (nearby disocclusions)
  vec3 normal   = imageLoad(normalImage, uv).xyz;
  vec3 position = imageLoad(positionImage, uv).xyz;
  for (int i = 0; i < 4; i++) {
    ivec2 tappingUv   = ivec2(pBaseUv) + off[i];
    vec3 lastNormal   = imageLoad(lastNormalImage, tappingUv).xyz;
    vec3 lastPosition = imageLoad(lastPositionImage, tappingUv).xyz;

    bool consistent = isConsistent(normal, lastNormal, position, lastPosition);
    if (consistent) {
      sumOfHistLengths += w[i] * float(imageLoad(temporalHistLengthImage, uv).x);
      sumOfWeightedColors += w[i] * getAccumColor(tappingUv);
      sumOfWeights += w[i];
    }
  }

  vec3 rawColor = unpackRGBE(imageLoad(rawImage, uv).x);

  float histLength;
  vec3 thisFrameColor;

  // relevant surfaces found
  if (sumOfWeights >= 1e-6) {
    sumOfHistLengths /= sumOfWeights;
    sumOfWeightedColors /= sumOfWeights;
    histLength     = min(255.0, sumOfHistLengths + 1.0);
    float alphaFac = max(temporalFilterInfoUbo.data.temporalAlpha, 1.0 / histLength);
    thisFrameColor = mix(sumOfWeightedColors, rawColor, alphaFac);
  } else {
    histLength     = 1.0;
    thisFrameColor = rawColor;
  }

  imageStore(aTrousPingImage, uv, uvec4(packRGBE(thisFrameColor), 0, 0, 0));
  imageStore(temporalHistLengthImage, uv, uvec4(histLength, 0, 0, 0));
  // vec4 accumVarianceHist = mix(imageLoad(lastVarianceHistImage, pUv), vec4(0), varianceBlending);
  // imageStore(varianceHistImage, uv, accumVarianceHist);
}