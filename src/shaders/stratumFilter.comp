#version 450
#extension GL_GOOGLE_include_directive : require

#define STRATUM_SIZE 3

// dispatching per stratum, no preload step because of atrous
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// the uniform buffer that contains ray trace description infos
layout(binding = 1) uniform UniformBufferObject {
  int i;
  bool bypass;
}
ubo;

// full res
layout(binding = 2, rgba32f) readonly uniform image2D posTex;
layout(binding = 3, rgba32f) readonly uniform image2D normalTex;
layout(binding = 4, r32f) readonly uniform image2D depthTex;
layout(binding = 5, rg32f) readonly uniform image2D gradientTex;
layout(binding = 6, rgba32f) readonly uniform image2D rawColorTex;

// stratum res, [float luminance, float variance, float temporal_gradient, float normalized_factor]
layout(binding = 7, r32ui) readonly uniform uimage2D stratumOffsetTex;
layout(binding = 8, rgba32f) uniform image2D pingTex;
layout(binding = 9, rgba32f) uniform image2D pongTex;

#include "include/definitions.glsl"
#include "include/globalUbo.glsl"

// standard 3x3 filtering kernel from q2rtx
const float waveletFac      = 0.5;
const float kernel3x3[2][2] = {{1.0, waveletFac}, {waveletFac, waveletFac *waveletFac}};

uvec2 decodeOffsetInStratum(uint offset) {
  // offset of 0 is invalid
  offset--;
  return uvec2(offset % STRATUM_SIZE, offset / STRATUM_SIZE);
}

// returns whether this pixel has stratum rec
bool checkStratumRecord(inout uvec2 stratumOffsetDecoded) {
  stratumOffsetDecoded = uvec2(0);

  ivec2 stratumUv       = ivec2(gl_GlobalInvocationID.xy);
  uint stratumOffsetRaw = imageLoad(stratumOffsetTex, stratumUv).x;
  if (stratumOffsetRaw == 0) return false;

  stratumOffsetDecoded = decodeOffsetInStratum(stratumOffsetRaw);
  return true;
}

vec4 readPing(ivec2 readingUv) { return imageLoad(pingTex, readingUv); }
vec4 readPong(ivec2 readingUv) { return imageLoad(pongTex, readingUv); }

void loadData(bool usePingAsInput, ivec2 readingStratumUv, ivec2 readingFullResUv,
              out vec2 gradientAtUv, out vec3 normalAtUv, out float luminanceAtUv,
              out float depthAtUv) {
  if (readingFullResUv.x < 0 || readingFullResUv.y < 0 ||
      readingFullResUv.x >= globalUbo.swapchainWidth ||
      readingFullResUv.y >= globalUbo.swapchainHeight) {
    readingFullResUv = clamp(readingFullResUv, ivec2(0),
                             ivec2(globalUbo.swapchainWidth - 1, globalUbo.swapchainHeight - 1));
  }

  gradientAtUv  = imageLoad(gradientTex, readingFullResUv).xy;
  normalAtUv    = imageLoad(normalTex, readingFullResUv).xyz;
  depthAtUv     = imageLoad(depthTex, readingFullResUv).x;
  luminanceAtUv = usePingAsInput ? imageLoad(pingTex, readingFullResUv).x
                                 : imageLoad(pongTex, readingFullResUv).x;
}

const float phiLuminance = 0.3;
const float phiDepth     = 0.2;
const float phiNormal    = 128.0;
void blurKernel(bool usePingAsInput, uint iteration, ivec2 offset, ivec2 stratumOffset,
                float luminanceAtUv, vec3 normalAtUv, vec2 gradientAtUv, float depthAtUv,
                inout float sumOfWeight, inout vec4 sumOfValue) {
  float weight = 0.0;

  float weightK = kernel3x3[abs(offset.x)][abs(offset.y)];
  int stepSize  = 1 << iteration;

  ivec2 currentStratumUv = ivec2(gl_GlobalInvocationID.xy);
  offset *= stepSize;
  ivec2 readingStratumUv = currentStratumUv + offset;
  ivec2 readingFullResUv = readingStratumUv * STRATUM_SIZE + stratumOffset;

  if (offset == ivec2(0, 0)) {
    weight = weightK;
  } else {
    float weightC, weightN, weightZ;

    vec2 gradientAtSample;
    vec3 normalAtSample;
    float luminanceAtSample;
    float depthAtSample;
    loadData(usePingAsInput, readingStratumUv, readingFullResUv, gradientAtSample, normalAtSample,
             luminanceAtSample, depthAtSample);

    float phiC    = pow(2, -iteration) * phiLuminance;
    float colDiff = abs(luminanceAtSample - luminanceAtUv);
    weightC       = ubo.i == 0 ? 1.0 : exp(-colDiff / phiC);

    weightN = max(0., pow(dot(normalAtUv, normalAtSample), phiNormal));

    float differenceInDepth = 0;
    differenceInDepth       = abs((depthAtUv - depthAtSample) - dot(gradientAtUv, vec2(offset)));
    weightZ                 = exp(-differenceInDepth / phiDepth);

    weight = weightK * weightC * weightN * weightZ;
  }

  vec4 readValue = usePingAsInput ? readPing(readingStratumUv) : readPong(readingStratumUv);

  sumOfWeight += weight;
  sumOfValue += weight * readValue;
}

vec4 bilateralBlur(bool usePingAsInput, ivec2 stratumOffset) {
  float sumOfWeight = 0;
  vec4 sumOfValue   = vec4(0.0);

  // load data of the center pixel
  ivec2 currentStratumUv = ivec2(gl_GlobalInvocationID.xy);
  ivec2 readingStratumUv = currentStratumUv;
  ivec2 readingFullResUv = readingStratumUv * STRATUM_SIZE + stratumOffset;

  float luminanceAtUv;
  vec3 normalAtUv;
  vec2 gradientAtUv;
  float depthAtUv;
  loadData(usePingAsInput, readingStratumUv, readingFullResUv, gradientAtUv, normalAtUv,
           luminanceAtUv, depthAtUv);

  const int r = (STRATUM_SIZE - 1) / 2;
  for (int x = -r; x <= r; x++) {
    for (int y = -r; y <= r; y++) {
      // because the first iter is reserved
      blurKernel(usePingAsInput, ubo.i - 1, ivec2(x, y), stratumOffset, luminanceAtUv, normalAtUv,
                 gradientAtUv, depthAtUv, sumOfWeight, sumOfValue);
    }
  }

  return sumOfValue / sumOfWeight;
}

float calculateInStratumAvgLum() {
  float sum = 0;
  for (int i = 0; i < STRATUM_SIZE; i++) {
    for (int j = 0; j < STRATUM_SIZE; j++) {
      ivec2 lookupPos = ivec2(gl_GlobalInvocationID.xy) * STRATUM_SIZE + ivec2(i, j);
      vec3 color      = imageLoad(rawColorTex, lookupPos).rgb;
      sum += dot(kRgbToLuminanceMat, color);
    }
  }
  return sum / (STRATUM_SIZE * STRATUM_SIZE);
}

void main() {

  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= ceil(globalUbo.swapchainWidth / 3.0) || uv.y >= ceil(globalUbo.swapchainHeight / 3.0))
    return;

  // in the first iter, we prepare for the average lum in stratum resolution
  if (ubo.i == 0) {
    float avgLum = calculateInStratumAvgLum();
    vec4 read    = imageLoad(pingTex, uv);
    vec4 write   = vec4(avgLum, 0.0, read.z, read.w);
    imageStore(pongTex, uv, write);
  }
  if (ubo.bypass) return;

  vec4 result = vec4(0.0);

  uvec2 stratumOffsetU;
  bool hasRecord      = checkStratumRecord(stratumOffsetU);
  ivec2 stratumOffset = ivec2(stratumOffsetU);

  // find variance and luminance from raw color without any filtering, ping -> pong
  switch (ubo.i) {
  case (1): {
    vec4 blurred = bilateralBlur(false, stratumOffset);
    imageStore(pingTex, uv, blurred);
    break;
  }
  case (2): {
    vec4 blurred = bilateralBlur(true, stratumOffset);
    imageStore(pongTex, uv, blurred);
    break;
  }
  case (3): {
    vec4 blurred = bilateralBlur(false, stratumOffset);
    imageStore(pingTex, uv, blurred);
    break;
  }
  case (4): {
    vec4 blurred = bilateralBlur(true, stratumOffset);
    imageStore(pongTex, uv, blurred);
    break;
  }
  case (5): {
    vec4 blurred = bilateralBlur(false, stratumOffset);
    imageStore(pingTex, uv, blurred);
    break;
  }
  case (6): {
    vec4 blurred = bilateralBlur(true, stratumOffset);
    imageStore(pongTex, uv, blurred);
    break;
  }
  }
}