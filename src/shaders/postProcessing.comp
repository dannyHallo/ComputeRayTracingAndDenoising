#version 450
#extension GL_GOOGLE_include_directive : require

#define STRATUM_SIZE 3

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "include/svoTracerDescriptorSetLayouts.glsl"

#include "include/interpolation.glsl"
#include "include/packer.glsl"
#include "include/projection.glsl"

#define DISPLAY_TYPE_RAW 0

// this hashing function is probably to be the best one of its kind
// https://nullprogram.com/blog/2018/07/31/
uint hash(uint x) {
  x ^= x >> 16;
  x *= 0x7feb352dU;
  x ^= x >> 15;
  x *= 0x846ca68bU;
  x ^= x >> 16;
  return x;
}

// Converts a color from linear light gamma to sRGB gamma
// https://gamedev.stackexchange.com/questions/92015/optimized-linear-to-srgb-glsl
vec4 linearToSrgb(vec4 linearRGB) {
  bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));
  vec4 higher  = vec4(1.055) * pow(linearRGB, vec4(1.0 / 2.4)) - vec4(0.055);
  vec4 lower   = linearRGB * vec4(12.92);
  return mix(higher, lower, cutoff);
}

uvec2 decodeOffsetInStratum(uint offset) {
  return uvec2(offset % STRATUM_SIZE, offset / STRATUM_SIZE);
}

// https://www.shadertoy.com/view/MslGR8
vec3 getDitherMask(ivec2 screenSpaceUv) {
  // bit-depth of display. Normally 8 but some LCD monitors are 7 or even 6-bit.
  float dither_bit = 8.0;
  // calculate grid position
  float grid_position =
      fract(dot(screenSpaceUv - vec2(0.5, 0.5), vec2(1.0 / 16.0, 10.0 / 36.0) + 0.25));

  // calculate how big the shift should be
  float dither_shift = (0.25) * (1.0 / (pow(2.0, dither_bit) - 1.0));

  // shift the individual colors differently, thus making it even harder to see the dithering
  // pattern
  vec3 dither_shift_RGB = vec3(dither_shift, -dither_shift, dither_shift); // subpixel dithering

  // modify shift acording to grid position
  dither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position);

  // shift the color by dither_shift
  return 0.5 / 255.0 + dither_shift_RGB;
}

vec2 highResToLowRes(ivec2 highResUv) {
  return (vec2(highResUv) + vec2(0.5)) *
             (vec2(renderInfoUbo.data.lowResSize) / vec2(renderInfoUbo.data.highResSize)) -
         vec2(0.5) - renderInfoUbo.data.subpixOffset;
}

vec4 bilinearInterpolateImage(vec2 uv) {
  // Calculate the integer coordinates (bottom-left corner)
  ivec2 baseCoord = ivec2(uv);

  // Calculate fractional part to determine interpolation weights
  vec2 fractionalPart = fract(uv);

  // Load the four nearest texels
  vec4 bl = imageLoad(taaImage, baseCoord);               // Bottom left
  vec4 br = imageLoad(taaImage, baseCoord + ivec2(1, 0)); // Bottom right
  vec4 tl = imageLoad(taaImage, baseCoord + ivec2(0, 1)); // Top left
  vec4 tr = imageLoad(taaImage, baseCoord + ivec2(1, 1)); // Top right

  // Interpolate between the four texels
  vec4 bottom     = mix(bl, br, fractionalPart.x);      // Interpolate along x (bottom)
  vec4 top        = mix(tl, tr, fractionalPart.x);      // Interpolate along x (top)
  vec4 finalColor = mix(bottom, top, fractionalPart.y); // Interpolate along y

  return finalColor;
}

void getMoments(out vec3 mom1, out vec3 mom2, out vec3 colorCenter, ivec2 uv) {
  mom1            = vec3(0);
  mom2            = vec3(0);
  uint numSamples = 0;

  for (int yy = -1; yy <= 1; yy++) {
    for (int xx = -1; xx <= 1; xx++) {
      ivec2 p = uv + ivec2(xx, yy);

      // out of bound
      if (any(lessThan(p, ivec2(0))) ||
          any(greaterThanEqual(p, ivec2(renderInfoUbo.data.lowResSize)))) {
        continue;
      }

      vec3 color = unpackRGBE(imageLoad(blittedImage, p).x);
      mom1 += color;
      mom2 += color * color;

      if (xx == 0 && yy == 0) {
        colorCenter = color;
      }

      numSamples++;
    }
  }

  mom1 /= float(numSamples);
  mom2 /= float(numSamples);
}

vec2 getLongestMotion(ivec2 uv) {
  float len   = -1;
  vec2 motion = vec2(0);

  for (int yy = -1; yy <= 1; yy++) {
    for (int xx = -1; xx <= 1; xx++) {
      ivec2 p = uv + ivec2(xx, yy);
      vec2 m  = imageLoad(motionImage, p).xy;
      float l = dot(m, m);
      if (l > len) {
        len    = l;
        motion = m;
      }
    }
  }

  return motion;
}

vec3 getAccumColor(ivec2 pUv) {
  ivec2 bound = ivec2(renderInfoUbo.data.highResSize);
  if (any(lessThan(pUv, ivec2(0))) || any(greaterThanEqual(pUv, bound))) {
    return vec3(0);
  }
  return unpackRGBE(imageLoad(lastTaaImage, pUv).x);
}

float getSampleWeight(vec2 delta, float scale) {
  return clamp(1 - scale * dot(delta, delta), 0, 1);
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (any(greaterThanEqual(uv, ivec2(renderInfoUbo.data.highResSize)))) {
    return;
  }

  vec2 lowResUv     = highResToLowRes(uv);
  ivec2 intLowResUv = ivec2((lowResUv));

  // get moments
  vec3 mom1, mom2;
  vec3 colorCenter;
  getMoments(mom1, mom2, colorCenter, intLowResUv);

  // motion points to the last frame
  // look up for its motion on the low res image
  vec2 motion = getLongestMotion(intLowResUv) * vec2(renderInfoUbo.data.highResSize);
  vec2 pUv    = vec2(uv) + motion;

  vec2 pBaseUv = floor(pUv);
  vec2 subpix  = fract(pUv - pBaseUv);

  const ivec2 off[4] = {{0, 0}, {1, 0}, {0, 1}, {1, 1}};
  float w[4]         = {(1.0 - subpix.x) * (1.0 - subpix.y), (subpix.x) * (1.0 - subpix.y),
                        (1.0 - subpix.x) * (subpix.y), (subpix.x) * (subpix.y)};

  float sumOfWeights       = 0;
  vec3 sumOfWeightedColors = vec3(0);

  // normal test is useful for edges (nearby disocclusions)
  vec3 normal   = unpackNormal(imageLoad(normalImage, uv).x);
  vec3 position = imageLoad(positionImage, uv).xyz;
  for (int i = 0; i < 4; i++) {
    ivec2 tappingUv = ivec2(pBaseUv) + off[i];

    sumOfWeightedColors += w[i] * getAccumColor(tappingUv);
    sumOfWeights += w[i];
  }
  vec3 colorPrev = sumOfWeightedColors / sumOfWeights;

  // mix the new color with the clamped previous color
  float motionWeight = smoothstep(0, 1.0, sqrt(dot(motion, motion)));
  float sampleWeight =
      getSampleWeight(lowResUv - intLowResUv, float(renderInfoUbo.data.highResSize.x) /
                                                  float(renderInfoUbo.data.lowResSize.x));
  float pixelWeight = max(motionWeight, sampleWeight) * 0.1;
  pixelWeight       = clamp(pixelWeight, 0, 1);

  vec3 writingCol = vec3(0);
  writingCol      = mix(colorPrev, colorCenter, pixelWeight);

  // // ensure the posPrev is in range
  // if (all(greaterThanEqual(ivec2(posPrev), ivec2(1))) &&
  //     all(lessThan(ivec2(posPrev), ivec2(renderInfoUbo.data.highResSize) - ivec2(1)))) {
  //   posPrev = vec2(uv);
  // }

  // bool hit = imageLoad(hitImage, intLowResUv).x != 0;
  // if (hit) {
  //   // writingCol = unpackRGBE(imageLoad(aTrousFinalResultImage, intLowResUv).x);

  //   // float depth = imageLoad(depthImage, uv).x;
  //   // writingCol  = vec3(0.5, 0.2, 0.1) * exp(-depth);

  //   // writingCol = unpackNormal(imageLoad(normalImage, uv).x);

  //   // float histLength = imageLoad(temporalHistLengthImage, uv).x;
  //   // writingCol       = exp(-histLength * 0.1) * vec3(1);
  // } else {
  //   writingCol = unpackRGBE(imageLoad(backgroundImage, intLowResUv).x);
  // }

  if (twickableParametersUbo.data.visualizeOctree) {
    writingCol += unpackRGBE(imageLoad(octreeVisualizationImage, intLowResUv).x);
  }

  imageStore(taaImage, uv, uvec4(packRGBE(writingCol), 0, 0, 0));

  // writingCol = unpackRGBE(imageLoad(blittedImage, intLowResUv).x).rgb;

  writingCol += getDitherMask(uv);

  // rgb to bgr
  imageStore(renderTargetImage, uv, vec4(writingCol.zyx, 1));
}