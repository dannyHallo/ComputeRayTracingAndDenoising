#version 450
#extension GL_GOOGLE_include_directive : require

#define STRATUM_SIZE 3

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "include/svoTracerDescriptorSetLayouts.glsl"

#include "include/interpolation.glsl"
#include "include/packer.glsl"
#include "include/projection.glsl"

#define DISPLAY_TYPE_RAW 0

// this hashing function is probably to be the best one of its kind
// https://nullprogram.com/blog/2018/07/31/
uint hash(uint x) {
  x ^= x >> 16;
  x *= 0x7feb352dU;
  x ^= x >> 15;
  x *= 0x846ca68bU;
  x ^= x >> 16;
  return x;
}

// Converts a color from linear light gamma to sRGB gamma
// https://gamedev.stackexchange.com/questions/92015/optimized-linear-to-srgb-glsl
vec4 linearToSrgb(vec4 linearRGB) {
  bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));
  vec4 higher  = vec4(1.055) * pow(linearRGB, vec4(1.0 / 2.4)) - vec4(0.055);
  vec4 lower   = linearRGB * vec4(12.92);
  return mix(higher, lower, cutoff);
}

uvec2 decodeOffsetInStratum(uint offset) {
  return uvec2(offset % STRATUM_SIZE, offset / STRATUM_SIZE);
}

// https://www.shadertoy.com/view/MslGR8
vec3 getDitherMask(ivec2 screenSpaceUv) {
  // bit-depth of display. Normally 8 but some LCD monitors are 7 or even 6-bit.
  float dither_bit = 8.0;
  // calculate grid position
  float grid_position =
      fract(dot(screenSpaceUv - vec2(0.5, 0.5), vec2(1.0 / 16.0, 10.0 / 36.0) + 0.25));

  // calculate how big the shift should be
  float dither_shift = (0.25) * (1.0 / (pow(2.0, dither_bit) - 1.0));

  // shift the individual colors differently, thus making it even harder to see the dithering
  // pattern
  vec3 dither_shift_RGB = vec3(dither_shift, -dither_shift, dither_shift); // subpixel dithering

  // modify shift acording to grid position
  dither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position);

  // shift the color by dither_shift
  return 0.5 / 255.0 + dither_shift_RGB;
}

vec2 highResToLowRes(ivec2 highResUv) {
  vec2 subpixOffset = twickableParametersUbo.data.taa ? renderInfoUbo.data.subpixOffset : vec2(0);
  return (vec2(highResUv) + vec2(0.5)) *
             (vec2(renderInfoUbo.data.lowResSize) / vec2(renderInfoUbo.data.highResSize)) -
         vec2(0.5) - subpixOffset;
}

vec4 bilinearInterpolateImage(vec2 uv) {
  // Calculate the integer coordinates (bottom-left corner)
  ivec2 baseCoord = ivec2(uv);

  // Calculate fractional part to determine interpolation weights
  vec2 fractionalPart = fract(uv);

  // Load the four nearest texels
  vec4 bl = imageLoad(taaImage, baseCoord);               // Bottom left
  vec4 br = imageLoad(taaImage, baseCoord + ivec2(1, 0)); // Bottom right
  vec4 tl = imageLoad(taaImage, baseCoord + ivec2(0, 1)); // Top left
  vec4 tr = imageLoad(taaImage, baseCoord + ivec2(1, 1)); // Top right

  // Interpolate between the four texels
  vec4 bottom     = mix(bl, br, fractionalPart.x);      // Interpolate along x (bottom)
  vec4 top        = mix(tl, tr, fractionalPart.x);      // Interpolate along x (top)
  vec4 finalColor = mix(bottom, top, fractionalPart.y); // Interpolate along y

  return finalColor;
}

void getMoments(out vec3 mom1, out vec3 mom2, out vec3 colorCenter, ivec2 uv) {
  mom1            = vec3(0);
  mom2            = vec3(0);
  uint numSamples = 0;

  for (int yy = -1; yy <= 1; yy++) {
    for (int xx = -1; xx <= 1; xx++) {
      ivec2 p = uv + ivec2(xx, yy);

      // out of bound
      if (any(lessThan(p, ivec2(0))) ||
          any(greaterThanEqual(p, ivec2(renderInfoUbo.data.lowResSize)))) {
        continue;
      }

      vec3 color = unpackRGBE(imageLoad(blittedImage, p).x);
      mom1 += color;
      mom2 += color * color;

      if (xx == 0 && yy == 0) {
        colorCenter = color;
      }

      numSamples++;
    }
  }

  mom1 /= float(numSamples);
  mom2 /= float(numSamples);
}

vec2 getLongestMotion(ivec2 uv) {
  float len   = -1;
  vec2 motion = vec2(0);

  for (int yy = -1; yy <= 1; yy++) {
    for (int xx = -1; xx <= 1; xx++) {
      ivec2 p = uv + ivec2(xx, yy);
      vec2 m  = imageLoad(motionImage, p).xy;
      float l = dot(m, m);
      if (l > len) {
        len    = l;
        motion = m;
      }
    }
  }

  return motion;
}

vec3 getAccumColor(ivec2 pUv) {
  ivec2 bound = ivec2(renderInfoUbo.data.highResSize);
  if (any(lessThan(pUv, ivec2(0))) || any(greaterThanEqual(pUv, bound))) {
    return vec3(0);
  }
  return unpackRGBE(imageLoad(lastTaaImage, pUv).x);
}

float getSampleWeight(vec2 delta, float scale) {
  return clamp(1 - scale * dot(delta, delta), 0, 1);
}

// TODO: use texelFetch to use hardware bilinear interpolation, so does the temporalFilter
// uv is in low res space
vec3 softwareTexelFetchColor(vec2 uv) {
  vec2 pBaseUv = floor(uv);
  vec2 subpix  = fract(uv - pBaseUv);

  const ivec2 off[4] = {{0, 0}, {1, 0}, {0, 1}, {1, 1}};
  float w[4]         = {(1.0 - subpix.x) * (1.0 - subpix.y), (subpix.x) * (1.0 - subpix.y),
                        (1.0 - subpix.x) * (subpix.y), (subpix.x) * (subpix.y)};

  float sumOfWeights       = 0;
  vec3 sumOfWeightedColors = vec3(0);

  for (int i = 0; i < 4; i++) {
    ivec2 tappingUv = ivec2(pBaseUv) + off[i];
    sumOfWeightedColors += w[i] * getAccumColor(tappingUv);
    sumOfWeights += w[i];
  }
  return sumOfWeightedColors / sumOfWeights;
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (any(greaterThanEqual(uv, ivec2(renderInfoUbo.data.highResSize)))) {
    return;
  }

  vec2 lowResUv     = highResToLowRes(uv);
  ivec2 intLowResUv = ivec2(lowResUv);
  vec3 writingCol   = vec3(0);
  if (twickableParametersUbo.data.taa) {

    // get moments
    vec3 mom1, mom2;
    vec3 colorCenter;
    getMoments(mom1, mom2, colorCenter, intLowResUv);

    // motion points to the last frame
    // look up for its motion on the low res image
    vec2 motion = getLongestMotion(intLowResUv) * vec2(renderInfoUbo.data.highResSize);
    vec2 pUv    = vec2(uv) + motion;

    vec3 colorPrev = softwareTexelFetchColor(pUv);

    // neighborhood color clamping
    float varianceScale = 3.0;
    vec3 sigma          = sqrt(max(vec3(0), mom2 - mom1 * mom1));
    vec3 mi             = mom1 - sigma * varianceScale;
    vec3 ma             = mom1 + sigma * varianceScale;
    colorPrev           = clamp(colorPrev, mi, ma);

    // mix the new color with the clamped previous color
    float motionWeight = smoothstep(0, 1.0, length(motion));
    float sampleWeight =
        getSampleWeight(lowResUv - intLowResUv, float(renderInfoUbo.data.highResSize.x) /
                                                    float(renderInfoUbo.data.lowResSize.x));
    float pixelWeight = max(motionWeight, sampleWeight) * 0.1;
    pixelWeight       = clamp(pixelWeight, 0, 1);

    writingCol = mix(colorPrev, colorCenter, pixelWeight);

    imageStore(taaImage, uv, uvec4(packRGBE(writingCol), 0, 0, 0));
  } else {
    writingCol = unpackRGBE(imageLoad(blittedImage, intLowResUv).x).rgb;
  }

  // octree overlay
  if (twickableParametersUbo.data.visualizeOctree) {
    writingCol += unpackRGBE(imageLoad(octreeVisualizationImage, intLowResUv).x);
  }

  // dithering pattern, to reduce banding
  writingCol += getDitherMask(uv);

  // rgb to bgr
  imageStore(renderTargetImage, uv, vec4(writingCol.zyx, 1));
}