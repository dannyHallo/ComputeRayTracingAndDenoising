#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

#include "include/svoBuilderDescriptorSetLayouts.glsl"

uint compressNormal(vec3 normal) {
  // scale and bias from [-1, 1] to [0, 127]
  uvec3 quantized = uvec3(((normal + 1) * 0.5) * 127.0);

  // pack the 7-bit components into a single uint
  uint packed = (quantized.r) | (quantized.g << 7) | (quantized.b << 14);

  return packed;
}

void main() {
  if (gl_GlobalInvocationID.x >= fragmentListInfoBuffer.data.voxelResolution ||
      gl_GlobalInvocationID.y >= fragmentListInfoBuffer.data.voxelResolution ||
      gl_GlobalInvocationID.z >= fragmentListInfoBuffer.data.voxelResolution) {
    return;
  }

  if (gl_GlobalInvocationID.y == 0) {
    uint fragmentListCur = atomicAdd(fragmentListInfoBuffer.data.voxelFragmentCount, 1);

    G_FragmentListEntry ufragment;
    uint coordinatesData = 0;
    coordinatesData |= gl_GlobalInvocationID.x;
    coordinatesData |= gl_GlobalInvocationID.y << 10;
    coordinatesData |= gl_GlobalInvocationID.z << 20;
    ufragment.coordinates = coordinatesData;

    uint propertiesData  = 0;
    ufragment.properties = propertiesData;

    fragmentListBuffer.datas[fragmentListCur] = ufragment;
  }

  // G_FragmentListEntry ufragment = fragmentListBuffer.datas[gl_GlobalInvocationID.x];

  // uint coordinates = ufragment.coordinates;
  // ivec3 voxel_pos  = ivec3((coordinates & 0x3FF00000u) >> 20u, (coordinates & 0x000FFC00u) >>
  // 10u,
  //                          (coordinates & 0x000003FFu));

  // ivec3 directions[6] = ivec3[6](ivec3(1, 0, 0), ivec3(-1, 0, 0), ivec3(0, 1, 0), ivec3(0, -1,
  // 0),
  //                                ivec3(0, 0, 1), ivec3(0, 0, -1));

  // vec3 normal = vec3(0.0);
  // for (int i = 0; i < 6; i++) {
  //   ivec3 direction    = directions[i];
  //   ivec3 neighbor_pos = voxel_pos + direction;
  //   bool hasVoxel =
  //       imageLoad(fragmentListImage, ivec3(neighbor_pos.x, neighbor_pos.y, neighbor_pos.z)).x !=
  //       0;
  //   if (!hasVoxel) {
  //     normal += vec3(direction);
  //   }
  // }

  // normal = normal == vec3(0) ? vec3(0) : normalize(normal);
  // ufragment.properties |= compressNormal(normal) << 8u;

  // // store property buffer back
  // fragmentListBuffer.datas[gl_GlobalInvocationID.x] = ufragment;
}