#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

#include "include/svoBuilderDescriptorSetLayouts.glsl"

uint compressNormal(vec3 normal) {
  // scale and bias from [-1, 1] to [0, 127]
  uvec3 quantized = uvec3(((normal + 1) * 0.5) * 127.0);

  // pack the 7-bit components into a single uint
  uint packed = (quantized.r) | (quantized.g << 7) | (quantized.b << 14);

  return packed;
}

ivec3 lookupOffsets[8] = ivec3[8](ivec3(0, 0, 0), ivec3(1, 0, 0), ivec3(0, 1, 0), ivec3(1, 1, 0),
                                  ivec3(0, 0, 1), ivec3(1, 0, 1), ivec3(0, 1, 1), ivec3(1, 1, 1));

// TODO: use preloading functions to accelerate the loading process, this may speed up to 8x :)

void main() {
  if (gl_GlobalInvocationID.x >= fragmentListInfoBuffer.data.voxelResolution ||
      gl_GlobalInvocationID.y >= fragmentListInfoBuffer.data.voxelResolution ||
      gl_GlobalInvocationID.z >= fragmentListInfoBuffer.data.voxelResolution) {
    return;
  }

  ivec3 uv = ivec3(gl_GlobalInvocationID);

  ivec3 noiseLookupPositions[8];
  for (int i = 0; i < 8; i++) {
    noiseLookupPositions[i] = uv + lookupOffsets[i];
  }

  float noiseValues[8];
  for (int i = 0; i < 8; i++) {
    noiseValues[i] = imageLoad(chunkFieldImage, noiseLookupPositions[i]).x;
  }

  // if all values are both less than 0 or all are greater than 0, then it's not a surface voxel
  bool allLessThanZero    = true;
  bool allGreaterThanZero = true;

  for (int i = 0; i < 8; i++) {
    if (noiseValues[i] < 0) {
      allGreaterThanZero = false;
    } else {
      allLessThanZero = false;
    }
  }

  if (allLessThanZero || allGreaterThanZero) {
    return;
  }

  uint fragmentListCur = atomicAdd(fragmentListInfoBuffer.data.voxelFragmentCount, 1);

  // position
  G_FragmentListEntry ufragment;
  uint coordinatesData = 0;
  coordinatesData |= gl_GlobalInvocationID.x;
  coordinatesData |= gl_GlobalInvocationID.y << 10;
  coordinatesData |= gl_GlobalInvocationID.z << 20;
  ufragment.coordinates = coordinatesData;

  // normal
  float gradX = ((noiseValues[0] + noiseValues[2] + noiseValues[4] + noiseValues[6]) -
                 (noiseValues[1] + noiseValues[3] + noiseValues[5] + noiseValues[7])) *
                0.25;
  float gradY = ((noiseValues[0] + noiseValues[1] + noiseValues[4] + noiseValues[5]) -
                 (noiseValues[2] + noiseValues[3] + noiseValues[6] + noiseValues[7])) *
                0.25;
  float gradZ = ((noiseValues[0] + noiseValues[1] + noiseValues[2] + noiseValues[3]) -
                 (noiseValues[4] + noiseValues[5] + noiseValues[6] + noiseValues[7])) *
                0.25;
  vec3 normal         = normalize(vec3(gradX, gradY, gradZ));
  uint propertiesData = 0;
  propertiesData |= compressNormal(normal) << 8u;
  ufragment.properties = propertiesData;

  fragmentListBuffer.datas[fragmentListCur] = ufragment;
}