#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "include/svoTracerDescriptorSetLayouts.glsl"

#include "include/definitions.glsl"
#include "include/random.glsl"
#include "include/rayGen.glsl"

const uint STACK_SIZE = 23;
struct StackItem {
  uint node;
  float t_max;
} stack[STACK_SIZE + 1];

// this algorithm is from here:
// https://research.nvidia.com/sites/default/files/pubs/2010-02_Efficient-Sparse-Voxel/laine2010tr1_paper.pdf

// code reference:
// https://code.google.com/archive/p/efficient-sparse-voxel-octrees/
// https://github.com/AdamYuan/SparseVoxelOctree

// design decisions:
// 1. the position range of the octree is [1, 2], because the POP function need that bit
// comparison from the floating points ranged from [0, 1]
// 2. the traversing reduces branching by mirroring the coordinate system
// 3. all eight childrens are stored if at least one is active, so the parent node masks only need
// two bits (isLeaf and hasChild), this is different from the paper, which needs 16 bits for
// that

// this marching algorithm fetches leaf properties
bool detailedMarching(out float oT, out vec3 oPos, out vec3 oColor, out vec3 oNormal,
                      out uint oIter, out uint oVoxHash, out bool lightSourceHit, vec3 o, vec3 d) {
  uint iter    = 0;
  uint voxHash = 0;

  // avoid division by zero
  d = max(abs(d), vec3(kEpsilon)) * sign(d);

  vec3 t_coef = 1 / -abs(d);
  vec3 t_bias = t_coef * o;

  uint oct_mask = 0u;
  if (d.x > 0) oct_mask ^= 1u, t_bias.x = 3 * t_coef.x - t_bias.x;
  if (d.y > 0) oct_mask ^= 2u, t_bias.y = 3 * t_coef.y - t_bias.y;
  if (d.z > 0) oct_mask ^= 4u, t_bias.z = 3 * t_coef.z - t_bias.z;

  // initialize the active span of t-values
  float t_min = max(max(2 * t_coef.x - t_bias.x, 2 * t_coef.y - t_bias.y), 2 * t_coef.z - t_bias.z);
  float t_max = min(min(t_coef.x - t_bias.x, t_coef.y - t_bias.y), t_coef.z - t_bias.z);
  t_min       = max(t_min, 0);
  float h     = t_max;

  uint parent = 0;
  uint cur    = 0;
  vec3 pos    = vec3(1);
  uint idx    = 0;
  if (1.5f * t_coef.x - t_bias.x > t_min) {
    idx ^= 1u, pos.x = 1.5f;
  }
  if (1.5f * t_coef.y - t_bias.y > t_min) {
    idx ^= 2u, pos.y = 1.5f;
  }
  if (1.5f * t_coef.z - t_bias.z > t_min) {
    idx ^= 4u, pos.z = 1.5f;
  }

  uint scale       = STACK_SIZE - 1;
  float scale_exp2 = 0.5f;

  while (scale < STACK_SIZE) {
    ++iter;

    // parent pointer means the first pointer of the child node (8 in total)
    voxHash = parent + (idx ^ oct_mask);
    if (cur == 0u) cur = octreeBuffer[voxHash];

    vec3 t_corner = pos * t_coef - t_bias;
    float tc_max  = min(min(t_corner.x, t_corner.y), t_corner.z);

    if ((cur & 0x80000000u) != 0 && t_min <= t_max) {
      // INTERSECT
      float tv_max          = min(t_max, tc_max);
      float half_scale_exp2 = scale_exp2 * 0.5f;
      vec3 t_center         = half_scale_exp2 * t_coef + t_corner;

      if (t_min <= tv_max) {
        // leaf node
        if ((cur & 0x40000000u) != 0) break;

        // PUSH
        if (tc_max < h) {
          stack[scale].node  = parent;
          stack[scale].t_max = t_max;
        }
        h = tc_max;

        parent = cur & 0x3FFFFFFFu;

        idx = 0u;
        --scale;
        scale_exp2 = half_scale_exp2;
        if (t_center.x > t_min) idx ^= 1u, pos.x += scale_exp2;
        if (t_center.y > t_min) idx ^= 2u, pos.y += scale_exp2;
        if (t_center.z > t_min) idx ^= 4u, pos.z += scale_exp2;

        cur   = 0;
        t_max = tv_max;

        continue;
      }
    }

    // ADVANCE
    uint step_mask = 0u;
    if (t_corner.x <= tc_max) step_mask ^= 1u, pos.x -= scale_exp2;
    if (t_corner.y <= tc_max) step_mask ^= 2u, pos.y -= scale_exp2;
    if (t_corner.z <= tc_max) step_mask ^= 4u, pos.z -= scale_exp2;

    // update active t-span and flip bits of the child slot index
    t_min = tc_max;
    idx ^= step_mask;

    // proceed with pop if the bit flips disagree with the ray direction
    if ((idx & step_mask) != 0) {
      // POP
      // find the highest differing bit between the two positions
      uint differing_bits = 0;
      if ((step_mask & 1u) != 0)
        differing_bits |= floatBitsToUint(pos.x) ^ floatBitsToUint(pos.x + scale_exp2);
      if ((step_mask & 2u) != 0)
        differing_bits |= floatBitsToUint(pos.y) ^ floatBitsToUint(pos.y + scale_exp2);
      if ((step_mask & 4u) != 0)
        differing_bits |= floatBitsToUint(pos.z) ^ floatBitsToUint(pos.z + scale_exp2);
      scale      = findMSB(differing_bits);
      scale_exp2 = uintBitsToFloat((scale - STACK_SIZE + 127u) << 23u); // exp2f(scale - s_max)

      // restore parent voxel from the stack
      parent = stack[scale].node;
      t_max  = stack[scale].t_max;

      // round cube position and extract child slot index
      uint shx = floatBitsToUint(pos.x) >> scale;
      uint shy = floatBitsToUint(pos.y) >> scale;
      uint shz = floatBitsToUint(pos.z) >> scale;
      pos.x    = uintBitsToFloat(shx << scale);
      pos.y    = uintBitsToFloat(shy << scale);
      pos.z    = uintBitsToFloat(shz << scale);
      idx      = (shx & 1u) | ((shy & 1u) << 1u) | ((shz & 1u) << 2u);

      // prevent same parent from being stored again and invalidate cached child descriptor
      h = 0, cur = 0;
    }
  }

  vec3 t_corner = t_coef * (pos + scale_exp2) - t_bias;

  vec3 norm = (t_corner.x > t_corner.y && t_corner.x > t_corner.z)
                  ? vec3(-1, 0, 0)
                  : (t_corner.y > t_corner.z ? vec3(0, -1, 0) : vec3(0, 0, -1));
  if ((oct_mask & 1u) == 0u) norm.x = -norm.x;
  if ((oct_mask & 2u) == 0u) norm.y = -norm.y;
  if ((oct_mask & 4u) == 0u) norm.z = -norm.z;

  // undo mirroring of the coordinate system.
  if ((oct_mask & 1u) != 0u) pos.x = 3 - scale_exp2 - pos.x;
  if ((oct_mask & 2u) != 0u) pos.y = 3 - scale_exp2 - pos.y;
  if ((oct_mask & 4u) != 0u) pos.z = 3 - scale_exp2 - pos.z;

  // output results.
  oPos = clamp(o + t_min * d, pos, pos + scale_exp2);
  if (norm.x != 0) oPos.x = norm.x > 0 ? pos.x + scale_exp2 + kEpsilon * 2 : pos.x - kEpsilon;
  if (norm.y != 0) oPos.y = norm.y > 0 ? pos.y + scale_exp2 + kEpsilon * 2 : pos.y - kEpsilon;
  if (norm.z != 0) oPos.z = norm.z > 0 ? pos.z + scale_exp2 + kEpsilon * 2 : pos.z - kEpsilon;
  oNormal = norm;

  // https://registry.khronos.org/OpenGL-Refpages/gl4/html/unpackUnorm.xhtml
  uint colorIndex = cur & 0x000000FFu;
  if (colorIndex == 255) {
    oColor         = vec3(1, 0.4, 0.2) * 4;
    lightSourceHit = true;
  } else {
    uint colorFromPalette = paletteBuffer[colorIndex];
    oColor                = unpackUnorm4x8(colorFromPalette).xyz;
    lightSourceHit        = false;
  }

  oIter    = iter;
  oVoxHash = voxHash;
  oT       = t_min;

  return scale < STACK_SIZE && t_min <= t_max;
}

vec3 dayLightCalc(vec3 d) {
  vec3 maximumLight = vec3(1.0);
  float angle       = max(0, dot(d, vec3(0, 1, 0)));
  return maximumLight * angle;
}

void rayGen(out vec3 o, out vec3 d, vec2 subpixOffset) {
  vec2 uv = (vec2(gl_GlobalInvocationID.xy) + subpixOffset) /
            vec2(renderInfoUbo.data.swapchainWidth, renderInfoUbo.data.swapchainHeight);

  o = renderInfoUbo.data.camPosition;
  d = getRayDir(renderInfoUbo.data, uv);
}

uvec3 getSeed() {
  return uvec3(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, renderInfoUbo.data.currentSample);
}

vec3 traceTerminate(uvec3 seed, vec3 o, vec3 d) {
  vec3 pos, color, normal;
  uint iter, voxHash;
  bool lightSourceHit;
  float tMin;
  bool hit = detailedMarching(tMin, pos, color, normal, iter, voxHash, lightSourceHit, o, d);
  if (!hit) {
    return dayLightCalc(d);
  }

  if (lightSourceHit) {
    return color;
  }

  return vec3(0);
}

vec3 traceSecondary(uvec3 seed, vec3 o, vec3 d) {
  vec3 pos, color, normal;
  uint iter, voxHash;
  bool lightSourceHit;
  float tMin;
  bool hit = detailedMarching(tMin, pos, color, normal, iter, voxHash, lightSourceHit, o, d);
  if (!hit) {
    return dayLightCalc(d);
  }

  if (lightSourceHit) {
    return color;
  }

  // only consider direct lighting
  if (!twickableParametersUbo.data.traceSecondaryRay) {
    return vec3(0);
  }

  vec3 indirectRayDir = randomCosineWeightedHemispherePoint(normal, seed, BaseDisturbance(0), true);
  float pdf           = dot(indirectRayDir, normal) / kPi;
  vec3 brdf           = kInvPi * color;

  return traceTerminate(seed, pos + normal * kEpsilon, indirectRayDir) * brdf *
         dot(indirectRayDir, normal) / pdf;
  return vec3(0);
}

bool tracePrimary(out float oT, out uint oPrimaryRayIterUsed, out vec3 oColor, out vec3 oPosition,
                  out vec3 oNormal, out uint oVoxHash, uvec3 seed, vec3 o, vec3 d,
                  float optimizedDistance) {
  o += d * optimizedDistance;

  oColor = vec3(0.0);

  vec3 pos, color, normal;
  uint iter, voxHash;
  bool lightSourceHit;
  float tMin;
  bool hit = detailedMarching(tMin, pos, color, normal, iter, voxHash, lightSourceHit, o, d);
  oPrimaryRayIterUsed = iter;

  if (!hit) {
    oColor    = dayLightCalc(d);
    oPosition = vec3(0);
    oNormal   = vec3(0);
    oVoxHash  = 0;
    oT        = 1e10;
    return false;
  }
  oPosition = vec3(pos);
  oNormal   = vec3(normal);
  oVoxHash  = voxHash;
  oT        = tMin + optimizedDistance;

  if (lightSourceHit) {
    oColor = color;
    return true;
  }

  vec3 indirectRayDir = randomCosineWeightedHemispherePoint(normal, seed, BaseDisturbance(1), true);
  float pdf           = dot(indirectRayDir, normal) / kPi;
  vec3 brdf           = kInvPi * color;

  oColor = traceSecondary(seed, pos + normal * kEpsilon, indirectRayDir) * brdf *
           dot(indirectRayDir, normal) / pdf;

  return true;
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= renderInfoUbo.data.swapchainWidth || uv.y >= renderInfoUbo.data.swapchainHeight) {
    return;
  }

  uvec3 seed = getSeed();

  vec3 o, d;
  rayGen(o, d, vec2(0.5));

  float optimizedDistance = 0;

  // beam optimization
  if (twickableParametersUbo.data.beamOptimization) {
    ivec2 beamUv      = ivec2(gl_GlobalInvocationID.xy / sceneDataBuffer.data.beamResolution);
    float t1          = imageLoad(beamDepthImage, beamUv).r;
    float t2          = imageLoad(beamDepthImage, beamUv + ivec2(1, 0)).r;
    float t3          = imageLoad(beamDepthImage, beamUv + ivec2(0, 1)).r;
    float t4          = imageLoad(beamDepthImage, beamUv + ivec2(1, 1)).r;
    float t           = min(min(t1, t2), min(t3, t4));
    optimizedDistance = t;
  }

  uint dhIterUsed, voxHash;
  vec3 color;
  vec3 position, normal;
  float tMin;
  bool hit = tracePrimary(tMin, dhIterUsed, color, position, normal, voxHash, seed, o, d,
                          optimizedDistance);

  // the only image that is guaranteed to be written
  imageStore(hitImage, uv, vec4(hit ? 1 : 0, 0, 0, 0));
  if (hit) {
    imageStore(rawImage, uv, vec4(color, 1.0));
    imageStore(positionImage, uv, vec4(position, 1));
    imageStore(normalImage, uv, vec4(normal, 0));
    imageStore(voxHashImage, uv, uvec4(voxHash, 0, 0, 0));
    imageStore(depthImage, uv, vec4(tMin, 0, 0, 0));
  } else {
    imageStore(backgroundImage, uv, vec4(color, 1.0));
  }

  vec4 overlappingColor = vec4(0.0);
  overlappingColor      = vec4(vec3(1, 0.4, 0.2) * float(dhIterUsed) / 100, 1.0);
  imageStore(octreeVisualizationImage, uv, vec4(overlappingColor));
}
