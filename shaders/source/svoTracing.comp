#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "include/definitions.glsl"
#include "include/random.glsl"
#include "include/rayGen.glsl"
#include "include/svoTracerDescriptorSet.glsl"

const uint STACK_SIZE = 23;
struct StackItem {
  uint node;
  float t_max;
} stack[STACK_SIZE + 1];

// this algorithm is from here:
// https://research.nvidia.com/sites/default/files/pubs/2010-02_Efficient-Sparse-Voxel/laine2010tr1_paper.pdf

// code reference:
// https://code.google.com/archive/p/efficient-sparse-voxel-octrees/
// https://github.com/AdamYuan/SparseVoxelOctree

// design decisions:
// 1. the position range of the octree is [1, 2], because the POP function need that bit
// comparison from the floating points ranged from [0, 1]
// 2. the traversing reduces branching by mirroring the coordinate system
// 3. all eight childrens are stored if at least one is active, so the parent node masks only need
// two bits (isLeaf and hasChild), this is different from the paper, which needs 16 bits for
// that

// this marching algorithm fetches leaf properties
bool detailedMarching(out float oT, out vec3 oPos, out vec3 oColor, out vec3 oNormal,
                      out uint oIter, out uint oVoxHash, vec3 o, vec3 d) {
  uint iter    = 0;
  uint voxHash = 0;

  // avoid division by zero
  d = max(abs(d), vec3(kEpsilon)) * sign(d);

  vec3 t_coef = 1 / -abs(d);
  vec3 t_bias = t_coef * o;

  uint oct_mask = 0u;
  if (d.x > 0) oct_mask ^= 1u, t_bias.x = 3 * t_coef.x - t_bias.x;
  if (d.y > 0) oct_mask ^= 2u, t_bias.y = 3 * t_coef.y - t_bias.y;
  if (d.z > 0) oct_mask ^= 4u, t_bias.z = 3 * t_coef.z - t_bias.z;

  // initialize the active span of t-values
  float t_min = max(max(2 * t_coef.x - t_bias.x, 2 * t_coef.y - t_bias.y), 2 * t_coef.z - t_bias.z);
  float t_max = min(min(t_coef.x - t_bias.x, t_coef.y - t_bias.y), t_coef.z - t_bias.z);
  t_min       = max(t_min, 0);
  float h     = t_max;

  uint parent = 0;
  uint cur    = 0;
  vec3 pos    = vec3(1);
  uint idx    = 0;
  if (1.5f * t_coef.x - t_bias.x > t_min) {
    idx ^= 1u, pos.x = 1.5f;
  }
  if (1.5f * t_coef.y - t_bias.y > t_min) {
    idx ^= 2u, pos.y = 1.5f;
  }
  if (1.5f * t_coef.z - t_bias.z > t_min) {
    idx ^= 4u, pos.z = 1.5f;
  }

  uint scale       = STACK_SIZE - 1;
  float scale_exp2 = 0.5f;

  while (scale < STACK_SIZE) {
    ++iter;

    // parent pointer means the first pointer of the child node (8 in total)
    voxHash = parent + (idx ^ oct_mask);
    if (cur == 0u) cur = octreeBuffer[voxHash];

    vec3 t_corner = pos * t_coef - t_bias;
    float tc_max  = min(min(t_corner.x, t_corner.y), t_corner.z);

    if ((cur & 0x80000000u) != 0 && t_min <= t_max) {
      // INTERSECT
      float tv_max          = min(t_max, tc_max);
      float half_scale_exp2 = scale_exp2 * 0.5f;
      vec3 t_center         = half_scale_exp2 * t_coef + t_corner;

      if (t_min <= tv_max) {
        // leaf node
        if ((cur & 0x40000000u) != 0) break;

        // PUSH
        if (tc_max < h) {
          stack[scale].node  = parent;
          stack[scale].t_max = t_max;
        }
        h = tc_max;

        parent = cur & 0x3FFFFFFFu;

        idx = 0u;
        --scale;
        scale_exp2 = half_scale_exp2;
        if (t_center.x > t_min) idx ^= 1u, pos.x += scale_exp2;
        if (t_center.y > t_min) idx ^= 2u, pos.y += scale_exp2;
        if (t_center.z > t_min) idx ^= 4u, pos.z += scale_exp2;

        cur   = 0;
        t_max = tv_max;

        continue;
      }
    }

    // ADVANCE
    uint step_mask = 0u;
    if (t_corner.x <= tc_max) step_mask ^= 1u, pos.x -= scale_exp2;
    if (t_corner.y <= tc_max) step_mask ^= 2u, pos.y -= scale_exp2;
    if (t_corner.z <= tc_max) step_mask ^= 4u, pos.z -= scale_exp2;

    // update active t-span and flip bits of the child slot index
    t_min = tc_max;
    idx ^= step_mask;

    // proceed with pop if the bit flips disagree with the ray direction
    if ((idx & step_mask) != 0) {
      // POP
      // find the highest differing bit between the two positions
      uint differing_bits = 0;
      if ((step_mask & 1u) != 0)
        differing_bits |= floatBitsToUint(pos.x) ^ floatBitsToUint(pos.x + scale_exp2);
      if ((step_mask & 2u) != 0)
        differing_bits |= floatBitsToUint(pos.y) ^ floatBitsToUint(pos.y + scale_exp2);
      if ((step_mask & 4u) != 0)
        differing_bits |= floatBitsToUint(pos.z) ^ floatBitsToUint(pos.z + scale_exp2);
      scale      = findMSB(differing_bits);
      scale_exp2 = uintBitsToFloat((scale - STACK_SIZE + 127u) << 23u); // exp2f(scale - s_max)

      // restore parent voxel from the stack
      parent = stack[scale].node;
      t_max  = stack[scale].t_max;

      // round cube position and extract child slot index
      uint shx = floatBitsToUint(pos.x) >> scale;
      uint shy = floatBitsToUint(pos.y) >> scale;
      uint shz = floatBitsToUint(pos.z) >> scale;
      pos.x    = uintBitsToFloat(shx << scale);
      pos.y    = uintBitsToFloat(shy << scale);
      pos.z    = uintBitsToFloat(shz << scale);
      idx      = (shx & 1u) | ((shy & 1u) << 1u) | ((shz & 1u) << 2u);

      // prevent same parent from being stored again and invalidate cached child descriptor
      h = 0, cur = 0;
    }
  }

  vec3 t_corner = t_coef * (pos + scale_exp2) - t_bias;

  vec3 norm = (t_corner.x > t_corner.y && t_corner.x > t_corner.z)
                  ? vec3(-1, 0, 0)
                  : (t_corner.y > t_corner.z ? vec3(0, -1, 0) : vec3(0, 0, -1));
  if ((oct_mask & 1u) == 0u) norm.x = -norm.x;
  if ((oct_mask & 2u) == 0u) norm.y = -norm.y;
  if ((oct_mask & 4u) == 0u) norm.z = -norm.z;

  // undo mirroring of the coordinate system.
  if ((oct_mask & 1u) != 0u) pos.x = 3 - scale_exp2 - pos.x;
  if ((oct_mask & 2u) != 0u) pos.y = 3 - scale_exp2 - pos.y;
  if ((oct_mask & 4u) != 0u) pos.z = 3 - scale_exp2 - pos.z;

  // output results.
  oPos = clamp(o + t_min * d, pos, pos + scale_exp2);
  if (norm.x != 0) oPos.x = norm.x > 0 ? pos.x + scale_exp2 + kEpsilon * 2 : pos.x - kEpsilon;
  if (norm.y != 0) oPos.y = norm.y > 0 ? pos.y + scale_exp2 + kEpsilon * 2 : pos.y - kEpsilon;
  if (norm.z != 0) oPos.z = norm.z > 0 ? pos.z + scale_exp2 + kEpsilon * 2 : pos.z - kEpsilon;
  oNormal = norm;

  // https://registry.khronos.org/OpenGL-Refpages/gl4/html/unpackUnorm.xhtml
  uint colorFromPalette = paletteBuffer[cur & 0x000000FFu];
  oColor                = unpackUnorm4x8(colorFromPalette).xyz;

  oIter    = iter;
  oVoxHash = voxHash;
  oT       = t_min;

  return scale < STACK_SIZE && t_min <= t_max;
}

vec3 dayLightCalc(vec3 d) {
  vec3 maximumLight = vec3(1.0);
  float angle       = max(0, dot(d, vec3(0, 1, 0)));
  return maximumLight * angle;
}

void rayGen(out vec3 o, out vec3 d, vec2 subpixOffset) {
  vec2 uv = (vec2(gl_GlobalInvocationID.xy) + subpixOffset) /
            vec2(renderInfoUbo.data.swapchainWidth, renderInfoUbo.data.swapchainHeight);

  o = renderInfoUbo.data.camPosition;
  d = getRayDir(renderInfoUbo.data, uv);
}

uvec3 getSeed() {
  return uvec3(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, renderInfoUbo.data.currentSample);
}

vec3 traceTerminate(uvec3 seed, vec3 o, vec3 d) {
  vec3 pos, color, normal;
  uint iter, voxHash;
  float tMin;
  bool hit = detailedMarching(tMin, pos, color, normal, iter, voxHash, o, d);
  return hit ? vec3(0) : dayLightCalc(d);
}

vec3 traceSecondary(uvec3 seed, vec3 o, vec3 d) {
  vec3 pos, color, normal;
  uint iter, voxHash;
  float tMin;
  bool hit = detailedMarching(tMin, pos, color, normal, iter, voxHash, o, d);
  if (!hit) {
    return dayLightCalc(d);
  }

  // only consider direct lighting
  if (twickableParametersUbo.data.traceSecondaryRay == 0) {
    return vec3(0);
  }

  vec3 indirectRayDir = randomCosineWeightedHemispherePoint(normal, seed, BaseDisturbance(0), true);
  float pdf           = dot(indirectRayDir, normal) / kPi;
  vec3 brdf           = kInvPi * color;

  return traceTerminate(seed, pos + normal * kEpsilon, indirectRayDir) * brdf *
         dot(indirectRayDir, normal) / pdf;
  return vec3(0);
}

void tracePrimary(out float oT, out uint oPrimaryRayIterUsed, out vec3 oColor, out vec4 oPosition,
                  out vec4 oNormal, out uint oVoxHash, uvec3 seed, vec3 o, vec3 d,
                  float optimizedDistance) {
  o += d * optimizedDistance;

  oColor = vec3(0.0);

  vec3 pos, color, normal;
  uint iter, voxHash;
  float tMin;
  bool hit            = detailedMarching(tMin, pos, color, normal, iter, voxHash, o, d);
  oPrimaryRayIterUsed = iter;

  if (!hit) {
    oColor    = dayLightCalc(d); // or the skybox
    oPosition = vec4(0);
    oNormal   = vec4(0);
    oVoxHash  = 0;
    oT        = 1e10;
    return;
  }

  vec3 indirectRayDir = randomCosineWeightedHemispherePoint(normal, seed, BaseDisturbance(1), true);
  float pdf           = dot(indirectRayDir, normal) / kPi;
  vec3 brdf           = kInvPi * color;

  oColor = traceSecondary(seed, pos + normal * kEpsilon, indirectRayDir) * brdf *
           dot(indirectRayDir, normal) / pdf;
  oPosition = vec4(pos, 1);
  oNormal   = vec4(normal, 1);
  oVoxHash  = voxHash;

  // don't forget the optimized distance
  oT = tMin + optimizedDistance;
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= renderInfoUbo.data.swapchainWidth || uv.y >= renderInfoUbo.data.swapchainHeight) {
    return;
  }

  uvec3 seed = getSeed();

  vec3 o, d;
  rayGen(o, d, vec2(0.5));

  float optimizedDistance = 0;

  // beam optimization
  if (twickableParametersUbo.data.beamOptimization == 1) {
    ivec2 beamUv      = ivec2(gl_GlobalInvocationID.xy / sceneDataBufferObject.data.beamResolution);
    float t1          = imageLoad(beamDepthImage, beamUv).r;
    float t2          = imageLoad(beamDepthImage, beamUv + ivec2(1, 0)).r;
    float t3          = imageLoad(beamDepthImage, beamUv + ivec2(0, 1)).r;
    float t4          = imageLoad(beamDepthImage, beamUv + ivec2(1, 1)).r;
    float t           = min(min(t1, t2), min(t3, t4));
    optimizedDistance = t;
  }

  uint dhIterUsed, voxHash;
  vec3 color;
  vec4 position, normal;
  float tMin;
  tracePrimary(tMin, dhIterUsed, color, position, normal, voxHash, seed, o, d, optimizedDistance);
  // for position and normal:
  // w = 0 means no hit
  // w = 1 means hit

  imageStore(rawImage, uv, vec4(color, 1.0));
  imageStore(positionImage, uv, position);
  imageStore(normalImage, uv, normal);
  imageStore(voxHashImage, uv, uvec4(voxHash, 0, 0, 0));
  imageStore(depthImage, uv, vec4(tMin, 0, 0, 0));

  vec4 overlappingColor = vec4(0.0);
  overlappingColor      = vec4(vec3(1, 0.4, 0.2) * float(dhIterUsed) / 100, 1.0);
  imageStore(octreeVisualizationImage, uv, vec4(overlappingColor));
}
