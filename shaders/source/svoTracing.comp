#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// layout(binding = 1) uniform UniformBufferObject { uint a; }
// ubo;

layout(binding = 1, rgba32f) writeonly uniform image2D rawTex;
layout(std430, binding = 2) readonly buffer VoxelBufferObject { uint[] voxelBuffer; };
layout(std430, binding = 3) readonly buffer PaletteBufferObject { uint[] paletteBuffer; };

#include "include/definitions.glsl"
#include "include/globalUbo.glsl" // defines layout 0

const int MAX_ITER    = 100;
const uint kMaxLevels = 10u;

struct Ray {
  vec3 origin;
  vec3 dir;
};

const float[] scaleLookup = float[](1.0, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125,
                                    0.00390625, 0.001953125, 0.0009765625, 0.00048828125);

// returns t0 and t1, also fills tmid and tmax
bool isect(out float tcmin, out float tcmax, out vec3 tmid, out vec3 tmax, vec3 pos, float size,
           Ray camRay) {
  vec3 halfSize  = vec3(0.5 * size);
  vec3 minCorner = pos - halfSize;
  vec3 maxCorner = pos + halfSize;

  // xyz components of t for the ray to get to the 3 planes of minCorner
  vec3 t1 = (minCorner - camRay.origin) / camRay.dir;
  // xyz ...
  vec3 t2   = (maxCorner - camRay.origin) / camRay.dir;
  vec3 tmin = min(t1, t2);
  tmax      = max(t1, t2);
  tmid      = (tmin + tmax) * 0.5;

  tcmin = max(tmin.x, max(tmin.y, tmin.z));
  tcmax = min(tmax.x, min(tmax.y, tmax.z));

  tcmin = max(tcmin, 0.0);
  return tcmin <= tcmax;
}

uint countOnesInLastN(uint value, uint n) {
  uint mask         = 0xFFu >> (8u - n);
  uint relevantBits = value & mask;
  // bitCount is introduced after GLSL 4.00 (incl)
  return bitCount(relevantBits);
}

void parseParentNodeBuffer(out uint nextByteOffset, out bool hasNode, out bool childIsLeaf,
                           uint byteOffset, uint bitOffset) {
  uint voxelData    = voxelBuffer[byteOffset];
  childIsLeaf       = (voxelData & 0x00000100u) == 0x00000100u;
  uint hasChildMask = voxelData & 0x000000FFu;
  hasNode           = (hasChildMask & (1u << bitOffset)) != 0u;

  // only if the node is presented, we need to calculate the pointer offset (absolute offset)
  if (hasNode) {
    nextByteOffset = voxelData >> 9;
    nextByteOffset += byteOffset;
    // bitOffset range: 0-7, so the last n range is 1-8, so we need to +1
    // the first bit '1' indicates a delta of 0, so we need to -1
    nextByteOffset += countOnesInLastN(hasChildMask, bitOffset + 1u) - 1u;
  }
}

void fetchLeafBuffer(out uint leafVal, uint byteOffset) { leafVal = voxelBuffer[byteOffset]; }

const vec4 kBlack   = vec4(0.0, 0.0, 0.0, 1.0);
const vec4 kRed     = vec4(1.0, 0.0, 0.0, 1.0);
const vec4 kGreen   = vec4(0.0, 1.0, 0.0, 1.0);
const vec4 kBlue    = vec4(0.0, 0.0, 1.0, 1.0);
const vec4 kMagenta = vec4(0.5, 0.2, 0.5, 1.0);

vec4 getColor(uint leafVal) {
  leafVal = leafVal & 0x000000FFu;

  uint colorFromPalette = paletteBuffer[leafVal];
  float red             = float((colorFromPalette & 0xFF000000u) >> 24u) / 255.0;
  float green           = float((colorFromPalette & 0x00FF0000u) >> 16u) / 255.0;
  float blue            = float((colorFromPalette & 0x0000FF00u) >> 8u) / 255.0;
  // alpha channel is discarded
  float alpha = float(colorFromPalette & 0x000000FFu) / 255.0;

  return vec4(red, green, blue, 1.0);
}

// returns true if hit, false if miss
vec4 trace(out bool hit, out float tcmin, out float tcmax, out vec3 pos, out int iterUsed,
           Ray camRay) {
  struct LevelStack {
    vec3 pos;
    int scale; // size = exp2(float(-scale)), a lookup table is used
    vec3 idx;
    uint byteOffset;
    float h;
  } stack[kMaxLevels];

  int stackPtr = 0;
  hit          = false;
  iterUsed     = 0;

  // STEP 1: initialize
  int scale = 0;

  pos = vec3(0);
  vec3 tmid, tmax;
  bool canPush = true;
  if (!isect(tcmin, tcmax, tmid, tmax, pos, scaleLookup[scale], camRay)) {
    return kBlack;
  }

  float h = tcmax;

  // initial [PUSH], determine the first hited child (direct child of root node)
  // for x component, if tcmin < tmid.x, idx.x reverts the ray dir in x axis,
  // same for y and z
  vec3 idx = mix(-sign(camRay.dir), sign(camRay.dir), step(tmid, vec3(tcmin)));

  uint byteOffset = 0;
  scale++;

  // move to first hitted sub-cell center
  pos += scaleLookup[scale + 1] * idx;

  while (iterUsed++ < MAX_ITER) {
    // transform idx from [-1, 1] to [0, 1]
    vec3 idx01     = (idx + 1.0) * 0.5;
    uint bitOffset = uint(dot(idx01, vec3(1., 2., 4.))); // 0-7

    isect(tcmin, tcmax, tmid, tmax, pos, scaleLookup[scale], camRay);

    uint nextByteOffset;
    bool hasNode, childIsLeaf;
    // TODO: don't fetch if not necessary (store them in stack)

    parseParentNodeBuffer(nextByteOffset, hasNode, childIsLeaf, byteOffset, bitOffset);

    // [PUSH] repeatedly, until empty voxel is found
    // when pushed layer reached the same level as the smallest voxel, stop
    // and return (this is temporary solution for finding the leaf)
    if (canPush && hasNode) {
      // hits the leaf
      if (childIsLeaf) {
        hit = true;

        uint leafVal;
        fetchLeafBuffer(leafVal, nextByteOffset);
        return getColor(leafVal);
      }

      // tcmax is current voxel's exist time, h is parent voxel exist time
      if (tcmax < h) {
        stack[stackPtr++] = LevelStack(pos, scale, idx, byteOffset, h);
      }

      h = tcmax;
      scale++;

      // step: for element i of the return value, 0.0 is returned if x[i] <
      // edge[i], and 1.0 is returned otherwise.
      idx = mix(-sign(camRay.dir), sign(camRay.dir), step(tmid, vec3(tcmin)));

      byteOffset = nextByteOffset;

      pos += scaleLookup[scale + 1] * idx;
      continue;
    }

    // save the previous idx
    vec3 old = idx;

    // this is genius, for the hitted direction, if hit point is in the
    // middle, we advance to the other side, because this uses the direction
    // directly (not increment / bit flipping), if the next bit is outside of
    // the parent voxel, old will be equal to idx
    idx = mix(idx, sign(camRay.dir), equal(tmax, vec3(tcmax)));

    // idx has not changed -> [POP]
    if (idx == old) {
      // if poped all the way to the root
      // if (stackPtr == 0 || scale == 0)
      if (stackPtr == 0) {
        return kMagenta;
      }

      LevelStack s = stack[--stackPtr]; // restore to parent Stack
      pos          = s.pos;
      scale        = s.scale;
      idx          = s.idx;
      byteOffset   = s.byteOffset;
      h            = s.h;

      // once stack pop out, avoid pushing it in again
      canPush = false;
    }
    // idx has changed -> [ADVANCE]
    else {
      // if old = idx → stay,else → move forward in this stack
      pos += mix(vec3(0.), sign(camRay.dir), notEqual(old, idx)) * scaleLookup[scale];
      canPush = true;
    }
  }
  return kBlack;
}

vec2 rotate2d(vec2 v, float a) {
  float sinA = sin(a);
  float cosA = cos(a);
  return vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);
}

vec3 getPixelInScreenPosByDispatch(vec2 subpixOffset) {
  const vec3 origin = globalUbo.camPos;
  const vec3 front  = globalUbo.camFront;
  const vec3 up     = globalUbo.camUp;
  const vec3 right  = globalUbo.camRight;

  const float theta          = globalUbo.vfov * kDeg2Rad;
  const float h              = tan(theta / 2);
  const float viewportHeight = 2.0 * h;
  const float viewportWidth =
      float(globalUbo.swapchainWidth) / float(globalUbo.swapchainHeight) * viewportHeight;

  vec3 rayPropDir    = viewportWidth * right - viewportHeight * up;
  vec3 topLeftCorner = front - rayPropDir / 2;

  vec2 uv = (gl_GlobalInvocationID.xy + subpixOffset) /
            vec2(globalUbo.swapchainWidth, globalUbo.swapchainHeight);

  return topLeftCorner + viewportWidth * right * uv.x - viewportHeight * up * uv.y;
}

Ray rayGen(vec2 subpixOffset) {
  vec3 rayDir = normalize(getPixelInScreenPosByDispatch(subpixOffset));
  return Ray(globalUbo.camPos, rayDir);
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= globalUbo.swapchainWidth || uv.y >= globalUbo.swapchainHeight) {
    return;
  }

  Ray camRay = rayGen(vec2(0.5)); // no hist now

  // step 2: ray march
  float tcmin, tcmax;
  bool hit;
  vec3 pos;
  int iterUsed;
  vec4 fragColor = trace(hit, tcmin, tcmax, pos, iterUsed, camRay);

  vec4 overlappingColor = vec4(0.0);

  // customized shading
  overlappingColor = vec4(vec3(float(iterUsed) / MAX_ITER), 1.0);
  imageStore(rawTex, uv, fragColor + overlappingColor);
}
