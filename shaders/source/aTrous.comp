#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "include/svoTracerDescriptorSetLayouts.glsl"

#include "include/definitions.glsl"
#include "include/random.glsl"

// standard 3x3 filtering kernel from q2rtx
const float waveletFac      = 0.5;
const float kernel3x3[2][2] = {{1.0, waveletFac}, {waveletFac, waveletFac *waveletFac}};

vec2 gradientAtUv;
vec3 normalAtUv;
vec3 colorAtUv;
float depthAtUv;
// float varianceAtUv;
float luminanceAtUv;

ivec2 jittering(int stepSize) {
  uvec3 seed       = uvec3(gl_GlobalInvocationID.xy, renderInfoUbo.data.currentSample);
  vec2 randomNoise = vec2(random(seed), random(seed));
  randomNoise -= 0.5;
  randomNoise *= 0.5;
  ivec2 jitter = ivec2(randomNoise * stepSize);
  return jitter;
}

void loadDataFromPing(out vec3 oNormal, out vec3 oColor, out float oDepth, ivec2 uv) {
  ivec2 bound = ivec2(renderInfoUbo.data.swapchainWidth, renderInfoUbo.data.swapchainHeight);
  if (any(lessThan(uv, ivec2(0))) || any(greaterThanEqual(uv, bound))) {
    uv =
        clamp(uv, ivec2(0),
              ivec2(renderInfoUbo.data.swapchainWidth - 1, renderInfoUbo.data.swapchainHeight - 1));
  }

  oNormal = imageLoad(normalImage, uv).xyz;
  oColor  = imageLoad(aTrousPingImage, uv).xyz;
  oDepth  = imageLoad(depthImage, uv).x;
  // oVariance = imageLoad(varianceImage, uv).x;
}

void loadDataFromPong(out vec3 oNormal, out vec3 oColor, out float oDepth, ivec2 uv) {
  ivec2 bound = ivec2(renderInfoUbo.data.swapchainWidth, renderInfoUbo.data.swapchainHeight);
  if (any(lessThan(uv, ivec2(0))) || any(greaterThanEqual(uv, bound))) {
    uv =
        clamp(uv, ivec2(0),
              ivec2(renderInfoUbo.data.swapchainWidth - 1, renderInfoUbo.data.swapchainHeight - 1));
  }

  oNormal = imageLoad(normalImage, uv).xyz;
  oColor  = imageLoad(aTrousPongImage, uv).xyz;
  oDepth  = imageLoad(depthImage, uv).x;
  // oVariance = imageLoad(varianceImage, uv).x;
}

void blurKernel(ivec2 uv, ivec2 dispatchXY, int kernalHalfSize, inout float weightSum,
                inout vec4 sumOfWeightedValues) {
  int stepSize   = 1 << aTrousIterationBuffer.data;
  ivec2 offsetXY = dispatchXY * stepSize;
  if ((aTrousInfoUbo.data.useJittering != 0) && dispatchXY != ivec2(0)) {
    offsetXY += jittering(stepSize);
  }

  float weightK = kernel3x3[abs(dispatchXY.x)][abs(dispatchXY.y)];
  if (dispatchXY == ivec2(0)) {
    float weight = weightK;
    weight       = clamp(weight, 0, 1);
    weightSum += weight;
    sumOfWeightedValues += weight * vec4(colorAtUv, 1);
  } else {
    float weightC, weightN, weightZ;

    vec2 gradientAtSample;
    vec3 normalAtSample;
    vec3 colorAtSample;
    float depthAtSample;
    // float varianceAtSample;
    // first load from ping
    if (aTrousIterationBuffer.data % 2 == 0) {
      loadDataFromPing(normalAtSample, colorAtSample, depthAtSample, uv + offsetXY);
    } else {
      loadDataFromPong(normalAtSample, colorAtSample, depthAtSample, uv + offsetXY);
    }

    float luminanceAtSample = dot(kRgbToLuminanceMat, colorAtSample);
    float phiC              = aTrousInfoUbo.data.phiLuminance;
    if (aTrousInfoUbo.data.changingLuminancePhi != 0) {
      phiC = pow(2, -aTrousIterationBuffer.data) * aTrousInfoUbo.data.phiLuminance;
    }
    weightC       = 0;
    float colDiff = abs(luminanceAtSample - luminanceAtUv);
    // if (aTrousInfoUbo.data.useVarianceGuidedFiltering != 0) {
    //   phiC *= 100.;
    //   weightC = exp(-colDiff / max(phiC * sqrt(varianceAtUv), kEpsilon));
    // } else {
    weightC = exp(-colDiff / phiC);
    // }
    if (aTrousInfoUbo.data.ignoreLuminanceAtFirstIteration != 0 &&
        aTrousIterationBuffer.data == 0) {
      weightC = 1.0;
    }

    weightN = max(0., pow(dot(normalAtUv, normalAtSample), aTrousInfoUbo.data.phiNormal));

    float differenceInDepth = 0;
    // using gradient here can better blend samples within a single screen space tilted mesh
    //   differenceInDepth = abs((depthAtUv - depthAtSample) - dot(gradientAtUv, vec2(offsetXY)));
    differenceInDepth = abs(depthAtUv - depthAtSample);

    weightZ = exp(-differenceInDepth / aTrousInfoUbo.data.phiDepth);

    float weight = weightK * weightC * weightN * weightZ;
    weightSum += weight;
    sumOfWeightedValues += weight * vec4(colorAtSample, 1);
  }
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= renderInfoUbo.data.swapchainWidth || uv.y >= renderInfoUbo.data.swapchainHeight)
    return;

  if (aTrousIterationBuffer.data >= aTrousInfoUbo.data.aTrousIterationCount) return;

  // vec3 col3 = vec3(1.0) * aTrousIterationBuffer.data / 5;
  // imageStore(aTrousPongImage, uv, vec4(col3, 1));

  if (aTrousIterationBuffer.data % 2 == 0) {
    loadDataFromPing(normalAtUv, colorAtUv, depthAtUv, uv);
  } else {
    loadDataFromPong(normalAtUv, colorAtUv, depthAtUv, uv);
  }

  luminanceAtUv = dot(kRgbToLuminanceMat, colorAtUv);

  // if (aTrousInfoUbo.data.bypassBluring || aTrousIterationsInfo.data >=
  // aTrousIterationsInfo.dataCap) {
  //   if (aTrousIterationsInfo.data == 0) {
  //     imageStore(accumTex, uv, vec4(colorAtUv, 1));
  //   }
  //   imageStore(aTrousOutputTex, uv, vec4(colorAtUv, 1));
  //   return;
  // }

  const int kernelSize     = 3;
  const int kernalHalfSize = 1;

  float weightSum          = 0;
  vec4 sumOfWeightedValues = vec4(0);
  for (int indexX = -kernalHalfSize; indexX <= kernalHalfSize; indexX++) {
    for (int indexY = -kernalHalfSize; indexY <= kernalHalfSize; indexY++) {
      blurKernel(uv, ivec2(indexX, indexY), kernalHalfSize, weightSum, sumOfWeightedValues);
    }
  }

  vec4 weightedColor = sumOfWeightedValues / weightSum;

  if (aTrousIterationBuffer.data == 0) {
    imageStore(accumedImage, uv, weightedColor);
  }

  if (aTrousIterationBuffer.data % 2 == 0) {
    imageStore(aTrousPongImage, uv, weightedColor);
  } else {
    imageStore(aTrousPingImage, uv, weightedColor);
  }
}
