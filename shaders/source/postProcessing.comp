#version 450
#extension GL_GOOGLE_include_directive : require

#define STRATUM_SIZE 3

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "include/svoTracerDescriptorSetLayouts.glsl"

#define DISPLAY_TYPE_RAW 0

// this hashing function is probably to be the best one of its kind
// https://nullprogram.com/blog/2018/07/31/
uint hash(uint x) {
  x ^= x >> 16;
  x *= 0x7feb352dU;
  x ^= x >> 15;
  x *= 0x846ca68bU;
  x ^= x >> 16;
  return x;
}

// Converts a color from linear light gamma to sRGB gamma
// https://gamedev.stackexchange.com/questions/92015/optimized-linear-to-srgb-glsl
vec4 linearToSrgb(vec4 linearRGB) {
  bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));
  vec4 higher  = vec4(1.055) * pow(linearRGB, vec4(1.0 / 2.4)) - vec4(0.055);
  vec4 lower   = linearRGB * vec4(12.92);

  return mix(higher, lower, cutoff);
}

uvec2 decodeOffsetInStratum(uint offset) {
  return uvec2(offset % STRATUM_SIZE, offset / STRATUM_SIZE);
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= renderInfoUbo.data.swapchainWidth || uv.y >= renderInfoUbo.data.swapchainHeight) {
    return;
  }

  vec3 writingCol = vec3(0);
  writingCol      = imageLoad(aTrousPongImage, uv).xyz;

  // float depthHighRes           = imageLoad(depthImage, uv).x;
  // vec3 highResOverlappingColor = vec3(1, 0, 0) * exp(-depthHighRes);

  // ivec2 lookupUv              = ivec2(uv / sceneDataBuffer.data.beamResolution);
  // float depthLowRes           = imageLoad(beamDepthImage, lookupUv).x;
  // vec3 lowResOverlappingColor = vec3(0, 1, 0) * exp(-depthLowRes);

  // vec3 positionOverlappingColor = imageLoad(positionImage, uv).xyz - vec3(1);

  if (twickableParametersUbo.data.visualizeOctree == 1) {
    writingCol += imageLoad(octreeVisualizationImage, uv).xyz;
  }

  // rgb to bgr
  imageStore(renderTargetImage, uv, vec4(writingCol.zyx, 1));
}