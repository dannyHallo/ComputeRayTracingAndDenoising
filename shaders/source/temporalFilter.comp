#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "include/svoTracerDescriptorSetLayouts.glsl"

#include "include/definitions.glsl"

// when alpha is too low, the image is over-smoothed -> loss of detail
// when alpha is too high, the image is unstable     -> jitter of noise

ivec2 backwardProjection(ivec2 uv) {
  vec4 worldPos = imageLoad(positionImage, uv);

  mat4 mvpe;
  mvpe = renderInfoUbo.data.lastMvpe;

  vec4 screenBoxCoord = mvpe * worldPos;

  // points are bounded in [-1, 1] in x, y, z after the following
  screenBoxCoord /= screenBoxCoord.w;
  // points are bounded in [0, 1] in x, y, meanwhile z, w are thrown away
  screenBoxCoord = (screenBoxCoord + vec4(1)) / 2;
  // to vulkan uv coord, starts from top left corner, range is [0, 1]
  vec2 uvCoord = vec2(screenBoxCoord.x, 1 - screenBoxCoord.y);
  return ivec2(uvCoord.x * renderInfoUbo.data.swapchainWidth,
               uvCoord.y * renderInfoUbo.data.swapchainHeight);
}

vec4 getAccumColor(ivec2 pUv) {
  ivec2 bound = ivec2(renderInfoUbo.data.swapchainWidth, renderInfoUbo.data.swapchainHeight);
  if (any(lessThan(pUv, ivec2(0))) || any(greaterThanEqual(pUv, bound))) {
    return vec4(0, 0, 0, 0);
  }

  return imageLoad(lastAccumedImage, pUv);
}

bool isConsistent(ivec2 uv, ivec2 pUv) {
  // normal test is useful for edges (nearby disocclusions)
  vec3 normal           = imageLoad(normalImage, uv).xyz;
  vec3 lastNormal       = imageLoad(lastNormalImage, pUv).xyz;
  float normalFac       = pow(dot(normal, lastNormal), 128.);
  bool normalConsistent = normalFac > 0.99;

  // position test is useful for disocclusions happened in some distance
  vec3 position           = imageLoad(positionImage, uv).xyz;
  vec3 lastPosition       = imageLoad(lastPositionImage, pUv).xyz;
  float positionFac       = exp(-distance(position, lastPosition));
  bool positionConsistent = positionFac > temporalFilterInfoUbo.data.temporalPositionPhi;

  return normalConsistent && positionConsistent;
}

void main() {
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  if (uv.x >= renderInfoUbo.data.swapchainWidth || uv.y >= renderInfoUbo.data.swapchainHeight)
    return;

  bool hit = imageLoad(hitImage, uv).x != 0;
  if (!hit) {
    return;
  }

  float alphaBlending = temporalFilterInfoUbo.data.temporalAlpha;

  ivec2 pUv = backwardProjection(uv);

  vec4 rawColor     = imageLoad(rawImage, uv);
  vec4 accumedColor = getAccumColor(pUv);

  // float varianceBlending = 0;
  if (!isConsistent(uv, pUv)) {
    alphaBlending = 1;
    // varianceBlending = 1;
  }

  vec4 colToWrite = mix(accumedColor, rawColor, alphaBlending);
  imageStore(aTrousPingImage, uv, colToWrite);
  // vec4 accumVarianceHist = mix(imageLoad(lastVarianceHistImage, pUv), vec4(0), varianceBlending);
  // imageStore(varianceHistImage, uv, accumVarianceHist);
}